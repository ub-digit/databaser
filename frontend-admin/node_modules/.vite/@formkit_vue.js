import {
  camel,
  clone,
  cloneAny,
  compile,
  createClasses,
  createConfig$1,
  createLibraryPlugin,
  createMessage,
  createNode,
  empty,
  eq,
  error,
  errorHandler,
  except,
  extend,
  generateClassList,
  getNode$1,
  has,
  inputs,
  isComponent,
  isConditional,
  isDOM,
  isNode,
  isPojo,
  kebab,
  nodeProps,
  only,
  regexForFormat,
  reset,
  resetCount,
  setErrors,
  slugify,
  submitForm,
  sugar,
  token,
  useSchema,
  warn,
  warningHandler,
  watchRegistry
} from "./chunk-KH7O2Y2Z.js";
import {
  computed,
  createTextVNode,
  defineComponent,
  getCurrentInstance,
  h,
  inject,
  markRaw,
  onUnmounted,
  provide,
  reactive,
  ref,
  resolveComponent,
  watch,
  watchEffect
} from "./chunk-YKE26KAB.js";
import {
  __export,
  __objRest,
  __spreadProps,
  __spreadValues
} from "./chunk-VYIV4F7G.js";

// node_modules/@formkit/rules/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  accepted: () => accepted,
  alpha: () => alpha,
  alpha_spaces: () => alpha_spaces,
  alphanumeric: () => alphanumeric,
  between: () => between,
  confirm: () => confirm,
  date_after: () => date_after,
  date_before: () => date_before,
  date_between: () => date_between,
  date_format: () => date_format,
  email: () => email,
  ends_with: () => ends_with,
  is: () => is,
  length: () => length,
  matches: () => matches,
  max: () => max,
  min: () => min,
  not: () => not,
  number: () => number,
  required: () => required,
  starts_with: () => starts_with,
  url: () => url
});
var accepted = function accepted2({ value }) {
  return ["yes", "on", "1", 1, true, "true"].includes(value);
};
var date_after = function({ value }, compare = false) {
  const timestamp = Date.parse(compare || new Date());
  const fieldValue = Date.parse(String(value));
  return isNaN(fieldValue) ? false : fieldValue > timestamp;
};
var alpha = function({ value }, set = "default") {
  const sets = {
    default: /^[a-zA-ZÀ-ÖØ-öø-ÿĄąĆćĘęŁłŃńŚśŹźŻż]+$/,
    latin: /^[a-zA-Z]+$/
  };
  const selectedSet = has(sets, set) ? set : "default";
  return sets[selectedSet].test(String(value));
};
var alpha_spaces = function({ value }, set = "default") {
  const sets = {
    default: /^[a-zA-ZÀ-ÖØ-öø-ÿĄąĆćĘęŁłŃńŚśŹźŻż ]+$/,
    latin: /^[a-zA-Z ]+$/
  };
  const selectedSet = has(sets, set) ? set : "default";
  return sets[selectedSet].test(String(value));
};
var alphanumeric = function({ value }, set = "default") {
  const sets = {
    default: /^[a-zA-Z0-9À-ÖØ-öø-ÿĄąĆćĘęŁłŃńŚśŹźŻż]+$/,
    latin: /^[a-zA-Z0-9]+$/
  };
  const selectedSet = has(sets, set) ? set : "default";
  return sets[selectedSet].test(String(value));
};
var date_before = function({ value }, compare = false) {
  const timestamp = Date.parse(compare || new Date());
  const fieldValue = Date.parse(String(value));
  return isNaN(fieldValue) ? false : fieldValue < timestamp;
};
var between = function between2({ value }, from, to) {
  if (!isNaN(value) && !isNaN(from) && !isNaN(to)) {
    const val = 1 * value;
    from = Number(from);
    to = Number(to);
    const [a, b] = from <= to ? [from, to] : [to, from];
    return val >= 1 * a && val <= 1 * b;
  }
  return false;
};
var hasConfirm = /(_confirm(?:ed)?)$/;
var confirm = function confirm2(node, address, comparison = "loose") {
  var _a;
  if (!address) {
    address = hasConfirm.test(node.name) ? node.name.replace(hasConfirm, "") : `${node.name}_confirm`;
  }
  const foreignValue = (_a = node.at(address)) === null || _a === void 0 ? void 0 : _a.value;
  return comparison === "strict" ? node.value === foreignValue : node.value == foreignValue;
};
var date_between = function date_between2({ value }, dateA, dateB) {
  dateA = dateA instanceof Date ? dateA.getTime() : Date.parse(dateA);
  dateB = dateB instanceof Date ? dateB.getTime() : Date.parse(dateB);
  const compareTo = value instanceof Date ? value.getTime() : Date.parse(String(value));
  if (dateA && !dateB) {
    dateB = dateA;
    dateA = Date.now();
  } else if (!dateA || !compareTo) {
    return false;
  }
  return compareTo >= dateA && compareTo <= dateB;
};
var date_format = function date({ value }, format) {
  if (format && typeof format === "string") {
    return regexForFormat(format).test(String(value));
  }
  return !isNaN(Date.parse(String(value)));
};
var email = function email2({ value }) {
  const isEmail = /^(([^<>()\[\]\.,;:\s@\"]+(\.[^<>()\[\]\.,;:\s@\"]+)*)|(\".+\"))@(([^<>()[\]\.,;:\s@\"]+\.)+[^<>()[\]\.,;:\s@\"]{2,})$/i;
  return isEmail.test(String(value));
};
var ends_with = function ends_with2({ value }, ...stack) {
  if (typeof value === "string" && stack.length) {
    return stack.some((item) => {
      return value.endsWith(item);
    });
  } else if (typeof value === "string" && stack.length === 0) {
    return true;
  }
  return false;
};
var is = function is2({ value }, ...stack) {
  return stack.some((item) => {
    if (typeof item === "object") {
      return eq(item, value);
    }
    return item == value;
  });
};
var length = function length2({ value }, first = 0, second = Infinity) {
  first = parseInt(first);
  second = isNaN(parseInt(second)) ? Infinity : parseInt(second);
  const min3 = first <= second ? first : second;
  const max3 = second >= first ? second : first;
  if (typeof value === "string" || Array.isArray(value)) {
    return value.length >= min3 && value.length <= max3;
  } else if (value && typeof value === "object") {
    const length3 = Object.keys(value).length;
    return length3 >= min3 && length3 <= max3;
  }
  return false;
};
var matches = function matches2({ value }, ...stack) {
  return stack.some((pattern) => {
    if (typeof pattern === "string" && pattern.substr(0, 1) === "/" && pattern.substr(-1) === "/") {
      pattern = new RegExp(pattern.substr(1, pattern.length - 2));
    }
    if (pattern instanceof RegExp) {
      return pattern.test(String(value));
    }
    return pattern === value;
  });
};
var max = function max2({ value }, maximum = 10) {
  if (Array.isArray(value)) {
    return value.length <= maximum;
  }
  return Number(value) <= Number(maximum);
};
var min = function min2({ value }, minimum = 1) {
  if (Array.isArray(value)) {
    return value.length >= minimum;
  }
  return Number(value) >= Number(minimum);
};
var not = function not2({ value }, ...stack) {
  return !stack.some((item) => {
    if (typeof item === "object") {
      return eq(item, value);
    }
    return item === value;
  });
};
var number = function number2({ value }) {
  return !isNaN(value);
};
var required = function required2({ value }) {
  return !empty(value);
};
required.skipEmpty = false;
var starts_with = function starts_with2({ value }, ...stack) {
  if (typeof value === "string" && stack.length) {
    return stack.some((item) => {
      return value.startsWith(item);
    });
  } else if (typeof value === "string" && stack.length === 0) {
    return true;
  }
  return false;
};
var url = function url2({ value }, ...stack) {
  try {
    const protocols = stack.length ? stack : ["http:", "https:"];
    const url3 = new URL(String(value));
    return protocols.includes(url3.protocol);
  } catch {
    return false;
  }
};

// node_modules/@formkit/observer/dist/index.mjs
function createObserver(node, dependencies) {
  const deps = dependencies || Object.assign(/* @__PURE__ */ new Map(), { active: false });
  const receipts = /* @__PURE__ */ new Map();
  const addDependency = function(event) {
    var _a;
    if (!deps.active)
      return;
    if (!deps.has(node))
      deps.set(node, /* @__PURE__ */ new Set());
    (_a = deps.get(node)) === null || _a === void 0 ? void 0 : _a.add(event);
  };
  const observeProps = function(props2) {
    return new Proxy(props2, {
      get(...args) {
        typeof args[1] === "string" && addDependency(`prop:${args[1]}`);
        return Reflect.get(...args);
      }
    });
  };
  const observeLedger = function(ledger) {
    return new Proxy(ledger, {
      get(...args) {
        if (args[1] === "value") {
          return (key) => {
            addDependency(`count:${key}`);
            return ledger.value(key);
          };
        }
        return Reflect.get(...args);
      }
    });
  };
  const observe = function(value, property) {
    if (isNode(value)) {
      return createObserver(value, deps);
    }
    if (property === "value")
      addDependency("commit");
    if (property === "props")
      return observeProps(value);
    if (property === "ledger")
      return observeLedger(value);
    return value;
  };
  const { proxy: observed, revoke } = Proxy.revocable(node, {
    get(...args) {
      switch (args[1]) {
        case "deps":
          return deps;
        case "watch":
          return (block) => watch2(observed, block);
        case "observe":
          return () => {
            const old = new Map(deps);
            deps.clear();
            deps.active = true;
            return old;
          };
        case "stopObserve":
          return () => {
            const newDeps = new Map(deps);
            deps.active = false;
            return newDeps;
          };
        case "receipts":
          return receipts;
        case "kill":
          removeListeners(receipts);
          return () => revoke();
      }
      const value = Reflect.get(...args);
      if (typeof value === "function") {
        return (...subArgs) => {
          const subValue = value(...subArgs);
          return observe(subValue, args[1]);
        };
      }
      return observe(value, args[1]);
    }
  });
  return observed;
}
function applyListeners(node, [toAdd, toRemove], callback) {
  toAdd.forEach((events, depNode) => {
    events.forEach((event) => {
      node.receipts.has(depNode) || node.receipts.set(depNode, {});
      node.receipts.set(depNode, Object.assign(node.receipts.get(depNode), {
        [event]: depNode.on(event, callback)
      }));
    });
  });
  toRemove.forEach((events, depNode) => {
    events.forEach((event) => {
      if (node.receipts.has(depNode)) {
        const nodeReceipts = node.receipts.get(depNode);
        if (nodeReceipts && has(nodeReceipts, event)) {
          depNode.off(nodeReceipts[event]);
          delete nodeReceipts[event];
          node.receipts.set(depNode, nodeReceipts);
        }
      }
    });
  });
}
function removeListeners(receipts) {
  receipts.forEach((events, node) => {
    for (const event in events) {
      node.off(events[event]);
    }
  });
}
async function watch2(node, block) {
  const oldDeps = new Map(node.deps);
  node.observe();
  const res = block(node);
  if (res instanceof Promise)
    await res;
  const newDeps = node.stopObserve();
  applyListeners(node, diffDeps(oldDeps, newDeps), () => watch2(node, block));
}
function diffDeps(previous, current) {
  const toAdd = /* @__PURE__ */ new Map();
  const toRemove = /* @__PURE__ */ new Map();
  current.forEach((events, node) => {
    if (!previous.has(node)) {
      toAdd.set(node, events);
    } else {
      const eventsToAdd = /* @__PURE__ */ new Set();
      const previousEvents = previous.get(node);
      events.forEach((event) => !(previousEvents === null || previousEvents === void 0 ? void 0 : previousEvents.has(event)) && eventsToAdd.add(event));
      toAdd.set(node, eventsToAdd);
    }
  });
  previous.forEach((events, node) => {
    if (!current.has(node)) {
      toRemove.set(node, events);
    } else {
      const eventsToRemove = /* @__PURE__ */ new Set();
      const newEvents = current.get(node);
      events.forEach((event) => !(newEvents === null || newEvents === void 0 ? void 0 : newEvents.has(event)) && eventsToRemove.add(event));
      toRemove.set(node, eventsToRemove);
    }
  });
  return [toAdd, toRemove];
}

// node_modules/@formkit/validation/dist/index.mjs
var validatingMessage = createMessage({
  type: "state",
  blocking: true,
  visible: false,
  value: true,
  key: "validating"
});
function createValidationPlugin(baseRules = {}) {
  return function validationPlugin(node) {
    const availableRules = Object.assign({}, baseRules, node.props.validationRules);
    const observedNode = createObserver(node);
    const state = { input: token(), rerun: null, isPassing: true };
    node.on("prop", (event) => {
      if (event.payload.prop === "validation") {
        removeListeners(observedNode.receipts);
        node.store.filter(() => false, "validation");
        node.props.parsedRules = parseRules(event.payload.value, availableRules);
        validate(observedNode, node.props.parsedRules, state);
      }
    });
    node.props.parsedRules = parseRules(node.props.validation, availableRules);
    validate(observedNode, node.props.parsedRules, state);
  };
}
function validate(node, validations, state) {
  state.input = token();
  state.isPassing = true;
  node.store.filter((message) => !message.meta.removeImmediately, "validation");
  validations.forEach((validation2) => validation2.debounce && clearTimeout(validation2.timer));
  if (validations.length) {
    node.store.set(validatingMessage);
    run(0, validations, node, state, false, () => {
      node.store.remove(validatingMessage.key);
    });
  }
}
function run(current, validations, node, state, removeImmediately, complete) {
  const validation2 = validations[current];
  if (!validation2)
    return complete();
  const currentRun = state.input;
  validation2.state = null;
  function next(async, result) {
    state.isPassing = state.isPassing && !!result;
    validation2.queued = false;
    const newDeps = node.stopObserve();
    applyListeners(node, diffDeps(validation2.deps, newDeps), () => {
      validation2.queued = true;
      if (state.rerun)
        clearTimeout(state.rerun);
      state.rerun = setTimeout(validate, 0, node, validations, state);
    });
    validation2.deps = newDeps;
    if (state.input === currentRun) {
      validation2.state = result;
      if (result === false) {
        createFailedMessage(node, validation2, removeImmediately || async);
      } else {
        removeMessage(node, validation2);
      }
      if (validations.length > current + 1) {
        run(current + 1, validations, node, state, removeImmediately || async, complete);
      } else {
        complete();
      }
    }
  }
  if ((!empty(node.value) || !validation2.skipEmpty) && (state.isPassing || validation2.force)) {
    if (validation2.queued) {
      runRule(validation2, node, (result) => {
        result instanceof Promise ? result.then((r) => next(true, r)) : next(false, result);
      });
    } else {
      run(current + 1, validations, node, state, removeImmediately, complete);
    }
  } else {
    if (empty(node.value) && validation2.skipEmpty && state.isPassing) {
      node.observe();
      node.value;
    }
    next(false, null);
  }
}
function runRule(validation2, node, after) {
  if (validation2.debounce) {
    validation2.timer = setTimeout(() => {
      node.observe();
      after(validation2.rule(node, ...validation2.args));
    }, validation2.debounce);
  } else {
    node.observe();
    after(validation2.rule(node, ...validation2.args));
  }
}
function removeMessage(node, validation2) {
  const key = `rule_${validation2.name}`;
  if (has(node.store, key)) {
    node.store.remove(key);
  }
}
function createFailedMessage(node, validation2, removeImmediately) {
  const i18nArgs = createI18nArgs(node, validation2);
  const customMessage = createCustomMessage(node, validation2, i18nArgs);
  const message = createMessage({
    blocking: validation2.blocking,
    key: `rule_${validation2.name}`,
    meta: {
      messageKey: validation2.name,
      removeImmediately,
      localize: !customMessage,
      i18nArgs
    },
    type: "validation",
    value: customMessage || "This field is not valid."
  });
  node.store.set(message);
  return message;
}
function createCustomMessage(node, validation2, i18nArgs) {
  const customMessage = node.props.validationMessages && has(node.props.validationMessages, validation2.name) ? node.props.validationMessages[validation2.name] : void 0;
  if (typeof customMessage === "function") {
    return customMessage(...i18nArgs);
  }
  return customMessage;
}
function createI18nArgs(node, validation2) {
  return [
    {
      node,
      name: createMessageName(node),
      args: validation2.args
    }
  ];
}
function createMessageName(node) {
  if (typeof node.props.validationLabel === "function") {
    return node.props.validationLabel(node);
  }
  return node.props.validationLabel || node.props.label || node.props.name || String(node.name);
}
var hintPattern = "(?:[\\*+?()0-9]+)";
var rulePattern = "[a-zA-Z][a-zA-Z0-9_]+";
var ruleExtractor = new RegExp(`^(${hintPattern}?${rulePattern})(?:\\:(.*)+)?$`, "i");
var hintExtractor = new RegExp(`^(${hintPattern})(${rulePattern})$`, "i");
var debounceExtractor = /([\*+?]+)?(\(\d+\))([\*+?]+)?/;
var hasDebounce = /\(\d+\)/;
var defaultHints = {
  blocking: true,
  debounce: 0,
  force: false,
  skipEmpty: true,
  name: ""
};
function parseRules(validation2, rules) {
  if (!validation2)
    return [];
  const intents = typeof validation2 === "string" ? extractRules(validation2) : clone(validation2);
  return intents.reduce((validations, args) => {
    let rule = args.shift();
    const hints = {};
    if (typeof rule === "string") {
      const [ruleName, parsedHints] = parseHints(rule);
      if (has(rules, ruleName)) {
        rule = rules[ruleName];
        Object.assign(hints, parsedHints);
      }
    }
    if (typeof rule === "function") {
      validations.push(__spreadValues(__spreadValues({
        rule,
        args,
        timer: 0,
        state: null,
        queued: true,
        deps: /* @__PURE__ */ new Map()
      }, defaultHints), fnHints(hints, rule)));
    }
    return validations;
  }, []);
}
function extractRules(validation2) {
  return validation2.split("|").reduce((rules, rule) => {
    const parsedRule = parseRule(rule);
    if (parsedRule) {
      rules.push(parsedRule);
    }
    return rules;
  }, []);
}
function parseRule(rule) {
  const trimmed = rule.trim();
  if (trimmed) {
    const matches3 = trimmed.match(ruleExtractor);
    if (matches3 && typeof matches3[1] === "string") {
      const ruleName = matches3[1].trim();
      const args = matches3[2] && typeof matches3[2] === "string" ? matches3[2].split(",").map((s) => s.trim()) : [];
      return [ruleName, ...args];
    }
  }
  return false;
}
function parseHints(ruleName) {
  const matches3 = ruleName.match(hintExtractor);
  if (!matches3) {
    return [ruleName, { name: ruleName }];
  }
  const map = {
    "*": { force: true },
    "+": { skipEmpty: false },
    "?": { blocking: false }
  };
  const [, hints, rule] = matches3;
  const hintGroups = hasDebounce.test(hints) ? hints.match(debounceExtractor) || [] : [, hints];
  return [
    rule,
    [hintGroups[1], hintGroups[2], hintGroups[3]].reduce((hints2, group) => {
      if (!group)
        return hints2;
      if (hasDebounce.test(group)) {
        hints2.debounce = parseInt(group.substr(1, group.length - 1));
      } else {
        group.split("").forEach((hint) => has(map, hint) && Object.assign(hints2, map[hint]));
      }
      return hints2;
    }, { name: rule })
  ];
}
function fnHints(existingHints, rule) {
  if (!existingHints.name) {
    existingHints.name = rule.ruleName || rule.name;
  }
  return ["skipEmpty", "force", "debounce", "blocking"].reduce((hints, hint) => {
    if (has(rule, hint) && !has(hints, hint)) {
      Object.assign(hints, {
        [hint]: rule[hint]
      });
    }
    return hints;
  }, existingHints);
}

// node_modules/@formkit/i18n/dist/index.mjs
function sentence(str) {
  return str[0].toUpperCase() + str.substr(1);
}
function list(items, conjunction = "or") {
  return items.reduce((oxford, item, index) => {
    oxford += item;
    if (index <= items.length - 2 && items.length > 2) {
      oxford += ", ";
    }
    if (index === items.length - 2) {
      oxford += `${items.length === 2 ? " " : ""}${conjunction} `;
    }
    return oxford;
  }, "");
}
function date2(date3) {
  const dateTime = typeof date3 === "string" ? new Date(Date.parse(date3)) : date3;
  if (!(dateTime instanceof Date)) {
    return "(unknown)";
  }
  return new Intl.DateTimeFormat(void 0, {
    dateStyle: "medium"
  }).format(dateTime);
}
function order(first, second) {
  return Number(first) >= Number(second) ? [second, first] : [first, second];
}
var ui$l = {
  remove: "\u0625\u0632\u0627\u0644\u0629",
  removeAll: "\u0625\u0632\u0627\u0644\u0629 \u0627\u0644\u0643\u0644",
  incomplete: "\u0639\u0630\u0631\u0627\u060C \u0644\u0645 \u064A\u062A\u0645 \u062A\u0639\u0628\u0626\u0629 \u062C\u0645\u064A\u0639 \u0627\u0644\u062D\u0642\u0648\u0644 \u0628\u0634\u0643\u0644 \u0635\u062D\u064A\u062D.",
  submit: "\u0625\u0631\u0633\u0627\u0644",
  noFiles: "\u0644\u0627 \u064A\u0648\u062C\u062F \u0645\u0644\u0641 \u0645\u062E\u062A\u0627\u0631"
};
var validation$l = {
  accepted({ name }) {
    return `\u0627\u0644\u0631\u062C\u0627\u0621 \u0642\u0628\u0648\u0644 ${name}.`;
  },
  date_after({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0628\u0639\u062F ${date2(args[0])}.`;
    }
    return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0641\u064A \u0627\u0644\u0645\u0633\u062A\u0642\u0628\u0644.`;
  },
  alpha({ name }) {
    return `\u064A\u0645\u0643\u0646 \u0623\u0646 \u064A\u062D\u062A\u0648\u064A ${sentence(name)} \u0639\u0644\u0649 \u0623\u062D\u0631\u0641 \u0623\u0628\u062C\u062F\u064A\u0629 \u0641\u0642\u0637.`;
  },
  alphanumeric({ name }) {
    return `\u064A\u0645\u0643\u0646 \u0623\u0646 \u064A\u062D\u062A\u0648\u064A ${sentence(name)} \u0639\u0644\u0649 \u0623\u062D\u0631\u0641 \u0648\u0623\u0631\u0642\u0627\u0645 \u0641\u0642\u0637.`;
  },
  alpha_spaces({ name }) {
    return `\u064A\u0645\u0643\u0646 \u0623\u0646 \u062A\u062D\u062A\u0648\u064A ${sentence(name)} \u0639\u0644\u0649 \u0623\u062D\u0631\u0641 \u0648\u0645\u0633\u0627\u0641\u0627\u062A \u0641\u0642\u0637.`;
  },
  date_before({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0642\u0628\u0644 ${date2(args[0])}.`;
    }
    return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0641\u064A \u0627\u0644\u0645\u0627\u0636\u064A.`;
  },
  between({ name, args }) {
    if (isNaN(args[0]) || isNaN(args[1])) {
      return `\u062A\u0645\u062A \u062A\u0647\u064A\u0626\u0629 \u0647\u0630\u0627 \u0627\u0644\u062D\u0642\u0644 \u0628\u0634\u0643\u0644 \u063A\u064A\u0631 \u0635\u062D\u064A\u062D \u0648\u0644\u0627 \u064A\u0645\u0643\u0646 \u0625\u0631\u0633\u0627\u0644\u0647.`;
    }
    const [a, b] = order(args[0], args[1]);
    return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0645\u0627 \u0628\u064A\u0646 ${a} \u0648 ${b}.`;
  },
  confirm({ name }) {
    return `${sentence(name)} \u063A\u064A\u0631 \u0645\u062A\u0637\u0627\u0628\u0642.`;
  },
  date_format({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} \u0644\u064A\u0633 \u062A\u0627\u0631\u064A\u062E\u064B\u0627 \u0635\u0627\u0644\u062D\u064B\u0627 \u060C \u064A\u0631\u062C\u0649 \u0627\u0633\u062A\u062E\u062F\u0627\u0645 \u0627\u0644\u062A\u0646\u0633\u064A\u0642 ${args[0]}`;
    }
    return "\u062A\u0645\u062A \u062A\u0647\u064A\u0626\u0629 \u0647\u0630\u0627 \u0627\u0644\u062D\u0642\u0644 \u0628\u0634\u0643\u0644 \u063A\u064A\u0631 \u0635\u062D\u064A\u062D \u0648\u0644\u0627 \u064A\u0645\u0643\u0646 \u0625\u0631\u0633\u0627\u0644\u0647";
  },
  date_between({ name, args }) {
    return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0628\u064A\u0646 ${date2(args[0])} \u0648 ${date2(args[1])}`;
  },
  email: "\u0627\u0644\u0631\u062C\u0627\u0621 \u0623\u062F\u062E\u0627\u0644 \u0628\u0631\u064A\u062F \u0625\u0644\u064A\u0643\u062A\u0631\u0648\u0646\u064A \u0635\u0627\u0644\u062D.",
  ends_with({ name, args }) {
    return `\u0644\u0627 \u064A\u0646\u062A\u0647\u064A ${sentence(name)} \u0628\u0640 ${list(args)}.`;
  },
  is({ name }) {
    return `${sentence(name)} \u0644\u064A\u0633\u062A \u0642\u064A\u0645\u0629 \u0645\u0633\u0645\u0648\u062D \u0628\u0647\u0627.`;
  },
  length({ name, args: [first = 0, second = Infinity] }) {
    const min3 = Number(first) <= Number(second) ? first : second;
    const max3 = Number(second) >= Number(first) ? second : first;
    if (min3 == 1 && max3 === Infinity) {
      return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u062D\u0631\u0641\u064B\u0627 \u0648\u0627\u062D\u062F\u064B\u0627 \u0639\u0644\u0649 \u0627\u0644\u0623\u0642\u0644.`;
    }
    if (min3 == 0 && max3) {
      return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0623\u0642\u0644 \u0645\u0646 \u0623\u0648 \u064A\u0633\u0627\u0648\u064A ${max3} \u062D\u0631\u0641\u064B\u0627.`;
    }
    if (min3 && max3 === Infinity) {
      return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0623\u0643\u0628\u0631 \u0645\u0646 \u0623\u0648 \u064A\u0633\u0627\u0648\u064A ${min3} \u062D\u0631\u0641\u064B\u0627.`;
    }
    return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0628\u064A\u0646 ${min3} \u0648 ${max3} \u062D\u0631\u0641\u064B\u0627.`;
  },
  matches({ name }) {
    return `${sentence(name)} \u0644\u064A\u0633\u062A \u0642\u064A\u0645\u0629 \u0645\u0633\u0645\u0648\u062D \u0628\u0647\u0627.`;
  },
  max({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `\u0644\u0627 \u064A\u0645\u0643\u0646 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0623\u0643\u062B\u0631 \u0645\u0646 ${args[0]} ${name}.`;
    }
    return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0623\u0642\u0644 \u0645\u0646 \u0623\u0648 \u064A\u0633\u0627\u0648\u064A ${args[0]}.`;
  },
  mime({ name, args }) {
    if (!args[0]) {
      return "\u0644\u0627 \u064A\u0633\u0645\u062D \u0628\u062A\u0646\u0633\u064A\u0642\u0627\u062A \u0627\u0644\u0645\u0644\u0641\u0627\u062A.";
    }
    return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0645\u0646 \u0627\u0644\u0646\u0648\u0639: ${args[0]}`;
  },
  min({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `\u0644\u0627 \u064A\u0645\u0643\u0646 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0623\u0642\u0644 \u0645\u0646 ${args[0]} ${name}.`;
    }
    return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0639\u0644\u0649 \u0627\u0644\u0623\u0642\u0644 ${args[0]}.`;
  },
  not({ name, node: { value } }) {
    return `\u201C${value}\u201D \u0644\u064A\u0633 ${name} \u0645\u0633\u0645\u0648\u062D\u064B\u0627 \u0628\u0647.`;
  },
  number({ name }) {
    return `${sentence(name)} \u064A\u062C\u0628 \u0627\u0646 \u064A\u0643\u0648\u0646 \u0631\u0642\u0645\u0627\u064B`;
  },
  required({ name }) {
    return `${sentence(name)} \u0645\u0637\u0644\u0648\u0628.`;
  },
  starts_with({ name, args }) {
    return `\u0644\u0627 \u064A\u0628\u062F\u0623 ${sentence(name)} \u0628\u0640 ${list(args)}.`;
  },
  url() {
    return `\u0627\u0644\u0631\u062C\u0627\u0621 \u062A\u0636\u0645\u064A\u0646 \u0639\u0646\u0648\u0627\u0646 \u0631\u0627\u0628\u0637 \u0635\u062D\u064A\u062D.`;
  }
};
var ar = Object.freeze({
  __proto__: null,
  ui: ui$l,
  validation: validation$l
});
var ui$k = {
  remove: "Odebrat",
  removeAll: "Odebrat v\u0161e",
  incomplete: "Pardon, ale ne v\u0161echna pole jsou vypln\u011Bna spr\xE1vn\u011B.",
  submit: "Odeslat",
  noFiles: "\u017D\xE1dn\xFD soubor nebyl vybr\xE1n"
};
var validation$k = {
  accepted({ name }) {
    return `Pros\xEDm, za\u0161krtn\u011Bte ${name}.`;
  },
  date_after({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} mus\xED b\xFDt po ${date2(args[0])}.`;
    }
    return `${sentence(name)} mus\xED b\xFDt v budoucnosti.`;
  },
  alpha({ name }) {
    return `${sentence(name)} m\u016F\u017Ee obsahovat pouze p\xEDsmena.`;
  },
  alphanumeric({ name }) {
    return `${sentence(name)} m\u016F\u017Ee obsahovat pouze p\xEDsmena a \u010D\xEDsla.`;
  },
  date_before({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} mus\xED b\xFDt p\u0159ed ${date2(args[0])}.`;
    }
    return `${sentence(name)} mus\xED b\xFDt v minulosti.`;
  },
  between({ name, args }) {
    if (isNaN(args[0]) || isNaN(args[1])) {
      return `Toto pole bylo \u0161patn\u011B nakonfigurov\xE1no a nem\u016F\u017Ee b\xFDt odesl\xE1no.`;
    }
    const [a, b] = order(args[0], args[1]);
    return `${sentence(name)} mus\xED b\xFDt mezi ${a} a ${b}.`;
  },
  confirm({ name }) {
    return `${sentence(name)} nejsou shodn\xE1.`;
  },
  date_format({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} nen\xED platn\xE9 datum, pros\xEDm, pou\u017Eijte form\xE1t ${args[0]}`;
    }
    return "Toto pole bylo \u0161patn\u011B nakonfigurov\xE1no a nem\u016F\u017Ee b\xFDt odesl\xE1no.";
  },
  date_between({ name, args }) {
    return `${sentence(name)} mus\xED b\xFDt mezi ${date2(args[0])} a ${date2(args[1])}`;
  },
  email: "Pros\xEDm, zadejte platnou e-mailovou adresu.",
  ends_with({ name, args }) {
    return `${sentence(name)} nekon\u010D\xED na ${list(args)}.`;
  },
  is({ name }) {
    return `${sentence(name)} nen\xED povolen\xE1 hodnota.`;
  },
  length({ name, args: [first = 0, second = Infinity] }) {
    const min3 = Number(first) <= Number(second) ? first : second;
    const max3 = Number(second) >= Number(first) ? second : first;
    if (min3 == 1 && max3 === Infinity) {
      return `${sentence(name)} mus\xED m\xEDt nejm\xE9n\u011B jeden znak.`;
    }
    if (min3 == 0 && max3) {
      return `${sentence(name)} m\u016F\u017Ee m\xEDt maxim\xE1ln\u011B ${max3} znak\u016F.`;
    }
    if (min3 && max3 === Infinity) {
      return `${sentence(name)} mus\xED obsahovat minim\xE1ln\u011B ${min3} znak\u016F.`;
    }
    return `${sentence(name)} mus\xED b\xFDt dlouh\xE9 ${min3} a\u017E ${max3} znak\u016F.`;
  },
  matches({ name }) {
    return `${sentence(name)} nen\xED povolen\xE1 hodnota.`;
  },
  max({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Nelze pou\u017E\xEDt v\xEDce ne\u017E ${args[0]} ${name}.`;
    }
    return `${sentence(name)} mus\xED m\xEDt men\u0161\xED nebo rovno ne\u017E ${args[0]}.`;
  },
  mime({ name, args }) {
    if (!args[0]) {
      return "Nejsou nakonfigurov\xE1ny povolen\xE9 typy soubor\u016F.";
    }
    return `${sentence(name)} mus\xED b\xFDt typu: ${args[0]}`;
  },
  min({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Nelze m\xEDt m\xE9n\u011B ne\u017E ${args[0]} ${name}.`;
    }
    return `${sentence(name)} mus\xED b\xFDt minim\xE1ln\u011B ${args[0]}.`;
  },
  not({ name, node: { value } }) {
    return `\u201C${value}\u201D nen\xED dovolen\xE1 hodnota pro ${name}.`;
  },
  number({ name }) {
    return `${sentence(name)} mus\xED b\xFDt \u010D\xEDslo.`;
  },
  required({ name }) {
    return `${sentence(name)} je povinn\xE9.`;
  },
  starts_with({ name, args }) {
    return `${sentence(name)} neza\u010D\xEDn\xE1 na ${list(args)}.`;
  },
  url() {
    return `Zadejte, pros\xEDm, platnou URL adresu.`;
  }
};
var cs = Object.freeze({
  __proto__: null,
  ui: ui$k,
  validation: validation$k
});
var ui$j = {
  remove: "Fjern",
  removeAll: "Fjern alle",
  incomplete: "Alle felter er ikke korrekt udfyldt.",
  submit: "Send",
  noFiles: "Ingen filer valgt"
};
var validation$j = {
  accepted({ name }) {
    return `Accepter venligst ${name}.`;
  },
  date_after({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} skal v\xE6re senere end ${date2(args[0])}.`;
    }
    return `${sentence(name)} skal v\xE6re i fremtiden.`;
  },
  alpha({ name }) {
    return `${sentence(name)} kan kun indeholde bogstaver.`;
  },
  alphanumeric({ name }) {
    return `${sentence(name)} kan kun indeholde bogstaver og tal.`;
  },
  alpha_spaces({ name }) {
    return `${sentence(name)} kan kun indeholde bogstaver og mellemrum.`;
  },
  date_before({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} skal v\xE6re f\xF8r ${date2(args[0])}.`;
    }
    return `${sentence(name)} skal v\xE6re f\xF8r i dag.`;
  },
  between({ name, args }) {
    if (isNaN(args[0]) || isNaN(args[1])) {
      return `Dette felt er ikke konfigureret korrekt og kan derfor ikke blive sendt.`;
    }
    const [a, b] = order(args[0], args[1]);
    return `${sentence(name)} skal v\xE6re mellem ${a} og ${b}.`;
  },
  confirm({ name }) {
    return `${sentence(name)} matcher ikke.`;
  },
  date_format({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} er ikke gyldig, brug venligst formatet ${args[0]}`;
    }
    return "Dette felt er ikke konfigureret korrekt og kan derfor ikke blive sendt.";
  },
  date_between({ name, args }) {
    return `${sentence(name)} skal v\xE6re mellem ${date2(args[0])} og ${date2(args[1])}`;
  },
  email: "Indtast venligst en gyldig email-adresse.",
  ends_with({ name, args }) {
    return `${sentence(name)} slutter ikke med ${list(args)}.`;
  },
  is({ name }) {
    return `${sentence(name)} er ikke en gyldig v\xE6rdi.`;
  },
  length({ name, args: [first = 0, second = Infinity] }) {
    const min3 = Number(first) <= Number(second) ? first : second;
    const max3 = Number(second) >= Number(first) ? second : first;
    if (min3 == 1 && max3 === Infinity) {
      return `${sentence(name)} skal v\xE6re p\xE5 mindst \xE9t tegn.`;
    }
    if (min3 == 0 && max3) {
      return `${sentence(name)} skal v\xE6re p\xE5 h\xF8jst ${max3} tegn.`;
    }
    if (min3 && max3 === Infinity) {
      return `${sentence(name)} skal v\xE6re p\xE5 mindst ${min3} tegn.`;
    }
    return `${sentence(name)} skal v\xE6re p\xE5 mindst ${min3} og h\xF8jst ${max3} tegn.`;
  },
  matches({ name }) {
    return `${sentence(name)} er ikke en gyldig v\xE6rdi.`;
  },
  max({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Kan ikke have flere end ${args[0]} ${name}.`;
    }
    return `${sentence(name)} skal v\xE6re mindre eller lig med ${args[0]}.`;
  },
  mime({ name, args }) {
    if (!args[0]) {
      return "Ingen filformater tilladt.";
    }
    return `${sentence(name)} skal v\xE6re af filtypen: ${args[0]}`;
  },
  min({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Kan ikke have mindre end ${args[0]} ${name}.`;
    }
    return `${sentence(name)} skal v\xE6re mindst ${args[0]}.`;
  },
  not({ name, node: { value } }) {
    return `\u201C${value}\u201D er ikke en tilladt ${name}.`;
  },
  number({ name }) {
    return `${sentence(name)} skal v\xE6re et tal.`;
  },
  required({ name }) {
    return `${sentence(name)} er p\xE5kr\xE6vet.`;
  },
  starts_with({ name, args }) {
    return `${sentence(name)} starter ikke med ${list(args)}.`;
  },
  url() {
    return `Indtast venligst en gyldig URL.`;
  }
};
var da = Object.freeze({
  __proto__: null,
  ui: ui$j,
  validation: validation$j
});
var ui$i = {
  remove: "Entfernen",
  removeAll: "Alles entfernen",
  incomplete: "Entschuldigung, nicht alle Felder wurden korrekt ausgef\xFCllt.",
  submit: "Senden",
  noFiles: "Keine Datei ausgew\xE4hlt"
};
var validation$i = {
  accepted({ name }) {
    return `Bitte ${name} akzeptieren.`;
  },
  date_after({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} muss nach dem ${date2(args[0])} liegen.`;
    }
    return `${sentence(name)} muss in der Zukunft liegen.`;
  },
  alpha({ name }) {
    return `${sentence(name)} darf nur Buchstaben enthalten.`;
  },
  alphanumeric({ name }) {
    return `${sentence(name)} darf nur Buchstaben und Zahlen enthalten.`;
  },
  alpha_spaces({ name }) {
    return `${sentence(name)} d\xFCrfen nur Buchstaben und Leerzeichen enthalten.`;
  },
  date_before({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} muss vor dem ${date2(args[0])} liegen.`;
    }
    return `${sentence(name)} muss in der Vergangenheit liegen.`;
  },
  between({ name, args }) {
    if (isNaN(args[0]) || isNaN(args[1])) {
      return `Dieses Feld wurde falsch konfiguriert und kann nicht \xFCbermittelt werden.`;
    }
    return `${sentence(name)} muss zwischen ${args[0]} und ${args[1]} sein.`;
  },
  confirm({ name }) {
    return `${sentence(name)} stimmt nicht \xFCberein.`;
  },
  date_format({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} ist kein g\xFCltiges Datum im Format ${args[0]}.`;
    }
    return "Dieses Feld wurde falsch konfiguriert und kann nicht \xFCbermittelt werden.";
  },
  date_between({ name, args }) {
    return `${sentence(name)} muss zwischen ${date2(args[0])} und ${date2(args[1])} liegen.`;
  },
  email: "E-Mail Adresse ist ung\xFCltig.",
  ends_with({ name, args }) {
    return `${sentence(name)} endet nicht mit ${list(args)}.`;
  },
  is({ name }) {
    return `${sentence(name)} enth\xE4lt einen ung\xFCltigen Wert.`;
  },
  length({ name, args: [first = 0, second = Infinity] }) {
    const min3 = first <= second ? first : second;
    const max3 = second >= first ? second : first;
    if (min3 == 1 && max3 === Infinity) {
      return `${sentence(name)} muss mindestens ein Zeichen enthalten.`;
    }
    if (min3 == 0 && max3) {
      return `${sentence(name)} darf maximal ${max3} Zeichen enthalten.`;
    }
    if (min3 && max3 === Infinity) {
      return `${sentence(name)} muss mindestens ${min3} Zeichen enthalten.`;
    }
    return `${sentence(name)} muss zwischen ${min3} und ${max3} Zeichen enthalten.`;
  },
  matches({ name }) {
    return `${sentence(name)} enth\xE4lt einen ung\xFCltigen Wert.`;
  },
  max({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Darf maximal ${args[0]} ${name} haben.`;
    }
    return `${sentence(name)} darf maximal ${args[0]} sein.`;
  },
  mime({ name, args }) {
    if (!args[0]) {
      return "Keine Dateiformate konfiguriert.";
    }
    return `${sentence(name)} muss vom Typ ${args[0]} sein.`;
  },
  min({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Mindestens ${args[0]} ${name} erforderlich.`;
    }
    return `${sentence(name)} muss mindestens ${args[0]} sein.`;
  },
  not({ name, node: { value } }) {
    return `\u201C${value}\u201D ist kein g\xFCltiger Wert f\xFCr ${name}.`;
  },
  number({ name }) {
    return `${sentence(name)} muss eine Zahl sein.`;
  },
  required({ name }) {
    return `${sentence(name)} ist erforderlich.`;
  },
  starts_with({ name, args }) {
    return `${sentence(name)} beginnt nicht mit ${list(args)}.`;
  },
  url() {
    return `URL ist ung\xFCltig.`;
  }
};
var de = Object.freeze({
  __proto__: null,
  ui: ui$i,
  validation: validation$i
});
var ui$h = {
  remove: "Remove",
  removeAll: "Remove all",
  incomplete: "Sorry, not all fields are filled out correctly.",
  submit: "Submit",
  noFiles: "No file chosen"
};
var validation$h = {
  accepted({ name }) {
    return `Please accept the ${name}.`;
  },
  date_after({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} must be after ${date2(args[0])}.`;
    }
    return `${sentence(name)} must be in the future.`;
  },
  alpha({ name }) {
    return `${sentence(name)} can only contain alphabetical characters.`;
  },
  alphanumeric({ name }) {
    return `${sentence(name)} can only contain letters and numbers.`;
  },
  alpha_spaces({ name }) {
    return `${sentence(name)} can only contain letters and spaces.`;
  },
  date_before({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} must be before ${date2(args[0])}.`;
    }
    return `${sentence(name)} must be in the past.`;
  },
  between({ name, args }) {
    if (isNaN(args[0]) || isNaN(args[1])) {
      return `This field was configured incorrectly and can\u2019t be submitted.`;
    }
    const [a, b] = order(args[0], args[1]);
    return `${sentence(name)} must be between ${a} and ${b}.`;
  },
  confirm({ name }) {
    return `${sentence(name)} does not match.`;
  },
  date_format({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} is not a valid date, please use the format ${args[0]}`;
    }
    return "This field was configured incorrectly and can\u2019t be submitted";
  },
  date_between({ name, args }) {
    return `${sentence(name)} must be between ${date2(args[0])} and ${date2(args[1])}`;
  },
  email: "Please enter a valid email address.",
  ends_with({ name, args }) {
    return `${sentence(name)} doesn\u2019t end with ${list(args)}.`;
  },
  is({ name }) {
    return `${sentence(name)} is not an allowed value.`;
  },
  length({ name, args: [first = 0, second = Infinity] }) {
    const min3 = Number(first) <= Number(second) ? first : second;
    const max3 = Number(second) >= Number(first) ? second : first;
    if (min3 == 1 && max3 === Infinity) {
      return `${sentence(name)} must be at least one character.`;
    }
    if (min3 == 0 && max3) {
      return `${sentence(name)} must be less than or equal to ${max3} characters.`;
    }
    if (min3 && max3 === Infinity) {
      return `${sentence(name)} must be greater than or equal to ${min3} characters.`;
    }
    return `${sentence(name)} must be between ${min3} and ${max3} characters.`;
  },
  matches({ name }) {
    return `${sentence(name)} is not an allowed value.`;
  },
  max({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Cannot have more than ${args[0]} ${name}.`;
    }
    return `${sentence(name)} must be less than or equal to ${args[0]}.`;
  },
  mime({ name, args }) {
    if (!args[0]) {
      return "No file formats allowed.";
    }
    return `${sentence(name)} must be of the type: ${args[0]}`;
  },
  min({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Cannot have less than ${args[0]} ${name}.`;
    }
    return `${sentence(name)} must be at least ${args[0]}.`;
  },
  not({ name, node: { value } }) {
    return `\u201C${value}\u201D is not an allowed ${name}.`;
  },
  number({ name }) {
    return `${sentence(name)} must be a number.`;
  },
  required({ name }) {
    return `${sentence(name)} is required.`;
  },
  starts_with({ name, args }) {
    return `${sentence(name)} doesn\u2019t start with ${list(args)}.`;
  },
  url() {
    return `Please include a valid url.`;
  }
};
var en = Object.freeze({
  __proto__: null,
  ui: ui$h,
  validation: validation$h
});
var ui$g = {
  remove: "Quitar",
  removeAll: "Quitar todos",
  incomplete: "Disc\xFAlpe, los campos no fueron completados correctamente.",
  submit: "Enviar",
  noFiles: "Archivo no seleccionado"
};
var validation$g = {
  accepted({ name }) {
    return `Acepte el ${name} por favor.`;
  },
  date_after({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} debe ser posterior a ${date2(args[0])}.`;
    }
    return `${sentence(name)} debe ser una fecha futura.`;
  },
  alpha({ name }) {
    return `${sentence(name)} debe contener solo caract\xE9res alfab\xE9ticos.`;
  },
  alphanumeric({ name }) {
    return `${sentence(name)} debe ser alfanum\xE9rico.`;
  },
  alpha_spaces({ name }) {
    return `${sentence(name)} espacios alfa solo pueden contener letras y espacios.`;
  },
  date_before({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} debe ser anterior a ${date2(args[0])}.`;
    }
    return `${sentence(name)} debe ser una fecha pasada.`;
  },
  between({ name, args }) {
    if (isNaN(args[0]) || isNaN(args[1])) {
      return `El campo no fue completado correctamente y no puede ser enviado.`;
    }
    const [a, b] = order(args[0], args[1]);
    return `${sentence(name)} debe estar entre ${a} y ${b}.`;
  },
  confirm({ name }) {
    return `${sentence(name)} no coincide.`;
  },
  date_format({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} no es una fecha v\xE1lida, por favor utilice el formato ${args[0]}`;
    }
    return "El campo no fue completado correctamente y no puede ser enviado.";
  },
  date_between({ name, args }) {
    return `${sentence(name)} debe estar entre ${date2(args[0])} y ${date2(args[1])}`;
  },
  email: "Ingrese una direcci\xF3n de correo electr\xF3nico v\xE1lida por favor.",
  ends_with({ name, args }) {
    return `${sentence(name)} no termina con ${list(args)}.`;
  },
  is({ name }) {
    return `${sentence(name)} no es un valor permitido.`;
  },
  length({ name, args: [first = 0, second = Infinity] }) {
    const min3 = Number(first) <= Number(second) ? first : second;
    const max3 = Number(second) >= Number(first) ? second : first;
    if (min3 == 1 && max3 === Infinity) {
      return `${sentence(name)} debe tener al menos una letra.`;
    }
    if (min3 == 0 && max3) {
      return `${sentence(name)} debe tener como m\xE1ximo ${max3} caract\xE9res.`;
    }
    if (min3 && max3 === Infinity) {
      return `${sentence(name)} debe tener como m\xEDnimo ${min3} caract\xE9res.`;
    }
    return `${sentence(name)} debe tener entre ${min3} y ${max3} caract\xE9res.`;
  },
  matches({ name }) {
    return `${sentence(name)} no es un valor permitido.`;
  },
  max({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Cannot have more than ${args[0]} ${name}.`;
    }
    return `${sentence(name)} debe ser menor o igual a ${args[0]}.`;
  },
  mime({ name, args }) {
    if (!args[0]) {
      return "No existen formatos de archivos permitidos.";
    }
    return `${sentence(name)} debe ser del tipo: ${args[0]}`;
  },
  min({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Cannot have less than ${args[0]} ${name}.`;
    }
    return `${sentence(name)} debe ser de al menos ${args[0]}.`;
  },
  not({ name, node: { value } }) {
    return `\u201C${value}\u201D no es un valor permitido de ${name}.`;
  },
  number({ name }) {
    return `${sentence(name)} debe ser un n\xFAmero.`;
  },
  required({ name }) {
    return `${sentence(name)} es requerido.`;
  },
  starts_with({ name, args }) {
    return `${sentence(name)} debe comenzar con ${list(args)}.`;
  },
  url() {
    return `Proporcione una URL v\xE1lida por favor.`;
  }
};
var es = Object.freeze({
  __proto__: null,
  ui: ui$g,
  validation: validation$g
});
var ui$f = {
  remove: "\u062D\u0630\u0641",
  removeAll: "\u0647\u0645\u0647 \u0631\u0627 \u062D\u0630\u0641 \u06A9\u0646\u06CC\u062F",
  incomplete: "\u0647\u0645\u0647 \u0641\u06CC\u0644\u062F\u0647\u0627 \u0628\u0647\u200C\u062F\u0631\u0633\u062A\u06CC \u067E\u0631 \u0646\u0634\u062F\u0647\u200C\u0627\u0646\u062F",
  submit: "\u062B\u0628\u062A",
  noFiles: "\u0647\u06CC\u0686 \u0641\u0627\u06CC\u0644\u06CC \u0627\u0646\u062A\u062E\u0627\u0628 \u0646\u0634\u062F\u0647 \u0627\u0633\u062A"
};
var validation$f = {
  accepted({ name }) {
    return `\u0644\u0637\u0641\u0627\u064B ${name} \u0631\u0627 \u0628\u067E\u0630\u06CC\u0631\u06CC\u062F.`;
  },
  date_after({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u0639\u062F \u0627\u0632 \u062A\u0627\u0631\u06CC\u062E ${date2(args[0])} \u0628\u0627\u0634\u062F.`;
    }
    return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0645\u0631\u0628\u0648\u0637 \u0628\u0647 \u0622\u06CC\u0646\u062F\u0647 \u0628\u0627\u0634\u062F.`;
  },
  alpha({ name }) {
    return `${sentence(name)} \u0641\u0642\u0637 \u0645\u06CC\u062A\u0648\u0627\u0646\u062F \u0634\u0627\u0645\u0644 \u062D\u0631\u0648\u0641 \u0627\u0644\u0641\u0628\u0627 \u0628\u0627\u0634\u062F.`;
  },
  alphanumeric({ name }) {
    return `${sentence(name)} \u0641\u0642\u0637 \u0645\u06CC\u062A\u0648\u0627\u0646\u062F \u0634\u0627\u0645\u0644 \u062D\u0631\u0648\u0641 \u0648 \u0627\u0639\u062F\u0627\u062F \u0628\u0627\u0634\u062F.`;
  },
  alpha_spaces({ name }) {
    return `${sentence(name)} \u0641\u0642\u0637 \u0645\u06CC \u062A\u0648\u0627\u0646\u062F \u0634\u0627\u0645\u0644 \u062D\u0631\u0648\u0641 \u0648 \u0641\u0627\u0635\u0644\u0647 \u0628\u0627\u0634\u062F.`;
  },
  date_before({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0642\u0628\u0644 \u0627\u0632 \u062A\u0627\u0631\u06CC\u062E ${date2(args[0])} \u0628\u0627\u0634\u062F.`;
    }
    return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0645\u0631\u0628\u0648\u0637 \u0628\u0647 \u06AF\u0630\u0634\u062A\u0647 \u0628\u0627\u0634\u062F.`;
  },
  between({ name, args }) {
    if (isNaN(args[0]) || isNaN(args[1])) {
      return `\u0627\u06CC\u0646 \u0641\u06CC\u0644\u062F \u0628\u0647 \u0627\u0634\u062A\u0628\u0627\u0647 \u067E\u06CC\u06A9\u0631\u0628\u0646\u062F\u06CC \u0634\u062F\u0647 \u0627\u0633\u062A \u0648 \u0642\u0627\u0628\u0644 \u0627\u0631\u0633\u0627\u0644 \u0646\u06CC\u0633\u062A`;
    }
    return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u06CC\u0646 ${args[0]} \u0648 ${args[1]} \u0628\u0627\u0634\u062F.`;
  },
  confirm({ name }) {
    return `${sentence(name)} \u0645\u0637\u0627\u0628\u0642\u062A \u0646\u062F\u0627\u0631\u062F.`;
  },
  date_format({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} \u062A\u0627\u0631\u06CC\u062E \u0645\u0639\u062A\u0628\u0631\u06CC \u0646\u06CC\u0633\u062A\u060C \u0644\u0637\u0641\u0627\u064B \u0627\u0632 \u0642\u0627\u0644\u0628 ${args[0]} \u0627\u0633\u062A\u0641\u0627\u062F\u0647 \u06A9\u0646\u06CC\u062F
`;
    }
    return "\u0627\u06CC\u0646 \u0641\u06CC\u0644\u062F \u0628\u0647 \u0627\u0634\u062A\u0628\u0627\u0647 \u067E\u06CC\u06A9\u0631\u0628\u0646\u062F\u06CC \u0634\u062F\u0647 \u0627\u0633\u062A \u0648 \u0642\u0627\u0628\u0644 \u0627\u0631\u0633\u0627\u0644 \u0646\u06CC\u0633\u062A";
  },
  date_between({ name, args }) {
    return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u06CC\u0646 ${date2(args[0])} \u0648 ${date2(args[1])} \u0628\u0627\u0634\u062F.`;
  },
  email: "\u0644\u0637\u0641\u0627 \u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644 \u0645\u0639\u062A\u0628\u0631 \u0648\u0627\u0631\u062F \u06A9\u0646\u06CC\u062F.",
  ends_with({ name, args }) {
    return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u0647 ${list(args)} \u062E\u062A\u0645 \u0634\u0648\u062F.`;
  },
  is({ name }) {
    return `${sentence(name)} \u0645\u062C\u0627\u0632 \u0646\u06CC\u0633\u062A.`;
  },
  length({ name, args: [first = 0, second = Infinity] }) {
    const min3 = first <= second ? first : second;
    const max3 = second >= first ? second : first;
    if (min3 == 1 && max3 === Infinity) {
      return `${sentence(name)} \u0628\u0627\u06CC\u062F \u062D\u062F\u0627\u0642\u0644 \u06CC\u06A9 \u06A9\u0627\u0631\u0627\u06A9\u062A\u0631 \u0628\u0627\u0634\u062F.`;
    }
    if (min3 == 0 && max3) {
      return `${sentence(name)} \u0628\u0627\u06CC\u062F \u06A9\u0645\u062A\u0631 \u06CC\u0627 \u0628\u0631\u0627\u0628\u0631 \u0628\u0627 ${max3} \u06A9\u0627\u0631\u0627\u06A9\u062A\u0631 \u0628\u0627\u0634\u062F.`;
    }
    if (min3 && max3 === Infinity) {
      return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u0632\u0631\u06AF\u062A\u0631 \u06CC\u0627 \u0628\u0631\u0627\u0628\u0631 \u0628\u0627 ${min3} \u06A9\u0627\u0631\u0627\u06A9\u062A\u0631 \u0628\u0627\u0634\u062F.`;
    }
    return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u06CC\u0646 ${min3} \u0648 ${max3} \u06A9\u0627\u0631\u0627\u06A9\u062A\u0631 \u0628\u0627\u0634\u062F.`;
  },
  matches({ name }) {
    return `${sentence(name)} \u0645\u062C\u0627\u0632 \u0646\u06CC\u0633\u062A.`;
  },
  max({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `${name} \u0646\u0645\u06CC \u062A\u0648\u0627\u0646\u062F \u0628\u06CC\u0634 \u0627\u0632 ${args[0]} \u0628\u0627\u0634\u062F.`;
    }
    return `${sentence(name)} \u0628\u0627\u06CC\u062F \u06A9\u0645\u062A\u0631 \u06CC\u0627 \u0628\u0631\u0627\u0628\u0631 \u0628\u0627 ${args[0]} \u0628\u0627\u0634\u062F.`;
  },
  mime({ name, args }) {
    if (!args[0]) {
      return "\u0641\u0631\u0645\u062A \u0641\u0627\u06CC\u0644 \u0645\u062C\u0627\u0632 \u0646\u06CC\u0633\u062A.";
    }
    return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0627\u0632 \u0627\u06CC\u0646 \u0646\u0648\u0639 \u0628\u0627\u0634\u062F: ${args[0]}`;
  },
  min({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `${name} \u0646\u0645\u06CC \u062A\u0648\u0627\u0646\u062F \u06A9\u0645\u062A\u0631 \u0627\u0632 ${args[0]} \u0628\u0627\u0634\u062F.
`;
    }
    return `${sentence(name)} \u0628\u0627\u06CC\u062F \u062D\u062F\u0627\u0642\u0644 ${args[0]} \u0628\u0627\u0634\u062F.`;
  },
  not({ name, node: { value } }) {
    return `"${value}" \u06CC\u06A9 ${name} \u0645\u062C\u0627\u0632 \u0646\u06CC\u0633\u062A.`;
  },
  number({ name }) {
    return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0639\u062F\u062F \u0628\u0627\u0634\u062F.`;
  },
  required({ name }) {
    return `\u067E\u0631 \u06A9\u0631\u062F\u0646 ${sentence(name)} \u0627\u062C\u0628\u0627\u0631\u06CC \u0627\u0633\u062A.`;
  },
  starts_with({ name, args }) {
    return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u0627 ${list(args)} \u0634\u0631\u0648\u0639 \u0634\u0648\u062F.`;
  },
  url() {
    return `\u0644\u0637\u0641\u0627\u064B \u0622\u062F\u0631\u0633 \u0627\u06CC\u0646\u062A\u0631\u0646\u062A\u06CC \u0645\u0639\u062A\u0628\u0631 \u0648\u0627\u0631\u062F \u06A9\u0646\u06CC\u062F.`;
  }
};
var fa = Object.freeze({
  __proto__: null,
  ui: ui$f,
  validation: validation$f
});
var ui$e = {
  remove: "Poista",
  removeAll: "Poista kaikki",
  incomplete: "Kaikkia kentti\xE4 ei ole t\xE4ytetty oikein.",
  submit: "Tallenna",
  noFiles: "Ei valittuja tiedostoja"
};
var validation$e = {
  accepted({ name }) {
    return `Ole hyv\xE4 ja hyv\xE4ksy ${name}`;
  },
  date_after({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} tulee olla ${date2(args[0])} j\xE4lkeen.`;
    }
    return `${sentence(name)} on oltava tulevaisuudessa.`;
  },
  alpha({ name }) {
    return `${sentence(name)} saa sis\xE4lt\xE4\xE4 vain kirjaimia.`;
  },
  alphanumeric({ name }) {
    return `${sentence(name)} saa sis\xE4lt\xE4\xE4 vain kirjaimia ja numeroita.`;
  },
  alpha_spaces({ name }) {
    return `${sentence(name)} voivat sis\xE4lt\xE4\xE4 vain kirjaimia ja v\xE4lily\xF6ntej\xE4.`;
  },
  date_before({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} tulee olla ennen: ${date2(args[0])}.`;
    }
    return `${sentence(name)} on oltava menneisyydess\xE4.`;
  },
  between({ name, args }) {
    if (isNaN(args[0]) || isNaN(args[1])) {
      return `T\xE4m\xE4 kentt\xE4 on t\xE4ytetty virheellisesti joten sit\xE4 ei voitu l\xE4hett\xE4\xE4.`;
    }
    const [a, b] = order(args[0], args[1]);
    return `${sentence(name)} on oltava v\xE4lill\xE4 ${a} - ${b} `;
  },
  confirm({ name }) {
    return `${sentence(name)} ei t\xE4sm\xE4\xE4.`;
  },
  date_format({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} ei ole validi p\xE4iv\xE4m\xE4\xE4r\xE4, ole hyv\xE4 ja sy\xF6t\xE4 muodossa: ${args[0]}`;
    }
    return "T\xE4m\xE4 kentt\xE4 on t\xE4ytetty virheellisesti joten sit\xE4 ei voitu l\xE4hett\xE4\xE4.";
  },
  date_between({ name, args }) {
    return `${sentence(name)} on oltava v\xE4lill\xE4 ${date2(args[0])} - ${date2(args[1])}`;
  },
  email: "Sy\xF6t\xE4 validi s\xE4hk\xF6postiosoite.",
  ends_with({ name, args }) {
    return `${sentence(name)} tulee p\xE4\xE4tty\xE4 ${list(args)}.`;
  },
  is({ name }) {
    return `${sentence(name)} ei ole sallittu vaihtoehto.`;
  },
  length({ name, args: [first = 0, second = Infinity] }) {
    const min3 = Number(first) <= Number(second) ? first : second;
    const max3 = Number(second) >= Number(first) ? second : first;
    if (min3 == 1 && max3 === Infinity) {
      return `${sentence(name)} on oltava v\xE4hint\xE4\xE4n yksi merkki.`;
    }
    if (min3 == 0 && max3) {
      return `${sentence(name)} on oltava ${max3} tai alle merkki\xE4.`;
    }
    if (min3 && max3 === Infinity) {
      return `${sentence(name)} on oltava v\xE4hint\xE4\xE4n ${min3} merkki\xE4.`;
    }
    return `${sentence(name)} on oltava v\xE4hint\xE4\xE4n ${min3}, enint\xE4\xE4n ${max3} merkki\xE4.`;
  },
  matches({ name }) {
    return `${sentence(name)} ei ole sallittu arvo.`;
  },
  max({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Valitse enint\xE4\xE4n ${args[0]} ${name} vaihtoehtoa.`;
    }
    return `${sentence(name)} on oltava ${args[0]} tai alle.`;
  },
  mime({ name, args }) {
    if (!args[0]) {
      return "Tiedostoja ei sallita.";
    }
    return `${sentence(name)} tulee olla ${args[0]}-tiedostotyyppi\xE4.`;
  },
  min({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Valitse v\xE4hint\xE4\xE4n ${args[0]} ${name} vaihtoehtoa.`;
    }
    return `${sentence(name)} tulee olla ${args[0]} tai suurempi.`;
  },
  not({ name, node: { value } }) {
    return `\u201C${value}\u201D ei ole sallittu ${name}.`;
  },
  number({ name }) {
    return `Kent\xE4n ${sentence(name)} tulee olla numero.`;
  },
  required({ name }) {
    return `${sentence(name)} vaaditaan.`;
  },
  starts_with({ name, args }) {
    return `${sentence(name)} on alettava ${list(args)}.`;
  },
  url() {
    return `Sy\xF6t\xE4 validi url-osoite.`;
  }
};
var fi = Object.freeze({
  __proto__: null,
  ui: ui$e,
  validation: validation$e
});
var ui$d = {
  remove: "Supprimer",
  removeAll: "Enlever tout",
  incomplete: "D\xE9sol\xE9, tous les champs ne sont pas remplis correctement.",
  submit: "Valider",
  noFiles: "Aucun fichier choisi"
};
var validation$d = {
  accepted({ name }) {
    return `Veuillez accepter le ${name}.`;
  },
  date_after({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} doit \xEAtre post\xE9rieure au ${date2(args[0])}.`;
    }
    return `${sentence(name)} doit \xEAtre dans le futur.`;
  },
  alpha({ name }) {
    return `${sentence(name)} ne peut contenir que des caract\xE8res alphab\xE9tiques.`;
  },
  alphanumeric({ name }) {
    return `${sentence(name)} ne peut contenir que des lettres et des chiffres.`;
  },
  alpha_spaces({ name }) {
    return `${sentence(name)} ne peuvent contenir que des lettres et des espaces.`;
  },
  date_before({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} doit \xEAtre ant\xE9rieure au ${date2(args[0])}.`;
    }
    return `${sentence(name)} doit \xEAtre dans le pass\xE9.`;
  },
  between({ name, args }) {
    if (isNaN(args[0]) || isNaN(args[1])) {
      return `Ce champ a \xE9t\xE9 configur\xE9 de mani\xE8re incorrecte et ne peut pas \xEAtre soumis.`;
    }
    const [a, b] = order(args[0], args[1]);
    return `${sentence(name)} doit \xEAtre comprise entre ${a} et ${b}.`;
  },
  confirm({ name }) {
    return `${sentence(name)} ne correspond pas.`;
  },
  date_format({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} n'est pas une date valide, veuillez utiliser le format ${args[0]}`;
    }
    return "Ce champ a \xE9t\xE9 configur\xE9 de mani\xE8re incorrecte et ne peut pas \xEAtre soumis.";
  },
  date_between({ name, args }) {
    return `${sentence(name)} doit \xEAtre comprise entre ${date2(args[0])} et ${date2(args[1])}`;
  },
  email: "Veuillez saisir une adresse email valide.",
  ends_with({ name, args }) {
    return `${sentence(name)} ne se termine pas par ${list(args)}.`;
  },
  is({ name }) {
    return `${sentence(name)} n'est pas une valeur autoris\xE9e.`;
  },
  length({ name, args: [first = 0, second = Infinity] }) {
    const min3 = Number(first) <= Number(second) ? first : second;
    const max3 = Number(second) >= Number(first) ? second : first;
    if (min3 == 1 && max3 === Infinity) {
      return `${sentence(name)} doit comporter au moins un caract\xE8re.`;
    }
    if (min3 == 0 && max3) {
      return `${sentence(name)} doit \xEAtre inf\xE9rieur ou \xE9gal \xE0 ${max3} caract\xE8res.`;
    }
    if (min3 && max3 === Infinity) {
      return `${sentence(name)} doit \xEAtre sup\xE9rieur ou \xE9gal \xE0 ${min3} caract\xE8res.`;
    }
    return `${sentence(name)} doit \xEAtre comprise entre ${min3} et ${max3} caract\xE8res.`;
  },
  matches({ name }) {
    return `${sentence(name)} n'est pas une valeur autoris\xE9e.`;
  },
  max({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Ne peut pas avoir plus de ${args[0]} ${name}.`;
    }
    return `${sentence(name)} doit \xEAtre inf\xE9rieur ou \xE9gal \xE0 ${args[0]}.`;
  },
  mime({ name, args }) {
    if (!args[0]) {
      return "Aucun format de fichier n\u2019est autoris\xE9";
    }
    return `${sentence(name)} doit \xEAtre du type: ${args[0]}`;
  },
  min({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Ne peut pas avoir moins de ${args[0]} ${name}.`;
    }
    return `${sentence(name)} doit \xEAtre au moins de ${args[0]}.`;
  },
  not({ name, node: { value } }) {
    return `\u201C${value}\u201D n'est pas un ${name} autoris\xE9.`;
  },
  number({ name }) {
    return `${sentence(name)} doit \xEAtre un nombre.`;
  },
  required({ name }) {
    return `${sentence(name)} est requis.`;
  },
  starts_with({ name, args }) {
    return `${sentence(name)} ne commence pas par ${list(args)}.`;
  },
  url() {
    return `Veuillez saisir une url valide.`;
  }
};
var fr = Object.freeze({
  __proto__: null,
  ui: ui$d,
  validation: validation$d
});
var ui$c = {
  remove: "Ferwider",
  removeAll: "Ferwider alles",
  incomplete: "Sorry, net alle fjilden binne korrekt ynfolle.",
  submit: "Ferstjoere",
  noFiles: "Gjin best\xE2n keazen"
};
var validation$c = {
  accepted({ name }) {
    return `Akseptearje de ${name}.`;
  },
  date_after({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} moat nei ${date2(args[0])} w\xEAze.`;
    }
    return `${sentence(name)} moat yn de takomst lizze.`;
  },
  alpha({ name }) {
    return `${sentence(name)} mei allinne alfabetyske tekens befetsje.`;
  },
  alphanumeric({ name }) {
    return `${sentence(name)} mei allinne letters en sifers befetsje.`;
  },
  date_before({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} moat foar ${date2(args[0])} falle.`;
    }
    return `${sentence(name)} moat yn it ferline w\xEAze.`;
  },
  between({ name, args }) {
    if (isNaN(args[0]) || isNaN(args[1])) {
      return `Dit fjild is ferkeard konfigurearre en kin net ferstjoerd wurde.`;
    }
    const [a, b] = order(args[0], args[1]);
    return `${sentence(name)} moat tusken ${a} en ${b} lizze.`;
  },
  confirm({ name }) {
    return `${sentence(name)} komt net oerien.`;
  },
  date_format({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} is gjin jildige datum, br\xFBk de notaasje ${args[0]}`;
    }
    return "Dit fjild is ferkeard konfigurearre en kin net ferstjoerd wurde";
  },
  date_between({ name, args }) {
    return `${sentence(name)} moat tusken ${date2(args[0])} en ${date2(args[1])} lizze`;
  },
  email: "Folje in jildich e-mailadres yn.",
  ends_with({ name, args }) {
    return `${sentence(name)} einiget net mei ${list(args)}.`;
  },
  is({ name }) {
    return `${sentence(name)} is gjin tastiene wearde.`;
  },
  length({ name, args: [first = 0, second = Infinity] }) {
    const min3 = Number(first) <= Number(second) ? first : second;
    const max3 = Number(second) >= Number(first) ? second : first;
    if (min3 == 1 && max3 === Infinity) {
      return `${sentence(name)} moat minimaal ien teken w\xEAze.`;
    }
    if (min3 == 0 && max3) {
      return `${sentence(name)} moat lytser w\xEAze as of gelyk w\xEAze oan ${max3} tekens.`;
    }
    if (min3 && max3 === Infinity) {
      return `${sentence(name)} moat grutter w\xEAze as of gelyk w\xEAze oan ${min3} tekens.`;
    }
    return `${sentence(name)} moat tusken de ${min3} en ${max3} tekens befetsje.`;
  },
  matches({ name }) {
    return `${sentence(name)} is gjin tastiene wearde.`;
  },
  max({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Mei net mear as ${args[0]} ${name} hawwe.`;
    }
    return `${sentence(name)} moat lytser w\xEAze as of gelyk w\xEAze oan ${args[0]}.`;
  },
  mime({ name, args }) {
    if (!args[0]) {
      return "Gjin best\xE2nsnotaasjes tastien.";
    }
    return `${sentence(name)} moat fan it type: ${args[0]} w\xEAze`;
  },
  min({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Mei net minder as ${args[0]} ${name} hawwe.`;
    }
    return `${sentence(name)} moat minimaal ${args[0]} w\xEAze.`;
  },
  not({ name, node: { value } }) {
    return `"${value}" is gjin tastiene ${name}.`;
  },
  number({ name }) {
    return `${sentence(name)} moat in getal w\xEAze.`;
  },
  required({ name }) {
    return `${sentence(name)} is ferplicht.`;
  },
  starts_with({ name, args }) {
    return `${sentence(name)} begjint net mei ${list(args)}.`;
  },
  url() {
    return `Doch der in jildige url by.`;
  }
};
var fy = Object.freeze({
  __proto__: null,
  ui: ui$c,
  validation: validation$c
});
var ui$b = {
  remove: "\u05DE\u05D7\u05E7",
  incomplete: "\u05E9\u05D9\u05DD \u05DC\u05D1, \u05DC\u05D0 \u05DB\u05DC \u05D4\u05E9\u05D3\u05D5\u05EA \u05DE\u05DC\u05D0\u05D9\u05DD \u05DB\u05E8\u05D0\u05D5\u05D9.",
  submit: "\u05E9\u05DC\u05D7"
};
var validation$b = {
  accepted({ name }) {
    return `\u05D0\u05E0\u05D0 \u05D0\u05E9\u05E8 \u05D0\u05EA ${name}.`;
  },
  date_after({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05D0\u05D7\u05E8\u05D9 ${date2(args[0])}.`;
    }
    return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05D1\u05E2\u05EA\u05D9\u05D3.`;
  },
  alpha({ name }) {
    return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05DB\u05D9\u05DC \u05D0\u05D5\u05EA\u05D9\u05D5\u05EA \u05D0\u05DC\u05E4\u05D1\u05EA.`;
  },
  alphanumeric({ name }) {
    return `${sentence(name)} \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05DB\u05D9\u05DC \u05E8\u05E7 \u05DE\u05E1\u05E4\u05E8\u05D9\u05DD \u05D5\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA.`;
  },
  alpha_spaces({ name }) {
    return `${sentence(name)} \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05DB\u05D9\u05DC \u05E8\u05E7 \u05D0\u05D5\u05EA\u05D9\u05D5\u05EA \u05D5\u05E8\u05D5\u05D5\u05D7\u05D9\u05DD.`;
  },
  date_before({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DC\u05E4\u05E0\u05D9 ${date2(args[0])}.`;
    }
    return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05D1\u05E2\u05D1\u05E8`;
  },
  between({ name, args }) {
    if (isNaN(args[0]) || isNaN(args[1])) {
      return `\u05E9\u05D3\u05D4 \u05D6\u05D4 \u05DC\u05D0 \u05D4\u05D5\u05D2\u05D3\u05E8 \u05DB\u05E8\u05D0\u05D5\u05D9 \u05D5\u05DC\u05D0 \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05D9\u05E9\u05DC\u05D7.`;
    }
    return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05D1\u05D9\u05DF ${args[0]} \u05D5-${args[1]}.`;
  },
  confirm({ name }) {
    return `${sentence(name)} \u05DC\u05D0 \u05DE\u05EA\u05D0\u05D9\u05DD.`;
  },
  date_format({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} \u05D4\u05D5\u05D0 \u05DC\u05D0 \u05EA\u05D0\u05E8\u05D9\u05DA \u05EA\u05E7\u05D9\u05DF, \u05D0\u05E0\u05D0 \u05D4\u05E9\u05EA\u05DE\u05E9 \u05D1\u05E4\u05D5\u05E8\u05DE\u05D8 ${args[0]}`;
    }
    return "\u05E9\u05D3\u05D4 \u05D6\u05D4 \u05DC\u05D0 \u05D4\u05D5\u05D2\u05D3\u05E8 \u05DB\u05E8\u05D0\u05D5\u05D9 \u05D5\u05DC\u05D0 \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05D9\u05E9\u05DC\u05D7.";
  },
  date_between({ name, args }) {
    return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05D1\u05D9\u05DF ${date2(args[0])} \u05D5- ${date2(args[1])}`;
  },
  email: "\u05D0\u05E0\u05D0 \u05D4\u05E7\u05DC\u05D3 \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC \u05EA\u05E7\u05D9\u05DF.",
  ends_with({ name, args }) {
    return `${sentence(name)} \u05DC\u05D0 \u05DE\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1- ${list(args)}.`;
  },
  is({ name }) {
    return `${sentence(name)} \u05D4\u05D5\u05D0 \u05DC\u05D0 \u05E2\u05E8\u05DA \u05DE\u05D5\u05E8\u05E9\u05D4.`;
  },
  length({ name, args: [first = 0, second = Infinity] }) {
    const min3 = first <= second ? first : second;
    const max3 = second >= first ? second : first;
    if (min3 == 1 && max3 === Infinity) {
      return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DC\u05E4\u05D7\u05D5\u05EA \u05EA\u05D5 \u05D0\u05D7\u05D3.`;
    }
    if (min3 == 0 && max3) {
      return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05E4\u05D7\u05D5\u05EA \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC- ${max3} \u05EA\u05D5\u05D5\u05D9\u05DD.`;
    }
    if (min3 && max3 === Infinity) {
      return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D9\u05D5\u05EA \u05D2\u05D3\u05D5\u05DC \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC- ${min3} \u05EA\u05D5\u05D5\u05D9\u05DD.`;
    }
    return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05D1\u05D9\u05DF ${min3} \u05D5- ${max3} \u05EA\u05D5\u05D5\u05D9\u05DD.`;
  },
  matches({ name }) {
    return `${sentence(name)} \u05D4\u05D5\u05D0 \u05DC\u05D0 \u05E2\u05E8\u05DA \u05EA\u05E7\u05D9\u05DF.`;
  },
  max({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `${name} \u05DC\u05D0 \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05D9\u05D5\u05EA \u05E2\u05DD \u05D9\u05D5\u05EA\u05E8 \u05DE- ${args[0]}.`;
    }
    return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05E4\u05D7\u05D5\u05EA \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC- ${args[0]}.`;
  },
  mime({ name, args }) {
    if (!args[0]) {
      return "\u05E4\u05D5\u05E8\u05DE\u05D8 \u05D4\u05E7\u05D5\u05D1\u05E5 \u05DC\u05D0 \u05DE\u05D5\u05E8\u05E9\u05D4.";
    }
    return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05E1\u05D5\u05D2: ${args[0]}`;
  },
  min({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `${name} \u05DC\u05D0 \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05D9\u05D5\u05EA \u05E2\u05DD \u05E4\u05D7\u05D5\u05EA \u05DE- ${args[0]}.`;
    }
    return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DC\u05E4\u05D7\u05D5\u05EA ${args[0]}.`;
  },
  not({ name, node: { value } }) {
    return `\u201C${value}\u201D \u05DC\u05D0 \u05DE\u05EA\u05D0\u05D9\u05DD \u05DC- ${name}.`;
  },
  number({ name }) {
    return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05E1\u05E4\u05E8.`;
  },
  required({ name }) {
    return `${sentence(name)} \u05D4\u05D9\u05E0\u05D5 \u05D7\u05D5\u05D1\u05D4.`;
  },
  starts_with({ name, args }) {
    return `${sentence(name)} \u05DC\u05D0 \u05DE\u05EA\u05D7\u05D9\u05DC \u05D1- ${list(args)}.`;
  },
  url() {
    return `\u05D0\u05E0\u05D0 \u05D4\u05E7\u05DC\u05D3 \u05E7\u05D9\u05E9\u05D5\u05E8 \u05EA\u05E7\u05D9\u05DF.`;
  }
};
var he = Object.freeze({
  __proto__: null,
  ui: ui$b,
  validation: validation$b
});
var ui$a = {
  remove: "Ukloni",
  incomplete: "Pojedina polja nisu ispravno ispunjena.",
  submit: "Predaj"
};
var validation$a = {
  accepted({ name }) {
    return `Potrebno je potvrditi ${name}.`;
  },
  date_after({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} mora biti u periodu poslije ${date2(args[0])}.`;
    }
    return `${sentence(name)} mora biti u budu\u0107nosti.`;
  },
  alpha({ name }) {
    return `${sentence(name)} mora sadr\u017Eavati samo slova.`;
  },
  alphanumeric({ name }) {
    return `${sentence(name)} mora sadr\u017Eavati slova i brojeve.`;
  },
  alpha_spaces({ name }) {
    return `${sentence(name)} mogu sadr\u017Eavati samo slova i razmake..`;
  },
  date_before({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} mora biti prije ${date2(args[0])}.`;
    }
    return `${sentence(name)} mora biti u pro\u0161losti.`;
  },
  between({ name, args }) {
    if (isNaN(args[0]) || isNaN(args[1])) {
      return `Format sadr\u017Eaja nije ispravan i ne mo\u017Ee biti predan.`;
    }
    return `${sentence(name)} mora biti izme\u0111u ${args[0]} i ${args[1]}.`;
  },
  confirm({ name }) {
    return `${sentence(name)} ne odgovara zadanoj vrijednosti.`;
  },
  date_format({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} nije ispravan format datuma. Molimo koristite sljede\u0107i format: ${args[0]}`;
    }
    return "Ovo polje nije ispravno postavljeno i ne mo\u017Ee biti predano.";
  },
  date_between({ name, args }) {
    return `${sentence(name)} mora biti vrijednost izme\u0111u ${date2(args[0])} i ${date2(args[1])}`;
  },
  email: "Molimo upi\u0161ite ispravnu email adresu.",
  ends_with({ name, args }) {
    return `${sentence(name)} ne zavr\u0161ava s ${list(args)}.`;
  },
  is({ name }) {
    return `${sentence(name)} nije dopu\u0161tena vrijednost.`;
  },
  length({ name, args: [first = 0, second = Infinity] }) {
    const min3 = first <= second ? first : second;
    const max3 = second >= first ? second : first;
    if (min3 == 1 && max3 === Infinity) {
      return `${sentence(name)} mora sadr\u017Eavati barem jedan znak.`;
    }
    if (min3 == 0 && max3) {
      return `${sentence(name)} mora imati ${max3} ili manje znakova.`;
    }
    if (min3 && max3 === Infinity) {
      return `${sentence(name)} mora imati barem ${min3} znakova.`;
    }
    return `Broj znakova za polje ${sentence(name)} mora biti izme\u0111u ${min3} i ${max3}.`;
  },
  matches({ name }) {
    return `${sentence(name)} nije dozvoljena vrijednost.`;
  },
  max({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Ne smije imati vi\u0161e od ${args[0]} ${name} polja.`;
    }
    return `${sentence(name)} mora imati vrijednost manju ili jednaku ${args[0]}.`;
  },
  mime({ name, args }) {
    if (!args[0]) {
      return "Format datoteke nije dozvoljen.";
    }
    return `Format datoteke na polju ${sentence(name)} mora odgovarati: ${args[0]}`;
  },
  min({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Broj upisanih vrijednosti na polju ${name} mora biti barem ${args[0]}.`;
    }
    return `${sentence(name)} mora biti barem ${args[0]}.`;
  },
  not({ name, node: { value } }) {
    return `\u201C${value}\u201D nije dozvoljena vrijednost na polju ${name}.`;
  },
  number({ name }) {
    return `${sentence(name)} mora biti broj.`;
  },
  required({ name }) {
    return `${sentence(name)} je obavezno.`;
  },
  starts_with({ name, args }) {
    return `${sentence(name)} ne po\u010Dinje s ${list(args)}.`;
  },
  url() {
    return `Molimo unesite ispravnu poveznicu.`;
  }
};
var hr = Object.freeze({
  __proto__: null,
  ui: ui$a,
  validation: validation$a
});
var ui$9 = {
  remove: "\uC81C\uAC70",
  removeAll: "\uBAA8\uB450 \uC81C\uAC70",
  incomplete: "\uBAA8\uB4E0 \uAC12\uC744 \uCC44\uC6CC\uC8FC\uC138\uC694",
  submit: "\uC81C\uCD9C\uD558\uAE30",
  noFiles: "\uC120\uD0DD\uB41C \uD30C\uC77C\uC774 \uC5C6\uC2B5\uB2C8\uB2E4"
};
var validation$9 = {
  accepted({ name }) {
    return `${name} \uC62C\uBC14\uB978 \uAC12\uC744 \uC120\uD0DD \uD574\uC8FC\uC138\uC694`;
  },
  date_after({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} ${date2(args[0])} \uC774\uD6C4\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
    }
    return `${sentence(name)} \uBBF8\uB798\uC758 \uB0A0\uC9DC\uC5EC\uC57C\uD569\uB2C8\uB2E4`;
  },
  alpha({ name }) {
    return `${sentence(name)} \uC54C\uD30C\uBCB3 \uBB38\uC790\uB9CC \uD3EC\uD568\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4`;
  },
  alphanumeric({ name }) {
    return `${sentence(name)} \uBB38\uC790\uC640 \uC22B\uC790\uB9CC \uD3EC\uD568\uB420 \uC218 \uC788\uC2B5\uB2C8\uB2E4`;
  },
  alpha_spaces({ name }) {
    return `${sentence(name)} \uBB38\uC790\uC640 \uACF5\uBC31\uB9CC \uD3EC\uD568\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.`;
  },
  date_before({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} ${date2(args[0])} \uC774\uC804\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
    }
    return `${sentence(name)} \uACFC\uAC70\uC758 \uB0A0\uC9DC\uC5EC\uC57C\uD569\uB2C8\uB2E4`;
  },
  between({ name, args }) {
    if (isNaN(args[0]) || isNaN(args[1])) {
      return `\uC798\uBABB\uB41C \uAD6C\uC131\uC73C\uB85C \uC81C\uCD9C\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4`;
    }
    const [a, b] = order(args[0], args[1]);
    return `${sentence(name)} ${a}\uC640 ${b} \uC0AC\uC774\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
  },
  confirm({ name }) {
    return `${sentence(name)} \uC77C\uCE58\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4`;
  },
  date_format({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} \uC720\uD6A8\uD55C \uB0A0\uC9DC\uAC00 \uC544\uB2D9\uB2C8\uB2E4. ${args[0]}\uACFC \uAC19\uC740 \uD615\uC2DD\uC744 \uC0AC\uC6A9\uD574\uC8FC\uC138\uC694`;
    }
    return "\uC798\uBABB\uB41C \uAD6C\uC131\uC73C\uB85C \uC81C\uCD9C\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4";
  },
  date_between({ name, args }) {
    return `${sentence(name)} ${date2(args[0])}\uC5D0\uC11C ${date2(args[1])} \uC0AC\uC774\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
  },
  email: "\uC62C\uBC14\uB978 \uC774\uBA54\uC77C \uC8FC\uC18C\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694",
  ends_with({ name, args }) {
    return `${sentence(name)} ${list(args)}\uB85C \uB05D\uB098\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4`;
  },
  is({ name }) {
    return `${sentence(name)} \uD5C8\uC6A9\uB418\uB294 \uAC12\uC774 \uC544\uB2D9\uB2C8\uB2E4`;
  },
  length({ name, args: [first = 0, second = Infinity] }) {
    const min3 = Number(first) <= Number(second) ? first : second;
    const max3 = Number(second) >= Number(first) ? second : first;
    if (min3 == 1 && max3 === Infinity) {
      return `${sentence(name)} \uD558\uB098 \uC774\uC0C1\uC758 \uBB38\uC790\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
    }
    if (min3 == 0 && max3) {
      return `${sentence(name)} ${max3}\uC790 \uC774\uD558\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
    }
    if (min3 && max3 === Infinity) {
      return `${sentence(name)} ${min3} \uBB38\uC790\uBCF4\uB2E4 \uD06C\uAC70\uB098 \uAC19\uC544\uC57C \uD569\uB2C8\uB2E4`;
    }
    return `${sentence(name)} ${min3}\uC5D0\uC11C ${max3}\uC790 \uC0AC\uC774\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
  },
  matches({ name }) {
    return `${sentence(name)} \uD5C8\uC6A9\uB418\uB294 \uAC12\uC774 \uC544\uB2D9\uB2C8\uB2E4`;
  },
  max({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `${args[0]} ${name} \uCD08\uACFC\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4`;
    }
    return `${sentence(name)} ${args[0]}\uBCF4\uB2E4 \uC791\uAC70\uB098 \uAC19\uC544\uC57C \uD569\uB2C8\uB2E4`;
  },
  mime({ name, args }) {
    if (!args[0]) {
      return "\uD30C\uC77C \uD615\uC2DD\uC774 \uD5C8\uC6A9\uB418\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4";
    }
    return `${sentence(name)} ${args[0]} \uC720\uD615\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
  },
  min({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `${args[0]} ${name}\uBCF4\uB2E4 \uC791\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4`;
    }
    return `${sentence(name)} ${args[0]} \uC774\uC0C1\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;
  },
  not({ name, node: { value } }) {
    return `${value}" \uD5C8\uC6A9\uB418\uC9C0 \uC54A\uB294 ${name}\uC785\uB2C8\uB2E4`;
  },
  number({ name }) {
    return `${sentence(name)} \uC22B\uC790\uC5EC\uC57C \uD569\uB2C8\uB2E4`;
  },
  required({ name }) {
    return `${sentence(name)} \uD544\uC218 \uAC12\uC785\uB2C8\uB2E4`;
  },
  starts_with({ name, args }) {
    return `${sentence(name)} ${list(args)}\uB85C \uC2DC\uC791\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4`;
  },
  url() {
    return `\uC62C\uBC14\uB978 URL\uC744 \uC785\uB825\uD574\uC8FC\uC138\uC694`;
  }
};
var ko = Object.freeze({
  __proto__: null,
  ui: ui$9,
  validation: validation$9
});
var ui$8 = {
  remove: "Hapus",
  removeAll: "Hapus semua",
  incomplete: "Maaf, tidak semua bidang formulir terisi dengan benar",
  submit: "Kirim",
  noFiles: "Tidak ada file yang dipilih"
};
var validation$8 = {
  accepted({ name }) {
    return `Tolong terima kolom ${name}.`;
  },
  date_after({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} nilainya harus lebih dari waktu ${date2(args[0])}.`;
    }
    return `${sentence(name)} harus berisi waktu di masa depan.`;
  },
  alpha({ name }) {
    return `${sentence(name)} hanya bisa diisi huruf alfabet.`;
  },
  alphanumeric({ name }) {
    return `${sentence(name)} hanya bisa diisi huruf dan angka.`;
  },
  alpha_spaces({ name }) {
    return `${sentence(name)} hanya boleh berisi huruf dan spasi..`;
  },
  date_before({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} nilainya harus kurang dari waktu ${date2(args[0])}.`;
    }
    return `${sentence(name)} harus berisi waktu yang sudah lampau.`;
  },
  between({ name, args }) {
    if (isNaN(args[0]) || isNaN(args[1])) {
      return `Kolom ini tidak diisi dengan benar sehingga tidak bisa dikirim`;
    }
    const [a, b] = order(args[0], args[1]);
    return `${sentence(name)} harus bernilai diantara ${a} dan ${b}.`;
  },
  confirm({ name }) {
    return `${sentence(name)} nilainya tidak cocok.`;
  },
  date_format({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} waktu tidak cocok, mohon gunakan format waktu ${args[0]}`;
    }
    return "Kolom ini tidak diisi dengan benar sehingga tidak bisa dikirim";
  },
  date_between({ name, args }) {
    return `${sentence(name)} harus diantara waktu ${date2(args[0])} dan waktu ${date2(args[1])}`;
  },
  email: "Tolong tulis alamat email yang benar.",
  ends_with({ name, args }) {
    return `${sentence(name)} nilainya tidak berakhiran dengan ${list(args)}.`;
  },
  is({ name }) {
    return `${sentence(name)} adalah nilai yang tidak diizinkan.`;
  },
  length({ name, args: [first = 0, second = Infinity] }) {
    const min3 = Number(first) <= Number(second) ? first : second;
    const max3 = Number(second) >= Number(first) ? second : first;
    if (min3 == 1 && max3 === Infinity) {
      return `${sentence(name)} nilainya setidaknya berisi satu karakter.`;
    }
    if (min3 == 0 && max3) {
      return `${sentence(name)} jumlah karakternya harus kurang dari atau sama dengan ${max3} karakter.`;
    }
    if (min3 && max3 === Infinity) {
      return `${sentence(name)} jumlah karakternya harus lebih dari atau sama dengan ${min3} karakter.`;
    }
    return `${sentence(name)} jumlah karakternya hanya bisa antara ${min3} dan ${max3} karakter.`;
  },
  matches({ name }) {
    return `${sentence(name)} nilainya tidak diizinkan.`;
  },
  max({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Tidak bisa memiliki lebih dari ${args[0]} ${name}.`;
    }
    return `${sentence(name)} harus lebih kecil atau sama dengan ${args[0]}.`;
  },
  mime({ name, args }) {
    if (!args[0]) {
      return "Format file tidak diizinkan";
    }
    return `${sentence(name)} hanya bisa bertipe: ${args[0]}`;
  },
  min({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Tidak boleh kurang dari ${args[0]} ${name}.`;
    }
    return `${sentence(name)} setidaknya harus berisi ${args[0]}.`;
  },
  not({ name, node: { value } }) {
    return `\u201C${value}\u201D adalah nilai yang tidak diperbolehkan untuk ${name}.`;
  },
  number({ name }) {
    return `${sentence(name)} harus berupa angka.`;
  },
  required({ name }) {
    return `${sentence(name)} harus diisi.`;
  },
  starts_with({ name, args }) {
    return `${sentence(name)} tidak dimulai dengan ${list(args)}.`;
  },
  url() {
    return `Mohon tuliskan url yang benar.`;
  }
};
var id = Object.freeze({
  __proto__: null,
  ui: ui$8,
  validation: validation$8
});
var ui$7 = {
  remove: "Rimuovi",
  removeAll: "Rimuovi tutti",
  incomplete: "Ci dispiace, non tutti i campi sono compilati correttamente.",
  submit: "Invia",
  noFiles: "Nessun file selezionato"
};
var validation$7 = {
  accepted({ name }) {
    return `Si prega di accettare ${name}.`;
  },
  date_after({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `la data ${sentence(name)} deve essere successiva ${date2(args[0])}.`;
    }
    return `la data ${sentence(name)} deve essere nel futuro.`;
  },
  alpha({ name }) {
    return `${sentence(name)} pu\xF2 contenere solo caratteri alfanumerici.`;
  },
  alphanumeric({ name }) {
    return `${sentence(name)} pu\xF2 contenere solo lettere e numeri.`;
  },
  alpha_spaces({ name }) {
    return `${sentence(name)} pu\xF2 contenere solo lettere e spazi.`;
  },
  date_before({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `la data ${sentence(name)} deve essere antecedente ${date2(args[0])}.`;
    }
    return `${sentence(name)} deve essere nel passato.`;
  },
  between({ name, args }) {
    if (isNaN(args[0]) || isNaN(args[1])) {
      return `Questo campo \xE8 stato configurato male e non pu\xF2 essere inviato.`;
    }
    const [a, b] = order(args[0], args[1]);
    return `${sentence(name)} deve essere tra ${a} e ${b}.`;
  },
  confirm({ name }) {
    return `${sentence(name)} non corrisponde.`;
  },
  date_format({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} non \xE8 una data valida, per favore usa il formato ${args[0]}`;
    }
    return "Questo campo \xE8 stato configurato in modo errato e non pu\xF2 essere inviato.";
  },
  date_between({ name, args }) {
    return `${sentence(name)} deve essere tra ${date2(args[0])} e ${date2(args[1])}`;
  },
  email: "Per favore inserire un indirizzo email valido.",
  ends_with({ name, args }) {
    return `${sentence(name)} non termina con ${list(args)}.`;
  },
  is({ name }) {
    return `${sentence(name)} non \xE8 un valore consentito.`;
  },
  length({ name, args: [first = 0, second = Infinity] }) {
    const min3 = Number(first) <= Number(second) ? first : second;
    const max3 = Number(second) >= Number(first) ? second : first;
    if (min3 == 1 && max3 === Infinity) {
      return `${sentence(name)} deve contenere almeno un carattere.`;
    }
    if (min3 == 0 && max3) {
      return `${sentence(name)} deve essere minore o uguale a ${max3} caratteri.`;
    }
    if (min3 && max3 === Infinity) {
      return `${sentence(name)} deve essere maggiore o uguale a ${min3} caratteri.`;
    }
    return `${sentence(name)} deve essere tra ${min3} e ${max3} caratteri.`;
  },
  matches({ name }) {
    return `${sentence(name)} non \xE8 un valore consentito.`;
  },
  max({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Non pu\xF2 avere pi\xF9 di ${args[0]} ${name}.`;
    }
    return `${sentence(name)} deve essere minore o uguale a ${args[0]}.`;
  },
  mime({ name, args }) {
    if (!args[0]) {
      return "Formato file non consentito.";
    }
    return `${sentence(name)} deve essere di tipo: ${args[0]}`;
  },
  min({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Non pu\xF2 avere meno di ${args[0]} ${name}.`;
    }
    return `${sentence(name)} deve essere almeno ${args[0]}.`;
  },
  not({ name, node: { value } }) {
    return `"${value}" non \xE8 un ${name} consentito.`;
  },
  number({ name }) {
    return `${sentence(name)} deve essere un numero.`;
  },
  required({ name }) {
    return `${sentence(name)} \xE8 richiesto.`;
  },
  starts_with({ name, args }) {
    return `${sentence(name)} non inizia con ${list(args)}.`;
  },
  url() {
    return `Per favore utilizare un url valido.`;
  }
};
var it = Object.freeze({
  __proto__: null,
  ui: ui$7,
  validation: validation$7
});
var ui$6 = {
  remove: "Verwijder",
  removeAll: "Verwijder alles",
  incomplete: "Sorry, niet alle velden zijn correct ingevuld.",
  submit: "Versturen",
  noFiles: "Geen bestand gekozen"
};
var validation$6 = {
  accepted({ name }) {
    return `Accepteer de ${name}.`;
  },
  date_after({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} moet na ${date2(args[0])} zijn.`;
    }
    return `${sentence(name)} moet in de toekomst liggen.`;
  },
  alpha({ name }) {
    return `${sentence(name)} mag alleen alfabetische tekens bevatten.`;
  },
  alphanumeric({ name }) {
    return `${sentence(name)} mag alleen letters en cijfers bevatten.`;
  },
  alpha_spaces({ name }) {
    return `${sentence(name)} kunnen alleen letters en spaties bevatten.`;
  },
  date_before({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} moet v\xF3\xF3r ${date2(args[0])} vallen.`;
    }
    return `${sentence(name)} moet in het verleden zijn.`;
  },
  between({ name, args }) {
    if (isNaN(args[0]) || isNaN(args[1])) {
      return `Dit veld is onjuist geconfigureerd en kan niet worden verzonden.`;
    }
    const [a, b] = order(args[0], args[1]);
    return `${sentence(name)} moet tussen ${a} en ${b} liggen.`;
  },
  confirm({ name }) {
    return `${sentence(name)} komt niet overeen.`;
  },
  date_format({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} is geen geldige datum, gebruik de notatie ${args[0]}`;
    }
    return "Dit veld is onjuist geconfigureerd en kan niet worden verzonden";
  },
  date_between({ name, args }) {
    return `${sentence(name)} moet tussen ${date2(args[0])} en ${date2(args[1])} liggen`;
  },
  email: "Vul een geldig e-mailadres in.",
  ends_with({ name, args }) {
    return `${sentence(name)} eindigt niet met ${list(args)}.`;
  },
  is({ name }) {
    return `${sentence(name)} is geen toegestane waarde.`;
  },
  length({ name, args: [first = 0, second = Infinity] }) {
    const min3 = Number(first) <= Number(second) ? first : second;
    const max3 = Number(second) >= Number(first) ? second : first;
    if (min3 == 1 && max3 === Infinity) {
      return `${sentence(name)} moet minimaal \xE9\xE9n teken zijn.`;
    }
    if (min3 == 0 && max3) {
      return `${sentence(name)} moet kleiner zijn dan of gelijk zijn aan ${max3} tekens.`;
    }
    if (min3 && max3 === Infinity) {
      return `${sentence(name)} moet groter zijn dan of gelijk zijn aan ${min3} tekens.`;
    }
    return `${sentence(name)} moet tussen de ${min3} en ${max3} tekens bevatten.`;
  },
  matches({ name }) {
    return `${sentence(name)} is geen toegestane waarde.`;
  },
  max({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Mag niet meer dan ${args[0]} ${name} hebben.`;
    }
    return `${sentence(name)} moet kleiner zijn dan of gelijk zijn aan ${args[0]}.`;
  },
  mime({ name, args }) {
    if (!args[0]) {
      return "Geen bestandsformaten toegestaan.";
    }
    return `${sentence(name)} moet van het type: ${args[0]} zijn`;
  },
  min({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Mag niet minder dan ${args[0]} ${name} hebben.`;
    }
    return `${sentence(name)} moet minimaal ${args[0]} zijn.`;
  },
  not({ name, node: { value } }) {
    return `"${value}" is geen toegestane ${name}.`;
  },
  number({ name }) {
    return `${sentence(name)} moet een getal zijn.`;
  },
  required({ name }) {
    return `${sentence(name)} is verplicht.`;
  },
  starts_with({ name, args }) {
    return `${sentence(name)} begint niet met ${list(args)}.`;
  },
  url() {
    return `Voeg een geldige url toe.`;
  }
};
var nl = Object.freeze({
  __proto__: null,
  ui: ui$6,
  validation: validation$6
});
var ui$5 = {
  remove: "Usu\u0144",
  removeAll: "Usu\u0144 wszystko",
  incomplete: "Nie wszystkie pola zosta\u0142y wype\u0142nione poprawnie.",
  submit: "Wy\u015Blij",
  noFiles: "Nie wybrano pliku"
};
var validation$5 = {
  accepted({ name }) {
    return `Prosz\u0119 zaakceptowa\u0107 ${name}.`;
  },
  date_after({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} musi by\u0107 po ${date2(args[0])}.`;
    }
    return `${sentence(name)} musi by\u0107 w przysz\u0142o\u015Bci.`;
  },
  alpha({ name }) {
    return `${sentence(name)} mo\u017Ce tylko zawiera\u0107 znaki alfabetyczne.`;
  },
  alphanumeric({ name }) {
    return `${sentence(name)} mo\u017Ce tylko zawiera\u0107 znaki alfanumeryczne.`;
  },
  alpha_spaces({ name }) {
    return `${sentence(name)} mog\u0105 zawiera\u0107 tylko litery i spacje.`;
  },
  date_before({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} musi by\u0107 przed ${date2(args[0])}.`;
    }
    return `${sentence(name)} musi by\u0107 w przesz\u0142o\u015Bci.`;
  },
  between({ name, args }) {
    if (isNaN(args[0]) || isNaN(args[1])) {
      return `Pole zosta\u0142o wype\u0142nione niepoprawnie i nie mo\u017Ce zosta\u0107 wys\u0142ane.`;
    }
    const [a, b] = order(args[0], args[1]);
    return `${sentence(name)} musi by\u0107 pomi\u0119dzy ${a} i ${b}.`;
  },
  confirm({ name }) {
    return `${sentence(name)} nie zgadza si\u0119.`;
  },
  date_format({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} nie jest poprawn\u0105 dat\u0105, prosz\u0119 u\u017Cy\u0107 formatu ${args[0]}`;
    }
    return "To pole zosta\u0142o wype\u0142nione niepoprawnie i nie mo\u017Ce zosta\u0107 wys\u0142ane";
  },
  date_between({ name, args }) {
    return `${sentence(name)} musi by\u0107 pomi\u0119dzy ${date2(args[0])} i ${date2(args[1])}`;
  },
  email: "Prosz\u0119 wpisa\u0107 poprawny adres email.",
  ends_with({ name, args }) {
    return `${sentence(name)} nie ko\u0144czy si\u0119 na ${list(args)}.`;
  },
  is({ name }) {
    return `${sentence(name)} nie jest dozwolon\u0105 warto\u015Bci\u0105.`;
  },
  length({ name, args: [first = 0, second = Infinity] }) {
    const min3 = Number(first) <= Number(second) ? first : second;
    const max3 = Number(second) >= Number(first) ? second : first;
    if (min3 == 1 && max3 === Infinity) {
      return `${sentence(name)} musi posiada\u0107 minimum jeden znak.`;
    }
    if (min3 == 0 && max3) {
      return `${sentence(name)} musi zawiera\u0107 ${max3} lub mniej znak\xF3w.`;
    }
    if (min3 && max3 === Infinity) {
      return `${sentence(name)} musi zawiera\u0107 ${min3} lub wi\u0119cej znak\xF3w.`;
    }
    return `${sentence(name)} musi mie\u0107 ${min3}-${max3} znak\xF3w.`;
  },
  matches({ name }) {
    return `${sentence(name)} nie jest dozwolon\u0105 warto\u015Bci\u0105.`;
  },
  max({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Nie mo\u017Cna mie\u0107 wi\u0119cej ni\u017C ${args[0]} ${name}.`;
    }
    return `${sentence(name)} musi by\u0107 mniejsze lub r\xF3wne ${args[0]}.`;
  },
  mime({ name, args }) {
    if (!args[0]) {
      return "Nie podano dozwolonych typ\xF3w plik\xF3w.";
    }
    return `${sentence(name)} musi by\u0107 typem: ${args[0]}`;
  },
  min({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `Musisz poda\u0107 wi\u0119cej ni\u017C ${args[0]} ${name}.`;
    }
    return ` Musisz poda\u0107 conajmniej ${args[0]} ${sentence(name)}.`;
  },
  not({ name, node: { value } }) {
    return `\u201C${value}\u201D nie jest dozwolonym ${name}.`;
  },
  number({ name }) {
    return `${sentence(name)} musi by\u0107 numerem.`;
  },
  required({ name }) {
    return `${sentence(name)} jest wymagany.`;
  },
  starts_with({ name, args }) {
    return `${sentence(name)} nie zaczyna si\u0119 od ${list(args)}.`;
  },
  url() {
    return `Prosz\u0119 poda\u0107 prawid\u0142owy adres url.`;
  }
};
var pl = Object.freeze({
  __proto__: null,
  ui: ui$5,
  validation: validation$5
});
var ui$4 = {
  remove: "Remover",
  removeAll: "Deletar tudo",
  incomplete: "Desculpe, nem todos os campos foram preenchidos corretamente.",
  submit: "Enviar",
  noFiles: "Nenhum arquivo"
};
var validation$4 = {
  accepted({ name }) {
    return `Por favor aceite o ${name}.`;
  },
  date_after({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} deve ser posterior a ${date2(args[0])}.`;
    }
    return `${sentence(name)} deve ser no futuro.`;
  },
  alpha({ name }) {
    return `${sentence(name)} s\xF3 pode conter caracteres do alfabeto.`;
  },
  alphanumeric({ name }) {
    return `${sentence(name)} s\xF3 pode ter letras e n\xFAmeros.`;
  },
  alpha_spaces({ name }) {
    return `${sentence(name)} s\xF3 podem conter letras e espa\xE7os.`;
  },
  date_before({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} deve ser anterior a ${date2(args[0])}.`;
    }
    return `${sentence(name)} deve ser anterior a data atual.`;
  },
  between({ name, args }) {
    if (isNaN(args[0]) || isNaN(args[1])) {
      return `O campo foi configurado incorretamente e n\xE3o pode ser enviado.`;
    }
    return `${sentence(name)} deve estar entre ${args[0]} e ${args[1]}.`;
  },
  confirm({ name }) {
    return `${sentence(name)} n\xE3o confere.`;
  },
  date_format({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} n\xE3o \xE9 uma data v\xE1lida, por favor use o formato ${args[0]}`;
    }
    return "O campo foi configurado incorretamente e n\xE3o pode ser enviado.";
  },
  date_between({ name, args }) {
    return `${sentence(name)} deve ser entre ${date2(args[0])} e ${date2(args[1])}`;
  },
  email: "Por favor informe um e-mail v\xE1lido.",
  ends_with({ name, args }) {
    return `${sentence(name)} n\xE3o termina com ${list(args)}.`;
  },
  is({ name }) {
    return `${sentence(name)} n\xE3o \xE9 um valor permitido.`;
  },
  length({ name, args: [first = 0, second = Infinity] }) {
    const min3 = first <= second ? first : second;
    const max3 = second >= first ? second : first;
    if (min3 == 1 && max3 === Infinity) {
      return `${sentence(name)} deve ter ao menos um caractere.`;
    }
    if (min3 == 0 && max3) {
      return `${sentence(name)} n\xE3o pode ter mais que ${max3} caracteres.`;
    }
    if (min3 && max3 === Infinity) {
      return `${sentence(name)} deve ter no m\xEDnimo ${min3} caracteres.`;
    }
    return `${sentence(name)} deve ter entre ${min3} e ${max3} caracteres.`;
  },
  matches({ name }) {
    return `${sentence(name)} n\xE3o \xE9 um valor permitido.`;
  },
  max({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `N\xE3o pode ter mais que ${args[0]} ${name}.`;
    }
    return `${sentence(name)} deve ser igual ou menor que ${args[0]}.`;
  },
  mime({ name, args }) {
    if (!args[0]) {
      return "Nenhum formato de arquivo permitido.";
    }
    return `${sentence(name)} deve ser do tipo: ${args[0]}`;
  },
  min({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `N\xE3o pode ter menos que ${args[0]} ${name}.`;
    }
    return `${sentence(name)} deve ter pelo menos ${args[0]}.`;
  },
  not({ name, node: { value } }) {
    return `\u201C${value}\u201D n\xE3o permite ${name}.`;
  },
  number({ name }) {
    return `${sentence(name)} deve ser um n\xFAmero.`;
  },
  required({ name }) {
    return `${sentence(name)} \xE9 obrigat\xF3rio.`;
  },
  starts_with({ name, args }) {
    return `${sentence(name)} n\xE3o come\xE7a com ${list(args)}.`;
  },
  url() {
    return `Por favor informe um url v\xE1lido.`;
  }
};
var pt = Object.freeze({
  __proto__: null,
  ui: ui$4,
  validation: validation$4
});
var ui$3 = {
  remove: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C",
  removeAll: "\u0423\u0431\u0440\u0430\u0442\u044C \u0432\u0441\u0435",
  incomplete: "\u0418\u0437\u0432\u0438\u043D\u0438\u0442\u0435, \u043D\u0435 \u0432\u0441\u0435 \u043F\u043E\u043B\u044F \u0437\u0430\u043F\u043E\u043B\u043D\u0435\u043D\u044B \u0432\u0435\u0440\u043D\u043E.",
  submit: "\u041E\u0442\u043F\u0440\u0430\u0432\u0438\u0442\u044C",
  noFiles: "\u0424\u0430\u0439\u043B \u043D\u0435 \u0432\u044B\u0431\u0440\u0430\u043D"
};
var validation$3 = {
  accepted({ name }) {
    return `\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u043F\u0440\u0438\u043C\u0438\u0442\u0435 ${name}.`;
  },
  date_after({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `\u0414\u0430\u0442\u0430 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u043F\u043E\u0437\u0436\u0435 ${date2(args[0])}.`;
    }
    return `\u0414\u0430\u0442\u0430 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u0432 \u0431\u0443\u0434\u0443\u0449\u0435\u043C.`;
  },
  alpha({ name }) {
    return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u043C\u043E\u0436\u0435\u0442 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u0442\u043E\u043B\u044C\u043A\u043E \u0431\u0443\u043A\u0432\u044B.`;
  },
  alphanumeric({ name }) {
    return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u043C\u043E\u0436\u0435\u0442 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u0442\u043E\u043B\u044C\u043A\u043E \u0431\u0443\u043A\u0432\u044B \u0438 \u0446\u0438\u0444\u0440\u044B.`;
  },
  alpha_spaces({ name }) {
    return `${sentence(name)} \u043C\u043E\u0433\u0443\u0442 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u0442\u043E\u043B\u044C\u043A\u043E \u0431\u0443\u043A\u0432\u044B \u0438 \u043F\u0440\u043E\u0431\u0435\u043B\u044B.`;
  },
  date_before({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `\u0414\u0430\u0442\u0430 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u0440\u0430\u043D\u044C\u0448\u0435 ${date2(args[0])}.`;
    }
    return `\u0414\u0430\u0442\u0430 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u0432 \u043F\u0440\u043E\u0448\u043B\u043E\u043C.`;
  },
  between({ name, args }) {
    if (isNaN(args[0]) || isNaN(args[1])) {
      return `\u042D\u0442\u043E \u043F\u043E\u043B\u0435 \u0437\u0430\u043F\u043E\u043B\u043D\u0435\u043D\u043E \u043D\u0435\u0432\u0435\u0440\u043D\u043E \u0438 \u043D\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u043E.`;
    }
    const [a, b] = order(args[0], args[1]);
    return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043C\u0435\u0436\u0434\u0443 ${a} \u0438 ${b}.`;
  },
  confirm({ name }) {
    return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u043D\u0435 \u0441\u043E\u0432\u043F\u0430\u0434\u0430\u0435\u0442.`;
  },
  date_format({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0438\u043C\u0435\u0435\u0442 \u043D\u0435\u0432\u0435\u0440\u043D\u0443\u044E \u0434\u0430\u0442\u0443. \u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439\u0442\u0435 \u0444\u043E\u0440\u043C\u0430\u0442 ${args[0]}`;
    }
    return "\u042D\u0442\u043E \u043F\u043E\u043B\u0435 \u0437\u0430\u043F\u043E\u043B\u043D\u0435\u043D\u043E \u043D\u0435\u0432\u0435\u0440\u043D\u043E \u0438 \u043D\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u043E.";
  },
  date_between({ name, args }) {
    return `\u0414\u0430\u0442\u0430 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u043C\u0435\u0436\u0434\u0443 ${date2(args[0])} \u0438 ${date2(args[1])}`;
  },
  email: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0432\u0432\u0435\u0434\u0438\u0442\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 \u044D\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u044B\u0439 \u0430\u0434\u0440\u0435\u0441.",
  ends_with({ name, args }) {
    return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u043D\u0435 \u0434\u043E\u043B\u0436\u043D\u043E \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 ${list(args)}.`;
  },
  is({ name }) {
    return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0438\u043C\u0435\u0435\u0442 \u043D\u0435\u043F\u043E\u0434\u0443\u0441\u0442\u0438\u043C\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435.`;
  },
  length({ name, args: [first = 0, second = Infinity] }) {
    const min3 = Number(first) <= Number(second) ? first : second;
    const max3 = Number(second) >= Number(first) ? second : first;
    if (min3 == 1 && max3 === Infinity) {
      return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u043E \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u043C\u0438\u043D\u0438\u043C\u0443\u043C \u043E\u0434\u0438\u043D \u0441\u0438\u043C\u0432\u043E\u043B.`;
    }
    if (min3 == 0 && max3) {
      return `\u0414\u043B\u0438\u043D\u0430 \u043F\u043E\u043B\u044F ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u043C\u0435\u043D\u044C\u0448\u0435 \u0438\u043B\u0438 \u0440\u0430\u0432\u043D\u0430 ${max3} \u0441\u0438\u043C\u0432\u043E\u043B\u0430\u043C.`;
    }
    if (min3 && max3 === Infinity) {
      return `\u0414\u043B\u0438\u043D\u0430 \u043F\u043E\u043B\u044F ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u0431\u043E\u043B\u044C\u0448\u0435 \u0438\u043B\u0438 \u0440\u0430\u0432\u043D\u0430 ${min3} \u0441\u0438\u043C\u0432\u043E\u043B\u0430\u043C.`;
    }
    return `\u0414\u043B\u0438\u043D\u0430 \u043F\u043E\u043B\u044F ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u043C\u0435\u0436\u0434\u0443 ${min3} \u0438 ${max3} \u0441\u0438\u043C\u0432\u043E\u043B\u0430\u043C\u0438.`;
  },
  matches({ name }) {
    return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0438\u043C\u0435\u0435\u0442 \u043D\u0435\u0434\u043E\u043F\u0443\u0441\u0442\u0438\u043C\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435.`;
  },
  max({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `\u041D\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u0432\u044B\u0431\u0440\u0430\u043D\u043E \u0431\u043E\u043B\u044C\u0448\u0435, \u0447\u0435\u043C ${args[0]} ${name}.`;
    }
    return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043C\u0435\u043D\u044C\u0448\u0435 \u0438\u043B\u0438 \u0440\u0430\u0432\u043D\u043E ${args[0]}.`;
  },
  mime({ name, args }) {
    if (!args[0]) {
      return "\u041D\u0435 \u0443\u043A\u0430\u0437\u0430\u043D\u044B \u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0430\u0432\u0435\u043C\u044B\u0435 \u0444\u043E\u0440\u043C\u0430\u0442\u044B \u0444\u0430\u0439\u043B\u0430.";
    }
    return `\u0424\u043E\u0440\u043C\u0430\u0442 \u0444\u0430\u0439\u043B\u0430 \u0432 \u043F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u0435\u043D \u0431\u044B\u0442\u044C: ${args[0]}.`;
  },
  min({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `\u041D\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u0432\u044B\u0431\u0440\u0430\u043D\u043E \u043C\u0435\u043D\u044C\u0448\u0435, \u0447\u0435\u043C ${args[0]} ${name}.`;
    }
    return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043D\u0435 \u043C\u0435\u043D\u0435\u0435, \u0447\u0435\u043C ${args[0]}.`;
  },
  not({ name, node: { value } }) {
    return `\u201C${value}\u201D \u043D\u0435 \u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442\u0441\u044F \u0432 \u043F\u043E\u043B\u0435 ${name}.`;
  },
  number({ name }) {
    return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u0447\u0438\u0441\u043B\u043E\u043C.`;
  },
  required({ name }) {
    return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u043E\u0431\u044F\u0437\u0430\u0442\u0435\u043B\u044C\u043D\u043E \u0434\u043B\u044F \u0437\u0430\u043F\u043E\u043B\u043D\u0435\u043D\u0438\u044F.`;
  },
  starts_with({ name, args }) {
    return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u043E \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 ${list(args)}.`;
  },
  url() {
    return `\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0432\u0432\u0435\u0434\u0438\u0442\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 URL \u0430\u0434\u0440\u0435\u0441.`;
  }
};
var ru = Object.freeze({
  __proto__: null,
  ui: ui$3,
  validation: validation$3
});
var ui$2 = {
  remove: "Kald\u0131r",
  removeAll: "Hepsini kald\u0131r",
  incomplete: "Maalesef, t\xFCm alanlar do\u011Fru doldurulmad\u0131.",
  submit: "G\xF6nder",
  noFiles: "Dosya yok"
};
var validation$2 = {
  accepted({ name }) {
    return `L\xFCtfen ${name}'yi kabul edin.`;
  },
  date_after({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} ${date2(args[0])}'den sonra olmal\u0131d\u0131r.`;
    }
    return `${sentence(name)} gelecekte bir zaman olmal\u0131d\u0131r.`;
  },
  alpha({ name }) {
    return `${sentence(name)} sadece alfabetik karakterler i\xE7erebilir.`;
  },
  alphanumeric({ name }) {
    return `${sentence(name)} sadece alfabetik karakterler ve say\u0131 i\xE7erebilir.`;
  },
  alpha_spaces({ name }) {
    return `${sentence(name)} yaln\u0131zca harf ve bo\u015Fluk i\xE7erebilir.`;
  },
  date_before({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} ${date2(args[0])} tarihinden \xF6nce olmal\u0131.`;
    }
    return `${sentence(name)} ge\xE7mi\u015Fte olmal\u0131.`;
  },
  between({ name, args }) {
    if (isNaN(args[0]) || isNaN(args[1])) {
      return `Alan yanl\u0131\u015F yap\u0131land\u0131r\u0131lm\u0131\u015F ve g\xF6nderilemez.`;
    }
    return `${sentence(name)} ${args[0]} ve ${args[1]} aral\u0131\u011F\u0131nda olmal\u0131.`;
  },
  confirm({ name }) {
    return `${sentence(name)} e\u015Fle\u015Fmiyor.`;
  },
  date_format({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} ge\xE7erli bir tarih de\u011Fil, l\xFCtfen ${args[0]} bi\xE7imini kullan\u0131n.`;
    }
    return "Alan yanl\u0131\u015F yap\u0131land\u0131r\u0131lm\u0131\u015F ve g\xF6nderilemez.";
  },
  date_between({ name, args }) {
    return `${sentence(name)}, ${date2(args[0])} ve ${date2(args[1])} aral\u0131\u011F\u0131nda olmal\u0131.`;
  },
  email: "L\xFCtfen ge\xE7erli bir e-mail adresi girin.",
  ends_with({ name, args }) {
    return `${sentence(name)} ${list(args)} ile bitmiyor.`;
  },
  is({ name }) {
    return `${sentence(name)} izin verilen bir de\u011Fer de\u011Fil.`;
  },
  length({ name, args: [first = 0, second = Infinity] }) {
    const min3 = first <= second ? first : second;
    const max3 = second >= first ? second : first;
    if (min3 == 1 && max3 === Infinity) {
      return `${sentence(name)} en az\u0131ndan bir karakter uzunlu\u011Funda olmal\u0131.`;
    }
    if (min3 == 0 && max3) {
      return `${sentence(name)} ${max3}'e e\u015Fit veya daha k\xFC\xE7\xFCk olmal\u0131.`;
    }
    if (min3 && max3 === Infinity) {
      return `${sentence(name)} ${min3}'e e\u015Fit veya daha b\xFCy\xFCk olmal\u0131.`;
    }
    return `${sentence(name)}, ${min3} ve ${max3} karakter uzunlu\u011Fu aral\u0131\u011F\u0131nda olmal\u0131.`;
  },
  matches({ name }) {
    return `${sentence(name)} izin verilen bir de\u011Fer de\u011Fil.`;
  },
  max({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `${name}'in uzunlu\u011Fu ${args[0]}'dan daha uzun olamaz.`;
    }
    return `${sentence(name)} en az\u0131ndan ${args[0]} uzunlu\u011Funda veya ona e\u015Fit olmal\u0131.`;
  },
  mime({ name, args }) {
    if (!args[0]) {
      return "Hi\xE7bir dosya t\xFCr\xFCne izin verilmez.";
    }
    return `${sentence(name)} \u015Fu tiplerden biri olmal\u0131: ${args[0]}`;
  },
  min({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `${name}'in uzunlu\u011Fu ${args[0]}'dan daha k\u0131sa olamaz.`;
    }
    return `${sentence(name)} en az\u0131ndan ${args[0]} uzunlu\u011Funda olmal\u0131.`;
  },
  not({ name, node: { value } }) {
    return `\u201C${value}\u201D ${name} olamaz.`;
  },
  number({ name }) {
    return `${sentence(name)} say\u0131 olmal\u0131.`;
  },
  required({ name }) {
    return `${sentence(name)} gerekli.`;
  },
  starts_with({ name, args }) {
    return `${sentence(name)} ${list(args)} ile ba\u015Flam\u0131yor.`;
  },
  url() {
    return `L\xFCtfen ge\xE7erli bir url dahil edin.`;
  }
};
var tr = Object.freeze({
  __proto__: null,
  ui: ui$2,
  validation: validation$2
});
var ui$1 = {
  remove: "Xo\xE1",
  removeAll: "Xo\xE1 t\u1EA5t c\u1EA3",
  incomplete: "Xin l\u1ED7i, kh\xF4ng ph\u1EA3i t\u1EA5t c\u1EA3 c\xE1c tr\u01B0\u1EDDng \u0111\u1EC1u \u0111\u01B0\u1EE3c nh\u1EADp \u0111\xFAng.",
  submit: "G\u1EEDi",
  noFiles: "Ch\u01B0a ch\u1ECDn file"
};
var validation$1 = {
  accepted({ name }) {
    return `H\xE3y \u0111\u1ED3ng \xFD v\u1EDBi ${name}.`;
  },
  date_after({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} ph\u1EA3i sau ${date2(args[0])}.`;
    }
    return `${sentence(name)} ph\u1EA3i trong t\u01B0\u01A1ng lai.`;
  },
  alpha({ name }) {
    return `${sentence(name)} c\xF3 th\u1EC3 ch\u1EC9 bao g\u1ED3m c\xE1c ch\u1EEF c\xE1i alphabet.`;
  },
  alphanumeric({ name }) {
    return `${sentence(name)} c\xF3 th\u1EC3 ch\u1EC9 bao g\u1ED3m c\xE1c ch\u1EEF c\xE1i v\xE0 ch\u1EEF s\u1ED1.`;
  },
  alpha_spaces({ name }) {
    return `${sentence(name)} ch\u1EC9 c\xF3 th\u1EC3 ch\u1EE9a c\xE1c ch\u1EEF c\xE1i v\xE0 kho\u1EA3ng tr\u1EAFng.`;
  },
  date_before({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} ph\u1EA3i tr\u01B0\u1EDBc ${date2(args[0])}.`;
    }
    return `${sentence(name)} ph\u1EA3i trong qu\xE1 kh\u1EE9.`;
  },
  between({ name, args }) {
    if (isNaN(args[0]) || isNaN(args[1])) {
      return `Tr\u01B0\u1EDDng n\xE0y \u0111\xE3 \u0111\u01B0\u1EE3c thi\u1EBFt l\u1EADp sai v\xE0 kh\xF4ng th\u1EC3 g\u1EEDi.`;
    }
    const [a, b] = order(args[0], args[1]);
    return `${sentence(name)} ph\u1EA3i \u1EDF gi\u1EEFa ${a} v\xE0 ${b}.`;
  },
  confirm({ name }) {
    return `${sentence(name)} kh\xF4ng kh\u1EDBp.`;
  },
  date_format({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)} kh\xF4ng ph\u1EA3i ng\xE0y h\u1EE3p l\u1EC7, h\xE3y s\u1EED d\u1EE5ng \u0111\u1ECBnh d\u1EA1ng ${args[0]}`;
    }
    return "Tr\u01B0\u1EDDng n\xE0y \u0111\xE3 \u0111\u01B0\u1EE3c thi\u1EBFt l\u1EADp sai v\xE0 kh\xF4ng th\u1EC3 g\u1EEDi.";
  },
  date_between({ name, args }) {
    return `${sentence(name)} ph\u1EA3i \u1EDF gi\u1EEFa kho\u1EA3ng t\u1EEB ${date2(args[0])} \u0111\u1EBFn ${date2(args[1])}.`;
  },
  email: "H\xE3y nh\u1EADp m\u1ED9t \u0111\u1ECBa ch\u1EC9 email h\u1EE3p l\u1EC7.",
  ends_with({ name, args }) {
    return `${sentence(name)} kh\xF4ng k\u1EBFt th\xFAc v\u1EDBi ${list(args)}.`;
  },
  is({ name }) {
    return `${sentence(name)} kh\xF4ng ph\u1EA3i m\u1ED9t gi\xE1 tr\u1ECB \u0111\u01B0\u1EE3c cho ph\xE9p.`;
  },
  length({ name, args: [first = 0, second = Infinity] }) {
    const min3 = Number(first) <= Number(second) ? first : second;
    const max3 = Number(second) >= Number(first) ? second : first;
    if (min3 == 1 && max3 === Infinity) {
      return `${sentence(name)} ph\u1EA3i c\xF3 \u0111\u1ED9 d\xE0i t\u1ED1i thi\u1EC3u m\u1ED9t k\xFD t\u1EF1.`;
    }
    if (min3 == 0 && max3) {
      return `${sentence(name)} ph\u1EA3i c\xF3 \u0111\u1ED9 d\xE0i t\u1ED1i \u0111a ${max3} k\xFD t\u1EF1.`;
    }
    if (min3 && max3 === Infinity) {
      return `${sentence(name)} ph\u1EA3i c\xF3 \u0111\u1ED9 d\xE0i t\u1ED1i thi\u1EC3u ${min3} k\xFD t\u1EF1.`;
    }
    return `${sentence(name)} ph\u1EA3i c\xF3 \u0111\u1ED9 d\xE0i t\u1ED1i \u0111a trong kho\u1EA3ng t\u1EEB ${min3} \u0111\u1EBFn ${max3} k\xFD t\u1EF1.`;
  },
  matches({ name }) {
    return `${sentence(name)} kh\xF4ng ph\u1EA3i m\u1ED9t gi\xE1 tr\u1ECB \u0111\u01B0\u1EE3c cho ph\xE9p.`;
  },
  max({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `${name} kh\xF4ng th\u1EC3 l\u1EDBn h\u01A1n ${args[0]}.`;
    }
    return `${sentence(name)} ph\u1EA3i t\u1ED1i \u0111a b\u1EB1ng ${args[0]}.`;
  },
  mime({ name, args }) {
    if (!args[0]) {
      return "\u0110\u1ECBnh d\u1EA1ng t\u1EC7p tin n\xE0y kh\xF4ng \u0111\u01B0\u1EE3c ph\xE9p.";
    }
    return `${sentence(name)} ph\u1EA3i l\xE0 m\u1ED9t trong c\xE1c d\u1EA1ng: ${args[0]}`;
  },
  min({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `${name} kh\xF4ng th\u1EC3 nh\u1ECF h\u01A1n ${args[0]}.`;
    }
    return `${sentence(name)} ph\u1EA3i t\u1ED1i thi\u1EC3u b\u1EB1ng ${args[0]}.`;
  },
  not({ name, node: { value } }) {
    return `"${value}" kh\xF4ng ph\u1EA3i gi\xE1 tr\u1ECB ${name} \u0111\u01B0\u1EE3c ph\xE9p.`;
  },
  number({ name }) {
    return `${sentence(name)} ph\u1EA3i l\xE0 m\u1ED9t s\u1ED1.`;
  },
  required({ name }) {
    return `${sentence(name)} l\xE0 b\u1EAFt bu\u1ED9c.`;
  },
  starts_with({ name, args }) {
    return `${sentence(name)} kh\xF4ng b\u1EAFt \u0111\u1EA7u v\u1EDBi ${list(args)}.`;
  },
  url() {
    return `H\xE3y nh\u1EADp m\u1ED9t URL h\u1EE3p l\u1EC7.`;
  }
};
var vi = Object.freeze({
  __proto__: null,
  ui: ui$1,
  validation: validation$1
});
var ui = {
  remove: "\u79FB\u9664",
  incomplete: "\u5BF9\u4E0D\u8D77\uFF0C\u6709\u4E9B\u5B57\u6BB5\u672A\u88AB\u6B63\u786E\u586B\u5199",
  submit: "\u63D0\u4EA4"
};
var validation = {
  accepted({ name }) {
    return `\u8BF7\u63A5\u53D7${name}`;
  },
  date_after({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)}\u5FC5\u987B\u665A\u4E8E${date2(args[0])}`;
    }
    return `${sentence(name)}\u5FC5\u987B\u662F\u672A\u6765\u7684\u65E5\u671F`;
  },
  alpha({ name }) {
    return `${sentence(name)}\u4EC5\u80FD\u5305\u542B\u5B57\u6BCD\u5B57\u7B26`;
  },
  alphanumeric({ name }) {
    return `${sentence(name)}\u4EC5\u80FD\u5305\u542B\u5B57\u6BCD\u548C\u6570\u5B57`;
  },
  alpha_spaces({ name }) {
    return `${sentence(name)}\u53EA\u80FD\u5305\u542B\u5B57\u6BCD\u548C\u7A7A\u683C`;
  },
  date_before({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)}\u5FC5\u987B\u65E9\u4E8E${date2(args[0])}`;
    }
    return `${sentence(name)}\u5FC5\u987B\u662F\u8FC7\u53BB\u7684\u65E5\u671F`;
  },
  between({ name, args }) {
    if (isNaN(args[0]) || isNaN(args[1])) {
      return `\u8BE5\u5B57\u6BB5\u672A\u88AB\u6B63\u786E\u8BBE\u7F6E\u800C\u65E0\u6CD5\u88AB\u63D0\u4EA4`;
    }
    return `${sentence(name)}\u5FC5\u987B\u5728${args[0]}\u548C${args[1]}\u4E4B\u95F4`;
  },
  confirm({ name }) {
    return `${sentence(name)}\u4E0D\u5339\u914D`;
  },
  date_format({ name, args }) {
    if (Array.isArray(args) && args.length) {
      return `${sentence(name)}\u4E0D\u662F\u4E00\u4E2A\u5408\u6CD5\u65E5\u671F\uFF0C\u8BF7\u4F7F\u7528\u6B64\u683C\u5F0F${args[0]}`;
    }
    return "\u8BE5\u5B57\u6BB5\u672A\u88AB\u6B63\u786E\u8BBE\u7F6E\u800C\u65E0\u6CD5\u88AB\u63D0\u4EA4";
  },
  date_between({ name, args }) {
    return `${sentence(name)}\u5FC5\u987B\u5728${date2(args[0])}\u548C${date2(args[1])}\u4E4B\u95F4`;
  },
  email: "\u8BF7\u8F93\u5165\u4E00\u4E2A\u5408\u6CD5\u7684\u7535\u5B50\u90AE\u4EF6\u5730\u5740",
  ends_with({ name, args }) {
    return `${sentence(name)}\u5E76\u672A\u4EE5${list(args)}\u7ED3\u5C3E`;
  },
  is({ name }) {
    return `${sentence(name)}\u4E0D\u662F\u4E00\u4E2A\u5141\u8BB8\u503C`;
  },
  length({ name, args: [first = 0, second = Infinity] }) {
    const min3 = first <= second ? first : second;
    const max3 = second >= first ? second : first;
    if (min3 == 1 && max3 === Infinity) {
      return `${sentence(name)}\u81F3\u5C11\u8981\u6709\u4E00\u4E2A\u5B57\u7B26`;
    }
    if (min3 == 0 && max3) {
      return `${sentence(name)}\u5FC5\u987B\u5C11\u4E8E\u6216\u7B49\u4E8E${max3}\u4E2A\u5B57\u7B26`;
    }
    if (min3 && max3 === Infinity) {
      return `${sentence(name)}\u5FC5\u987B\u591A\u4E8E\u6216\u7B49\u4E8E${min3}\u4E2A\u5B57\u7B26`;
    }
    return `${sentence(name)}\u5FC5\u987B\u6709${min3}\u81F3${max3}\u4E2A\u5B57\u7B26`;
  },
  matches({ name }) {
    return `${sentence(name)}\u4E0D\u662F\u4E00\u4E2A\u5141\u8BB8\u503C`;
  },
  max({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `${name}\u4E0D\u80FD\u8D85\u8FC7${args[0]}`;
    }
    return `${sentence(name)}\u5FC5\u987B\u5C0F\u4E8E\u6216\u7B49\u4E8E${args[0]}`;
  },
  mime({ name, args }) {
    if (!args[0]) {
      return "\u65E0\u5141\u8BB8\u7684\u6587\u4EF6\u683C\u5F0F";
    }
    return `${sentence(name)}\u5FC5\u987B\u4E3A\u6B64\u7C7B\u578B\uFF1A${args[0]}`;
  },
  min({ name, node: { value }, args }) {
    if (Array.isArray(value)) {
      return `${name}\u4E0D\u80FD\u5C11\u4E8E${args[0]}`;
    }
    return `${sentence(name)}\u4E0D\u80FD\u5C0F\u4E8E${args[0]}`;
  },
  not({ name, node: { value } }) {
    return `\u201C${value}\u201D\u4E0D\u662F\u4E00\u4E2A\u88AB\u5141\u8BB8\u7684${name}`;
  },
  number({ name }) {
    return `${sentence(name)}\u5FC5\u987B\u662F\u4E00\u4E2A\u6570\u5B57`;
  },
  required({ name }) {
    return `${sentence(name)}\u5FC5\u987B\u586B\u5199`;
  },
  starts_with({ name, args }) {
    return `${sentence(name)}\u6CA1\u6709\u4EE5${list(args)}\u5F00\u5934`;
  },
  url() {
    return `\u8BF7\u5305\u542B\u4E00\u4E2A\u5408\u6CD5\u7684url`;
  }
};
var zh = Object.freeze({
  __proto__: null,
  ui,
  validation
});
function createI18nPlugin(registry) {
  return function i18nPlugin(node) {
    let localeKey = parseLocale(node.config.locale, registry);
    let locale = localeKey ? registry[localeKey] : {};
    node.on("prop:locale", ({ payload: lang }) => {
      localeKey = parseLocale(lang, registry);
      locale = localeKey ? registry[localeKey] : {};
      node.store.touch();
    });
    node.hook.text((fragment, next) => {
      var _a, _b;
      const key = ((_a = fragment.meta) === null || _a === void 0 ? void 0 : _a.messageKey) || fragment.key;
      if (has(locale, fragment.type) && has(locale[fragment.type], key)) {
        const t = locale[fragment.type][key];
        if (typeof t === "function") {
          fragment.value = Array.isArray((_b = fragment.meta) === null || _b === void 0 ? void 0 : _b.i18nArgs) ? t(...fragment.meta.i18nArgs) : t(fragment);
        } else {
          fragment.value = t;
        }
      }
      return next(fragment);
    });
  };
}
function parseLocale(locale, availableLocales) {
  if (has(availableLocales, locale)) {
    return locale;
  }
  const [lang] = locale.split("-");
  if (has(availableLocales, lang)) {
    return lang;
  }
  for (const locale2 in availableLocales) {
    return locale2;
  }
  return false;
}

// node_modules/@formkit/dev/dist/index.mjs
var registered = false;
var errors = {
  100: ({ data: node }) => `Only groups, lists, and forms can have children (${node.name}).`,
  101: ({ data: node }) => `You cannot directly modify the store (${node.name}). See: https://formkit.com/advanced/core#message-store`,
  102: ({ data: [node, property] }) => `You cannot directly assign node.${property} (${node.name})`,
  103: ({ data: [operator] }) => `Schema expressions cannot start with an operator (${operator})`,
  104: ({ data: [operator, expression] }) => `Schema expressions cannot end with an operator (${operator} in "${expression}")`,
  105: ({ data: expression }) => `Invalid schema expression: ${expression}`,
  106: ({ data: name }) => `Cannot submit because (${name}) is not in a form.`,
  107: ({ data: [node, value] }) => `Cannot set ${node.name} to non object value: ${value}`,
  108: ({ data: [node, value] }) => `Cannot set ${node.name} to non array value: ${value}`,
  600: ({ data: node }) => `Unknown input type${typeof node.props.type === "string" ? ' "' + node.props.type + '"' : ""} ("${node.name}")`,
  601: ({ data: node }) => `Input definition${typeof node.props.type === "string" ? ' "' + node.props.type + '"' : ""} is missing a schema or component property (${node.name}).`
};
var warnings = {
  150: ({ data: fn }) => `Schema function "${fn}()" is not a valid function.`,
  151: ({ data: id2 }) => `No form element with id: ${id2}`,
  152: ({ data: id2 }) => `No input element with id: ${id2}`,
  350: ({ data: node }) => `Invalid options prop for radio input (${node.name}). See https://formkit.com/inputs/radio`,
  650: 'Schema "$get()" must use the id of an input to access.',
  651: ({ data: id2 }) => `Cannot setErrors() on "${id2}" because no such id exists.`
};
var decodeErrors = (error2, next) => {
  if (error2.code in errors) {
    const err = errors[error2.code];
    error2.message = typeof err === "function" ? err(error2) : err;
  }
  return next(error2);
};
if (!registered)
  errorHandler(decodeErrors);
var decodeWarnings = (warning, next) => {
  if (warning.code in warnings) {
    const warn2 = warnings[warning.code];
    warning.message = typeof warn2 === "function" ? warn2(warning) : warn2;
  }
  return next(warning);
};
if (!registered)
  warningHandler(decodeWarnings);
registered = true;

// node_modules/@formkit/vue/dist/index.mjs
var memo = {};
var instanceKey;
var instanceScopes = /* @__PURE__ */ new Map();
var raw = "__raw__";
var isClassProp = /[a-zA-Z0-9\-][cC]lass$/;
function getRef(token2, data) {
  const value = ref(null);
  const nodeRef = ref(void 0);
  if (token2 === "get") {
    value.value = get.bind(null, nodeRef);
    return value;
  }
  const path = token2.split(".");
  watchEffect(() => value.value = getValue(data, path));
  return value;
}
function getValue(set, path) {
  if (Array.isArray(set)) {
    for (const subset of set) {
      const value = subset !== false && getValue(subset, path);
      if (value !== void 0)
        return value;
    }
    return void 0;
  }
  let foundValue = void 0;
  path.reduce((obj, segment, i2, arr) => {
    if (typeof obj !== "object") {
      foundValue = void 0;
      return arr.splice(1);
    }
    const currentValue = obj[segment];
    if (i2 === path.length - 1 && currentValue !== void 0) {
      foundValue = currentValue;
    }
    return obj[segment];
  }, set);
  return foundValue;
}
function get(nodeRef, id2) {
  if (typeof id2 !== "string")
    return warn(650);
  if (nodeRef.value === void 0) {
    nodeRef.value = null;
    const root = getNode$1(id2);
    if (root)
      nodeRef.value = root.context;
    watchRegistry(id2, ({ payload: node }) => {
      nodeRef.value = isNode(node) ? node.context : node;
    });
  }
  return nodeRef.value;
}
function parseSchema(library, schema) {
  function parseCondition(library2, node) {
    const condition = provider(compile(node.if), { if: true });
    const children = createElements(library2, node.then);
    const alternate = node.else ? createElements(library2, node.else) : null;
    return [condition, children, alternate];
  }
  function parseConditionAttr(attr, _default) {
    var _a, _b;
    const condition = provider(compile(attr.if));
    let b = () => _default;
    let a = () => _default;
    if (typeof attr.then === "object") {
      a = parseAttrs(attr.then, void 0);
    } else if (typeof attr.then === "string" && ((_a = attr.then) === null || _a === void 0 ? void 0 : _a.startsWith("$"))) {
      a = provider(compile(attr.then));
    } else {
      a = () => attr.then;
    }
    if (has(attr, "else")) {
      if (typeof attr.else === "object") {
        b = parseAttrs(attr.else);
      } else if (typeof attr.else === "string" && ((_b = attr.else) === null || _b === void 0 ? void 0 : _b.startsWith("$"))) {
        b = provider(compile(attr.else));
      } else {
        b = () => attr.else;
      }
    }
    return () => condition() ? a() : b();
  }
  function parseAttrs(unparsedAttrs, bindExp, _default = {}) {
    const explicitAttrs = new Set(Object.keys(unparsedAttrs || {}));
    const boundAttrs = bindExp ? provider(compile(bindExp)) : () => ({});
    const staticAttrs = {};
    const setters = [
      (attrs) => {
        const bound = boundAttrs();
        for (const attr in bound) {
          if (!explicitAttrs.has(attr)) {
            attrs[attr] = bound[attr];
          }
        }
      }
    ];
    if (unparsedAttrs) {
      if (isConditional(unparsedAttrs)) {
        const condition = parseConditionAttr(unparsedAttrs, _default);
        return condition;
      }
      for (let attr in unparsedAttrs) {
        const value = unparsedAttrs[attr];
        let getValue2;
        const isStr = typeof value === "string";
        if (attr.startsWith(raw)) {
          attr = attr.substring(7);
          getValue2 = () => value;
        } else if (isStr && value.startsWith("$") && value.length > 1 && !(value.startsWith("$reset") && isClassProp.test(attr))) {
          getValue2 = provider(compile(value));
        } else if (typeof value === "object" && isConditional(value)) {
          getValue2 = parseConditionAttr(value, void 0);
        } else if (typeof value === "object" && isPojo(value)) {
          getValue2 = parseAttrs(value);
        } else {
          getValue2 = () => value;
          staticAttrs[attr] = value;
        }
        setters.push((attrs) => {
          attrs[attr] = getValue2();
        });
      }
    }
    return () => {
      const attrs = {};
      setters.forEach((setter) => setter(attrs));
      return attrs;
    };
  }
  function parseNode(library2, _node) {
    let element = null;
    let attrs = () => null;
    let condition = false;
    let children = null;
    let alternate = null;
    let iterator = null;
    let resolve = false;
    const node = sugar(_node);
    if (isDOM(node)) {
      element = node.$el;
      attrs = node.$el !== "text" ? parseAttrs(node.attrs, node.bind) : () => null;
    } else if (isComponent(node)) {
      if (typeof node.$cmp === "string") {
        if (has(library2, node.$cmp)) {
          element = library2[node.$cmp];
        } else {
          element = node.$cmp;
          resolve = true;
        }
      } else {
        element = node.$cmp;
      }
      attrs = parseAttrs(node.props, node.bind);
    } else if (isConditional(node)) {
      [condition, children, alternate] = parseCondition(library2, node);
    }
    if (!isConditional(node) && "if" in node) {
      condition = provider(compile(node.if));
    } else if (!isConditional(node) && element === null) {
      condition = () => true;
    }
    if ("children" in node && node.children) {
      if (typeof node.children === "string") {
        if (node.children.startsWith("$slots.")) {
          element = element === "text" ? "slot" : element;
          children = provider(compile(node.children));
        } else if (node.children.startsWith("$") && node.children.length > 1) {
          const value = provider(compile(node.children));
          children = () => String(value());
        } else {
          children = () => String(node.children);
        }
      } else if (Array.isArray(node.children)) {
        children = createElements(library2, node.children);
      } else {
        const [childCondition, c, a] = parseCondition(library2, node.children);
        children = (iterationData) => childCondition && childCondition() ? c && c(iterationData) : a && a(iterationData);
      }
    }
    if (isComponent(node)) {
      if (children) {
        const produceChildren = children;
        children = (iterationData) => {
          return {
            default(slotData2, key) {
              var _a, _b, _c, _d;
              const currentKey = instanceKey;
              if (key)
                instanceKey = key;
              if (slotData2)
                (_a = instanceScopes.get(instanceKey)) === null || _a === void 0 ? void 0 : _a.unshift(slotData2);
              if (iterationData)
                (_b = instanceScopes.get(instanceKey)) === null || _b === void 0 ? void 0 : _b.unshift(iterationData);
              const c = produceChildren(iterationData);
              if (slotData2)
                (_c = instanceScopes.get(instanceKey)) === null || _c === void 0 ? void 0 : _c.shift();
              if (iterationData)
                (_d = instanceScopes.get(instanceKey)) === null || _d === void 0 ? void 0 : _d.shift();
              instanceKey = currentKey;
              return c;
            }
          };
        };
        children.slot = true;
      } else {
        children = () => ({});
      }
    }
    if ("for" in node && node.for) {
      const values = node.for.length === 3 ? node.for[2] : node.for[1];
      const getValues = typeof values === "string" && values.startsWith("$") ? provider(compile(values)) : () => values;
      iterator = [
        getValues,
        node.for[0],
        node.for.length === 3 ? String(node.for[1]) : null
      ];
    }
    return [condition, element, attrs, children, alternate, iterator, resolve];
  }
  function createSlots(children, iterationData) {
    const slots = children(iterationData);
    const currentKey = instanceKey;
    return Object.keys(slots).reduce((allSlots, slotName) => {
      const slotFn = slots && slots[slotName];
      allSlots[slotName] = (data) => {
        return slotFn && slotFn(data, currentKey) || null;
      };
      return allSlots;
    }, {});
  }
  function createElement(library2, node) {
    const [condition, element, attrs, children, alternate, iterator, resolve] = parseNode(library2, node);
    let createNodes = (iterationData) => {
      if (condition && element === null && children) {
        return condition() ? children(iterationData) : alternate && alternate(iterationData);
      }
      if (element && (!condition || condition())) {
        if (element === "text" && children) {
          return createTextVNode(String(children()));
        }
        if (element === "slot" && children)
          return children(iterationData);
        const el = resolve ? resolveComponent(element) : element;
        const slots = (children === null || children === void 0 ? void 0 : children.slot) ? createSlots(children, iterationData) : null;
        return h(el, attrs(), slots || (children ? children(iterationData) : []));
      }
      return typeof alternate === "function" ? alternate(iterationData) : alternate;
    };
    if (iterator) {
      const repeatedNode = createNodes;
      const [getValues, valueName, keyName] = iterator;
      createNodes = () => {
        const _v = getValues();
        const values = !isNaN(_v) ? Array(Number(_v)).fill(0).map((_, i2) => i2) : _v;
        const fragment = [];
        if (typeof values !== "object")
          return null;
        const instanceScope = instanceScopes.get(instanceKey) || [];
        for (const key in values) {
          const iterationData = Object.defineProperty(__spreadValues(__spreadProps(__spreadValues({}, instanceScope.reduce((previousIterationData, scopedData) => {
            if (previousIterationData.__idata) {
              return __spreadValues(__spreadValues({}, previousIterationData), scopedData);
            }
            return scopedData;
          }, {})), {
            [valueName]: values[key]
          }), keyName !== null ? { [keyName]: key } : {}), "__idata", { enumerable: false, value: true });
          instanceScope.unshift(iterationData);
          fragment.push(repeatedNode.bind(null, iterationData)());
          instanceScope.shift();
        }
        return fragment;
      };
    }
    return createNodes;
  }
  function createElements(library2, schema2) {
    if (Array.isArray(schema2)) {
      const els = schema2.map(createElement.bind(null, library2));
      return (iterationData) => els.map((element2) => element2(iterationData));
    }
    const element = createElement(library2, schema2);
    return (iterationData) => element(iterationData);
  }
  const providers = [];
  function provider(compiled, hints = {}) {
    const compiledFns = {};
    providers.push((callback, key) => {
      compiledFns[key] = compiled.provide((tokens) => callback(tokens, hints));
    });
    return () => compiledFns[instanceKey]();
  }
  return function createInstance(providerCallback, key) {
    const memoKey = JSON.stringify(schema);
    const [render, compiledProviders] = has(memo, memoKey) ? memo[memoKey] : [createElements(library, schema), providers];
    memo[memoKey] = [render, compiledProviders];
    compiledProviders.forEach((compiledProvider) => {
      compiledProvider(providerCallback, key);
    });
    return () => {
      instanceKey = key;
      return render();
    };
  };
}
function useScope(token2, defaultValue) {
  const scopedData = instanceScopes.get(instanceKey) || [];
  let scopedValue = void 0;
  if (scopedData.length) {
    scopedValue = getValue(scopedData, token2.split("."));
  }
  return scopedValue === void 0 ? defaultValue : scopedValue;
}
function slotData(data, key) {
  return new Proxy(data, {
    get(...args) {
      let data2 = void 0;
      const property = args[1];
      if (typeof property === "string") {
        const prevKey = instanceKey;
        instanceKey = key;
        data2 = useScope(property, void 0);
        instanceKey = prevKey;
      }
      return data2 !== void 0 ? data2 : Reflect.get(...args);
    }
  });
}
function createRenderFn(instanceCreator, data, instanceKey2) {
  return instanceCreator((requirements, hints = {}) => {
    return requirements.reduce((tokens, token2) => {
      if (token2.startsWith("slots.")) {
        const slot = token2.substring(6);
        const hasSlot = data.slots && has(data.slots, slot);
        if (hints.if) {
          tokens[token2] = () => hasSlot;
        } else if (data.slots && hasSlot) {
          const scopedData = slotData(data, instanceKey2);
          tokens[token2] = () => data.slots[slot](scopedData);
          return tokens;
        }
      }
      const value = getRef(token2, data);
      tokens[token2] = () => useScope(token2, value.value);
      return tokens;
    }, {});
  }, instanceKey2);
}
var i = 0;
var FormKitSchema = defineComponent({
  name: "FormKitSchema",
  props: {
    schema: {
      type: [Array, Object],
      required: true
    },
    data: {
      type: Object,
      default: () => ({})
    },
    library: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props2, context) {
    const instance = getCurrentInstance();
    let instanceKey2 = Symbol(String(i++));
    instanceScopes.set(instanceKey2, []);
    let provider = parseSchema(props2.library, props2.schema);
    let render;
    let data;
    watch(() => props2.schema, (newSchema, oldSchema) => {
      var _a;
      instanceKey2 = Symbol(String(i++));
      provider = parseSchema(props2.library, props2.schema);
      render = createRenderFn(provider, data, instanceKey2);
      if (newSchema === oldSchema) {
        ((_a = instance === null || instance === void 0 ? void 0 : instance.proxy) === null || _a === void 0 ? void 0 : _a.$forceUpdate)();
      }
    }, { deep: true });
    watchEffect(() => {
      data = Object.assign(reactive(props2.data), {
        slots: context.slots
      });
      render = createRenderFn(provider, data, instanceKey2);
    });
    return () => render();
  }
});
var nativeProps = {
  config: {
    type: Object,
    default: {}
  },
  classes: {
    type: Object,
    required: false
  },
  delay: {
    type: Number,
    required: false
  },
  errors: {
    type: Array,
    default: []
  },
  inputErrors: {
    type: Object,
    default: () => ({})
  },
  id: {
    type: String,
    required: false
  },
  modelValue: {
    required: false
  },
  name: {
    type: String,
    required: false
  },
  parent: {
    type: Object,
    required: false
  },
  plugins: {
    type: Array,
    default: []
  },
  sectionsSchema: {
    type: Object,
    default: {}
  },
  type: {
    type: [String, Object],
    default: "text"
  },
  validation: {
    type: [String, Array],
    required: false
  },
  validationMessages: {
    type: Object,
    required: false
  },
  validationRules: {
    type: Object,
    required: false
  },
  validationLabel: {
    type: [String, Function],
    required: false
  }
};
var props = nativeProps;
var parentSymbol = Symbol("FormKitParent");
var FormKit = defineComponent({
  props,
  emits: {
    input: (_value) => true,
    "update:modelValue": (_value) => true,
    node: (node) => !!node,
    submit: (_data, _node) => true,
    submitRaw: (_event) => true
  },
  inheritAttrs: false,
  setup(props2, context) {
    const node = useInput(props2, context);
    if (!node.props.definition)
      error(600, node);
    if (node.props.definition.component) {
      return () => {
        var _a;
        return h((_a = node.props.definition) === null || _a === void 0 ? void 0 : _a.component, {
          context: node.context
        }, __spreadValues({}, context.slots));
      };
    }
    const schemaDefinition = node.props.definition.schema;
    if (!schemaDefinition)
      error(601, node);
    const schema = typeof schemaDefinition === "function" ? schemaDefinition(__spreadValues({}, props2.sectionsSchema)) : schemaDefinition;
    context.emit("node", node);
    const library = node.props.definition.library;
    context.expose({ node });
    return () => h(FormKitSchema, { schema, data: node.context, library }, __spreadValues({}, context.slots));
  }
});
function createPlugin(app, options) {
  app.component(options.alias || "FormKit", FormKit).component(options.schemaAlias || "FormKitSchema", FormKitSchema);
  return {
    get: getNode$1,
    setLocale: (locale) => {
      var _a;
      if ((_a = options.config) === null || _a === void 0 ? void 0 : _a.rootConfig) {
        options.config.rootConfig.locale = locale;
      }
    },
    setErrors,
    submit: submitForm,
    reset
  };
}
var optionsSymbol = Symbol.for("FormKitOptions");
var configSymbol = Symbol.for("FormKitConfig");
var plugin = {
  install(app, _options) {
    const options = Object.assign({
      alias: "FormKit",
      schemaAlias: "FormKitSchema"
    }, typeof _options === "function" ? _options() : _options);
    const rootConfig = createConfig$1(options.config || {});
    options.config = { rootConfig };
    app.config.globalProperties.$formkit = createPlugin(app, options);
    app.provide(optionsSymbol, options);
    app.provide(configSymbol, rootConfig);
  }
};
var pseudoProps = [
  "help",
  "label",
  "ignore",
  "disabled",
  "preserve",
  /^[a-z]+(?:-visibility|Visibility)$/,
  /^[a-zA-Z-]+(?:-class|Class)$/
];
function classesToNodeProps(node, props2) {
  if (props2.classes) {
    Object.keys(props2.classes).forEach((key) => {
      node.props[`_${key}Class`] = props2.classes[key];
    });
  }
}
function onlyListeners(props2) {
  if (!props2)
    return {};
  const knownListeners = ["Submit", "SubmitRaw"].reduce((listeners, listener) => {
    const name = `on${listener}`;
    if (name in props2) {
      if (typeof props2[name] === "function") {
        listeners[name] = props2[name];
      }
    }
    return listeners;
  }, {});
  return knownListeners;
}
function useInput(props2, context, options = {}) {
  const config = Object.assign({}, inject(optionsSymbol) || {}, options);
  const parent = props2.parent || inject(parentSymbol, null);
  const instance = getCurrentInstance();
  const listeners = onlyListeners(instance === null || instance === void 0 ? void 0 : instance.vnode.props);
  const value = props2.modelValue !== void 0 ? props2.modelValue : cloneAny(context.attrs.value);
  function createInitialProps() {
    const initialProps2 = __spreadValues(__spreadValues({}, nodeProps(props2)), listeners);
    const attrs = except(nodeProps(context.attrs), pseudoProps);
    initialProps2.attrs = attrs;
    const propValues = only(nodeProps(context.attrs), pseudoProps);
    for (const propName in propValues) {
      initialProps2[camel(propName)] = propValues[propName];
    }
    const classesProps = { props: {} };
    classesToNodeProps(classesProps, props2);
    Object.assign(initialProps2, classesProps.props);
    if (typeof initialProps2.type !== "string") {
      initialProps2.definition = initialProps2.type;
      delete initialProps2.type;
    }
    return initialProps2;
  }
  const initialProps = createInitialProps();
  const node = createNode(extend(config || {}, {
    name: props2.name || void 0,
    value,
    parent: initialProps.ignore ? null : parent,
    plugins: (config.plugins || []).concat(props2.plugins),
    config: props2.config,
    props: initialProps
  }, false, true));
  if (!node.props.definition)
    error(600, node);
  const pseudoPropNames = pseudoProps.concat(node.props.definition.props || []).reduce((names, prop) => {
    if (typeof prop === "string") {
      names.push(camel(prop));
      names.push(kebab(prop));
    } else {
      names.push(prop);
    }
    return names;
  }, []);
  watchEffect(() => classesToNodeProps(node, props2));
  const passThrough = nodeProps(props2);
  for (const prop in passThrough) {
    watch(() => props2[prop], () => {
      if (props2[prop] !== void 0) {
        node.props[prop] = props2[prop];
      }
    });
  }
  const pseudoPropsValues = only(nodeProps(context.attrs), pseudoPropNames);
  for (const prop in pseudoPropsValues) {
    const camelName = camel(prop);
    watch(() => context.attrs[prop], () => {
      node.props[camelName] = context.attrs[prop];
    });
  }
  watchEffect(() => {
    const attrs = except(nodeProps(context.attrs), pseudoPropNames);
    node.props.attrs = Object.assign({}, node.props.attrs || {}, attrs);
  });
  watchEffect(() => {
    const messages = props2.errors.map((error2) => createMessage({
      key: slugify(error2),
      type: "error",
      value: error2,
      meta: { source: "prop" }
    }));
    node.store.apply(messages, (message) => message.type === "error" && message.meta.source === "prop");
  });
  if (node.type !== "input") {
    const sourceKey = `${node.name}-prop`;
    watchEffect(() => {
      const keys = Object.keys(props2.inputErrors);
      const messages = keys.reduce((messages2, key) => {
        let value2 = props2.inputErrors[key];
        if (typeof value2 === "string")
          value2 = [value2];
        if (Array.isArray(value2)) {
          messages2[key] = value2.map((error2) => createMessage({
            key: error2,
            type: "error",
            value: error2,
            meta: { source: sourceKey }
          }));
        }
        return messages2;
      }, {});
      node.store.apply(messages, (message) => message.type === "error" && message.meta.source === sourceKey);
    });
  }
  watchEffect(() => Object.assign(node.config, props2.config));
  if (node.type !== "input") {
    provide(parentSymbol, node);
  }
  watch(() => {
    var _a;
    return (_a = node.context) === null || _a === void 0 ? void 0 : _a.value;
  }, () => {
    var _a, _b;
    context.emit("input", (_a = node.context) === null || _a === void 0 ? void 0 : _a.value);
    context.emit("update:modelValue", (_b = node.context) === null || _b === void 0 ? void 0 : _b.value);
  });
  if (props2.modelValue !== void 0) {
    watch(() => props2.modelValue, (value2) => {
      node.input(value2, false);
    }, {
      deep: true
    });
  }
  onUnmounted(() => node.destroy());
  return node;
}
var totalCreated = 1;
function isComponent2(obj) {
  return typeof obj === "function" && obj.length === 2 || typeof obj === "object" && !Array.isArray(obj) && !("$el" in obj) && !("$cmp" in obj) && !("if" in obj);
}
function createInput(schemaOrComponent, definitionOptions = {}) {
  const definition = __spreadValues({
    type: "input"
  }, definitionOptions);
  let schema = void 0;
  if (isComponent2(schemaOrComponent)) {
    const cmpName = `SchemaComponent${totalCreated++}`;
    schema = () => ({
      $cmp: cmpName,
      props: {
        context: "$node.context"
      }
    });
    definition.library = { [cmpName]: markRaw(schemaOrComponent) };
  } else {
    schema = schemaOrComponent;
  }
  definition.schema = useSchema(schema || "Schema undefined");
  return definition;
}
var vueBindings = function vueBindings2(node) {
  node.ledger.count("blocking", (m) => m.blocking);
  const isValid = ref(!node.ledger.value("blocking"));
  node.ledger.count("errors", (m) => m.type === "error");
  const hasErrors = ref(!!node.ledger.value("errors"));
  const availableMessages = reactive(node.store.reduce((store, message) => {
    if (message.visible) {
      store[message.key] = message;
    }
    return store;
  }, {}));
  const validationVisibility = ref(node.props.validationVisibility || "blur");
  node.on("props:validationVisibility", ({ payload }) => {
    validationVisibility.value = payload;
  });
  const hasShownErrors = ref(validationVisibility.value === "live");
  const validationVisible = computed(() => {
    if (context.state.submitted)
      return true;
    if (!hasShownErrors.value && !context.state.settled) {
      return false;
    }
    switch (validationVisibility.value) {
      case "live":
        return true;
      case "blur":
        return context.state.blurred;
      case "dirty":
        return context.state.dirty;
      default:
        return false;
    }
  });
  const isComplete = computed(() => {
    return hasValidation.value ? isValid.value && !hasErrors.value : context.state.dirty && !empty(context.value);
  });
  const hasValidation = ref(Array.isArray(node.props.parsedRules) && node.props.parsedRules.length > 0);
  node.on("prop:parsedRules", ({ payload: rules }) => {
    hasValidation.value = Array.isArray(rules) && rules.length > 0;
  });
  const messages = computed(() => {
    const visibleMessages = {};
    for (const key in availableMessages) {
      const message = availableMessages[key];
      if (message.type !== "validation" || validationVisible.value) {
        visibleMessages[key] = message;
      }
    }
    return visibleMessages;
  });
  const ui2 = reactive(node.store.reduce((messages2, message) => {
    if (message.type === "ui" && message.visible)
      messages2[message.key] = message;
    return messages2;
  }, {}));
  let inputElement = null;
  const cachedClasses = reactive({});
  const classes = new Proxy(cachedClasses, {
    get(...args) {
      const [target, property] = args;
      let className = Reflect.get(...args);
      if (!className && typeof property === "string") {
        if (!has(target, property) && !property.startsWith("__v")) {
          const observedNode = createObserver(node);
          observedNode.watch((node2) => {
            const rootClasses = typeof node2.config.rootClasses === "function" ? node2.config.rootClasses(property, node2) : {};
            const globalConfigClasses = node2.config.classes ? createClasses(property, node2, node2.config.classes[property]) : {};
            const classesPropClasses = createClasses(property, node2, node2.props[`_${property}Class`]);
            const sectionPropClasses = createClasses(property, node2, node2.props[`${property}Class`]);
            className = generateClassList(node2, property, rootClasses, globalConfigClasses, classesPropClasses, sectionPropClasses);
            target[property] = className;
          });
        }
      }
      return className;
    }
  });
  const describedBy = computed(() => {
    const describers = [];
    if (context.help) {
      describers.push(`help-${node.props.id}`);
    }
    for (const key in messages.value) {
      describers.push(`${node.props.id}-${key}`);
    }
    return describers.length ? describers.join(" ") : void 0;
  });
  const context = reactive({
    _value: node.value,
    attrs: node.props.attrs,
    disabled: node.props.disabled,
    describedBy,
    fns: {
      length: (obj) => Object.keys(obj).length,
      number: (value) => Number(value),
      string: (value) => String(value),
      json: (value) => JSON.stringify(value)
    },
    handlers: {
      blur: () => node.store.set(createMessage({ key: "blurred", visible: false, value: true })),
      touch: () => {
        node.store.set(createMessage({ key: "dirty", visible: false, value: true }));
      },
      DOMInput: (e) => {
        inputElement = e.target;
        node.input(e.target.value);
      }
    },
    help: node.props.help,
    id: node.props.id,
    label: node.props.label,
    messages,
    node,
    options: node.props.options,
    state: {
      blurred: false,
      complete: isComplete,
      dirty: false,
      submitted: false,
      settled: node.isSettled,
      valid: isValid,
      errors: hasErrors,
      rules: hasValidation,
      validationVisible
    },
    type: node.props.type,
    ui: ui2,
    value: node.value,
    classes
  });
  node.on("created", () => {
    if (!eq(context.value, node.value)) {
      context._value = node.value;
      context.value = node.value;
    }
  });
  node.on("settled", ({ payload: isSettled }) => {
    context.state.settled = isSettled;
  });
  function observeProps(observe) {
    observe.forEach((prop) => {
      prop = camel(prop);
      if (!has(context, prop) && has(node.props, prop)) {
        context[prop] = node.props[prop];
      }
      node.on(`prop:${prop}`, ({ payload }) => {
        context[prop] = payload;
      });
    });
  }
  const rootProps = [
    "help",
    "label",
    "disabled",
    "options",
    "type",
    "attrs",
    "id"
  ];
  observeProps(rootProps);
  function definedAs(definition) {
    if (definition.props)
      observeProps(definition.props);
  }
  node.props.definition ? definedAs(node.props.definition) : node.on("defined", ({ payload }) => definedAs(payload));
  node.on("input", ({ payload }) => {
    context._value = payload;
    if (inputElement) {
      inputElement.value = context._value;
    }
  });
  node.on("commit", ({ payload }) => {
    switch (node.type) {
      case "group":
        context.value = __spreadValues({}, payload);
        break;
      case "list":
        context.value = [...payload];
        break;
      default:
        context.value = payload;
    }
    if (!context.state.dirty && node.isCreated)
      context.handlers.touch();
  });
  const updateState = async (message) => {
    if (message.type === "ui" && message.visible && !message.meta.showAsMessage) {
      ui2[message.key] = message;
    } else if (message.visible) {
      availableMessages[message.key] = message;
    } else if (message.type === "state") {
      context.state[message.key] = !!message.value;
    }
  };
  node.on("message-added", (e) => updateState(e.payload));
  node.on("message-updated", (e) => updateState(e.payload));
  node.on("message-removed", ({ payload: message }) => {
    delete ui2[message.key];
    delete availableMessages[message.key];
    delete context.state[message.key];
  });
  node.on("settled:blocking", () => {
    isValid.value = true;
  });
  node.on("unsettled:blocking", () => {
    isValid.value = false;
  });
  node.on("settled:errors", () => {
    hasErrors.value = false;
  });
  node.on("unsettled:errors", () => {
    hasErrors.value = true;
  });
  watch(validationVisible, (value) => {
    if (value) {
      hasShownErrors.value = true;
    }
  });
  node.context = context;
  node.emit("context", node, false);
};
var defaultConfig = (options = {}) => {
  const _a = options, { rules = {}, locales = {}, inputs: inputs$1 = {}, messages = {}, locale = void 0 } = _a, nodeOptions = __objRest(_a, ["rules", "locales", "inputs", "messages", "locale"]);
  const validation2 = createValidationPlugin(__spreadValues(__spreadValues({}, dist_exports), rules || {}));
  const i18n = createI18nPlugin(extend(__spreadValues({ en }, locales || {}), messages));
  const library = createLibraryPlugin(inputs, inputs$1);
  return extend(__spreadValues({
    plugins: [library, vueBindings, i18n, validation2]
  }, !locale ? {} : { config: { locale } }), nodeOptions || {}, true);
};
export {
  FormKit,
  FormKitSchema,
  vueBindings as bindings,
  configSymbol,
  createInput,
  defaultConfig,
  errorHandler,
  optionsSymbol,
  plugin,
  reset,
  resetCount,
  setErrors,
  submitForm,
  useInput
};
//# sourceMappingURL=@formkit_vue.js.map

import {
  __objRest,
  __spreadProps,
  __spreadValues
} from "./chunk-VYIV4F7G.js";

// node_modules/@formkit/utils/dist/index.mjs
function token() {
  return Math.random().toString(36).substring(2, 15);
}
function dedupe(arr1, arr2) {
  const original = arr1 instanceof Set ? arr1 : new Set(arr1);
  if (arr2)
    arr2.forEach((item) => original.add(item));
  return [...original];
}
function has(obj, property) {
  return Object.prototype.hasOwnProperty.call(obj, property);
}
function eq(valA, valB, deep = true) {
  if (valA === valB)
    return true;
  if (typeof valA === typeof valB && typeof valA === "object") {
    if (valA instanceof Map)
      return false;
    if (valA instanceof Set)
      return false;
    if (Object.keys(valA).length !== Object.keys(valB).length)
      return false;
    for (const key in valA) {
      if (!(key in valB))
        return false;
      if (valA[key] !== valB[key] && !deep)
        return false;
      if (deep && !eq(valA[key], valB[key], true))
        return false;
    }
    return true;
  }
  return false;
}
function empty(value) {
  const type = typeof value;
  if (type === "number")
    return false;
  if (value === void 0)
    return true;
  if (type === "string") {
    return value === "";
  }
  if (type === "object") {
    if (value === null)
      return true;
    for (const _i in value)
      return false;
    return true;
  }
  return false;
}
function escapeExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function regexForFormat(format) {
  const escaped = `^${escapeExp(format)}$`;
  const formats = {
    MM: "(0[1-9]|1[012])",
    M: "([1-9]|1[012])",
    DD: "([012][0-9]|3[01])",
    D: "([012]?[0-9]|3[01])",
    YYYY: "\\d{4}",
    YY: "\\d{2}"
  };
  const tokens = Object.keys(formats);
  return new RegExp(tokens.reduce((regex, format2) => {
    return regex.replace(format2, formats[format2]);
  }, escaped));
}
function isObject(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function isPojo(o) {
  if (isObject(o) === false)
    return false;
  if (o.__FKNode__ || o.__POJO__ === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function extend(original, additional, extendArrays = false, ignoreUndefined = false) {
  if (additional === null)
    return null;
  const merged = {};
  if (typeof additional === "string")
    return additional;
  for (const key in original) {
    if (has(additional, key) && (additional[key] !== void 0 || !ignoreUndefined)) {
      if (extendArrays && Array.isArray(original[key]) && Array.isArray(additional[key])) {
        merged[key] = original[key].concat(additional[key]);
        continue;
      }
      if (additional[key] === void 0) {
        continue;
      }
      if (isPojo(original[key]) && isPojo(additional[key])) {
        merged[key] = extend(original[key], additional[key], extendArrays, ignoreUndefined);
      } else {
        merged[key] = additional[key];
      }
    } else {
      merged[key] = original[key];
    }
  }
  for (const key in additional) {
    if (!has(merged, key) && additional[key] !== void 0) {
      merged[key] = additional[key];
    }
  }
  return merged;
}
function isQuotedString(str) {
  if (str[0] !== '"' && str[0] !== "'")
    return false;
  if (str[0] !== str[str.length - 1])
    return false;
  const quoteType = str[0];
  for (let p = 1; p < str.length; p++) {
    if (str[p] === quoteType && (p === 1 || str[p - 1] !== "\\") && p !== str.length - 1) {
      return false;
    }
  }
  return true;
}
function rmEscapes(str) {
  if (!str.length)
    return "";
  let clean = "";
  let lastChar = "";
  for (let p = 0; p < str.length; p++) {
    const char = str.charAt(p);
    if (char !== "\\" || lastChar === "\\") {
      clean += char;
    }
    lastChar = char;
  }
  return clean;
}
function nodeProps(...sets) {
  return sets.reduce((valid, props) => {
    const _a = props, { value, name, modelValue, config, plugins } = _a, validProps = __objRest(_a, ["value", "name", "modelValue", "config", "plugins"]);
    return Object.assign(valid, validProps);
  }, {});
}
function parseArgs(str) {
  const args = [];
  let arg = "";
  let depth = 0;
  let quote = "";
  let lastChar = "";
  for (let p = 0; p < str.length; p++) {
    const char = str.charAt(p);
    if (char === quote && lastChar !== "\\") {
      quote = "";
    } else if ((char === "'" || char === '"') && !quote && lastChar !== "\\") {
      quote = char;
    } else if (char === "(" && !quote) {
      depth++;
    } else if (char === ")" && !quote) {
      depth--;
    }
    if (char === "," && !quote && depth === 0) {
      if (isQuotedString(arg))
        arg = rmEscapes(arg.substr(1, arg.length - 2));
      args.push(arg);
      arg = "";
    } else if (char !== " " || quote) {
      arg += char;
    }
    lastChar = char;
  }
  if (arg) {
    if (isQuotedString(arg))
      arg = rmEscapes(arg.substr(1, arg.length - 2));
    args.push(arg);
  }
  return args;
}
function except(obj, toRemove) {
  const clean = {};
  const exps = toRemove.filter((n) => n instanceof RegExp);
  const keysToRemove = new Set(toRemove);
  for (const key in obj) {
    if (!keysToRemove.has(key) && !exps.some((exp) => exp.test(key))) {
      clean[key] = obj[key];
    }
  }
  return clean;
}
function only(obj, include) {
  const clean = {};
  const exps = include.filter((n) => n instanceof RegExp);
  include.forEach((key) => {
    if (!(key instanceof RegExp)) {
      clean[key] = obj[key];
    }
  });
  Object.keys(obj).forEach((key) => {
    if (exps.some((exp) => exp.test(key))) {
      clean[key] = obj[key];
    }
  });
  return clean;
}
function camel(str) {
  return str.replace(/-([a-z0-9])/gi, (_s, g) => g.toUpperCase());
}
function kebab(str) {
  return str.replace(/([a-z0-9])([A-Z])/g, (_s, trail, cap) => trail + "-" + cap.toLowerCase()).replace(" ", "-").toLowerCase();
}
function clone(obj) {
  if (obj === null || obj instanceof RegExp || obj instanceof Date || typeof File === "function" && obj instanceof File)
    return obj;
  if (Array.isArray(obj)) {
    return obj.map((value) => {
      if (typeof value === "object")
        return clone(value);
      return value;
    });
  }
  return Object.keys(obj).reduce((newObj, key) => {
    newObj[key] = typeof obj[key] === "object" ? clone(obj[key]) : obj[key];
    return newObj;
  }, {});
}
function cloneAny(obj) {
  return typeof obj === "object" ? clone(obj) : obj;
}
function getAt(obj, addr) {
  if (!obj || typeof obj !== "object")
    return null;
  const segments = addr.split(".");
  let o = obj;
  for (const i in segments) {
    const segment = segments[i];
    if (has(o, segment)) {
      o = o[segment];
    }
    if (+i === segments.length - 1)
      return o;
    if (!o || typeof o !== "object")
      return null;
  }
  return null;
}
function undefine(value) {
  return value !== void 0 && value !== "false" && value !== false ? true : void 0;
}
function init(obj) {
  return Object.defineProperty(obj, "__init", {
    enumerable: false,
    value: true
  });
}
function slugify(str) {
  return str.normalize("NFD").replace(/[\u0300-\u036f]/g, "").toLowerCase().replace(/[^a-z0-9]/g, " ").trim().replace(/\s+/g, "-");
}

// node_modules/@formkit/core/dist/index.mjs
function createDispatcher() {
  const middleware = [];
  let currentIndex = 0;
  const use2 = (dispatchable) => middleware.push(dispatchable);
  const dispatch = (payload) => {
    const current = middleware[currentIndex];
    if (typeof current === "function") {
      return current(payload, (explicitPayload) => {
        currentIndex++;
        return dispatch(explicitPayload === void 0 ? payload : explicitPayload);
      });
    }
    currentIndex = 0;
    return payload;
  };
  use2.dispatch = dispatch;
  use2.unshift = (dispatchable) => middleware.unshift(dispatchable);
  use2.remove = (dispatchable) => {
    const index = middleware.indexOf(dispatchable);
    if (index > -1)
      middleware.splice(index, 1);
  };
  return use2;
}
function createEmitter() {
  const listeners = /* @__PURE__ */ new Map();
  const receipts2 = /* @__PURE__ */ new Map();
  let buffer = void 0;
  const emitter = (node, event) => {
    if (buffer) {
      buffer.set(event.name, [node, event]);
      return;
    }
    if (listeners.has(event.name)) {
      listeners.get(event.name).forEach((wrapper2) => {
        if (event.origin === node || wrapper2.modifiers.includes("deep")) {
          wrapper2.listener(event);
        }
      });
    }
    if (event.bubble) {
      node.bubble(event);
    }
  };
  emitter.on = (eventName, listener) => {
    const [event, ...modifiers] = eventName.split(".");
    const receipt = listener.receipt || token();
    const wrapper2 = {
      modifiers,
      event,
      listener,
      receipt
    };
    listeners.has(event) ? listeners.get(event).push(wrapper2) : listeners.set(event, [wrapper2]);
    receipts2.has(receipt) ? receipts2.get(receipt).push(event) : receipts2.set(receipt, [event]);
    return receipt;
  };
  emitter.off = (receipt) => {
    var _a;
    if (receipts2.has(receipt)) {
      (_a = receipts2.get(receipt)) === null || _a === void 0 ? void 0 : _a.forEach((event) => {
        const eventListeners = listeners.get(event);
        if (Array.isArray(eventListeners)) {
          listeners.set(event, eventListeners.filter((wrapper2) => wrapper2.receipt !== receipt));
        }
      });
      receipts2.delete(receipt);
    }
  };
  emitter.pause = (node) => {
    if (!buffer)
      buffer = /* @__PURE__ */ new Map();
    if (node) {
      node.walk((child) => child._e.pause());
    }
  };
  emitter.play = (node) => {
    if (!buffer)
      return;
    const events = buffer;
    buffer = void 0;
    events.forEach(([node2, event]) => emitter(node2, event));
    if (node) {
      node.walk((child) => child._e.play());
    }
  };
  return emitter;
}
function emit$1(node, context, name, payload, bubble2 = true) {
  context._e(node, {
    payload,
    name,
    bubble: bubble2,
    origin: node
  });
  return node;
}
function bubble(node, _context, event) {
  if (isNode(node.parent)) {
    node.parent._e(node.parent, event);
  }
  return node;
}
function on(_node, context, name, listener) {
  return context._e.on(name, listener);
}
function off(node, context, receipt) {
  context._e.off(receipt);
  return node;
}
var errorHandler = createDispatcher();
errorHandler((error2, next) => {
  if (!error2.message)
    error2.message = String(`E${error2.code}`);
  return next(error2);
});
var warningHandler = createDispatcher();
warningHandler((warning, next) => {
  if (!warning.message)
    warning.message = String(`W${warning.code}`);
  const result = next(warning);
  if (console && typeof console.warn === "function")
    console.warn(result.message);
  return result;
});
function warn(code, data = {}) {
  warningHandler.dispatch({ code, data });
}
function error(code, data = {}) {
  throw Error(errorHandler.dispatch({ code, data }).message);
}
function createMessage(conf, node) {
  const m = __spreadValues({
    blocking: false,
    key: token(),
    meta: {},
    type: "state",
    visible: true
  }, conf);
  if (node && m.value && m.meta.localize !== false) {
    m.value = node.t(m);
    m.meta.locale = node.config.locale;
  }
  return m;
}
var storeTraps = {
  apply: applyMessages,
  set: setMessage,
  remove: removeMessage,
  filter: filterMessages,
  reduce: reduceMessages,
  release: releaseBuffer,
  touch: touchMessages
};
function createStore(_buffer = false) {
  const messages2 = {};
  let node;
  let buffer = _buffer;
  let _b = [];
  const _m = /* @__PURE__ */ new Map();
  let _r = void 0;
  const store = new Proxy(messages2, {
    get(...args) {
      const [_target, property] = args;
      if (property === "buffer")
        return buffer;
      if (property === "_b")
        return _b;
      if (property === "_m")
        return _m;
      if (property === "_r")
        return _r;
      if (has(storeTraps, property)) {
        return storeTraps[property].bind(null, messages2, store, node);
      }
      return Reflect.get(...args);
    },
    set(_t, prop, value) {
      if (prop === "_n") {
        node = value;
        if (_r === "__n")
          releaseMissed(node, store);
        return true;
      } else if (prop === "_b") {
        _b = value;
        return true;
      } else if (prop === "buffer") {
        buffer = value;
        return true;
      } else if (prop === "_r") {
        _r = value;
        return true;
      }
      error(101, node);
      return false;
    }
  });
  return store;
}
function setMessage(messageStore, store, node, message2) {
  if (store.buffer) {
    store._b.push([[message2]]);
    return store;
  }
  if (messageStore[message2.key] !== message2) {
    if (typeof message2.value === "string" && message2.meta.localize !== false) {
      const previous = message2.value;
      message2.value = node.t(message2);
      if (message2.value !== previous) {
        message2.meta.locale = node.props.locale;
      }
    }
    const e = `message-${has(messageStore, message2.key) ? "updated" : "added"}`;
    messageStore[message2.key] = Object.freeze(message2);
    node.emit(e, message2);
  }
  return store;
}
function touchMessages(messageStore, store) {
  for (const key in messageStore) {
    const message2 = __spreadValues({}, messageStore[key]);
    store.set(message2);
  }
}
function removeMessage(messageStore, store, node, key) {
  if (has(messageStore, key)) {
    const message2 = messageStore[key];
    delete messageStore[key];
    node.emit("message-removed", message2);
  }
  if (store.buffer === true) {
    store._b = store._b.filter((buffered) => {
      buffered[0] = buffered[0].filter((m) => m.key !== key);
      return buffered[1] || buffered[0].length;
    });
  }
  return store;
}
function filterMessages(messageStore, store, node, callback, type) {
  for (const key in messageStore) {
    const message2 = messageStore[key];
    if ((!type || message2.type === type) && !callback(message2)) {
      removeMessage(messageStore, store, node, key);
    }
  }
}
function reduceMessages(messageStore, _store, _node, reducer, accumulator) {
  for (const key in messageStore) {
    const message2 = messageStore[key];
    accumulator = reducer(accumulator, message2);
  }
  return accumulator;
}
function applyMessages(_messageStore, store, node, messages2, clear) {
  if (Array.isArray(messages2)) {
    if (store.buffer) {
      store._b.push([messages2, clear]);
      return;
    }
    const applied = new Set(messages2.map((message2) => {
      store.set(message2);
      return message2.key;
    }));
    if (typeof clear === "string") {
      store.filter((message2) => message2.type !== clear || applied.has(message2.key));
    } else if (typeof clear === "function") {
      store.filter((message2) => !clear(message2) || applied.has(message2.key));
    }
  } else {
    for (const address in messages2) {
      const child = node.at(address);
      if (child) {
        child.store.apply(messages2[address], clear);
      } else {
        missed(node, store, address, messages2[address], clear);
      }
    }
  }
}
function createMessages(node, ...errors2) {
  const sourceKey = `${node.name}-set`;
  const make = (error2) => createMessage({
    key: slugify(error2),
    type: "error",
    value: error2,
    meta: { source: sourceKey }
  });
  return errors2.filter((m) => !!m).map((errorSet) => {
    if (typeof errorSet === "string")
      errorSet = [errorSet];
    if (Array.isArray(errorSet)) {
      return errorSet.map((error2) => make(error2));
    } else {
      const errors3 = {};
      for (const key in errorSet) {
        if (Array.isArray(errorSet[key])) {
          errors3[key] = errorSet[key].map((error2) => make(error2));
        } else {
          errors3[key] = [make(errorSet[key])];
        }
      }
      return errors3;
    }
  });
}
function missed(node, store, address, messages2, clear) {
  var _a;
  const misses = store._m;
  if (!misses.has(address))
    misses.set(address, []);
  if (!store._r)
    store._r = releaseMissed(node, store);
  (_a = misses.get(address)) === null || _a === void 0 ? void 0 : _a.push([messages2, clear]);
}
function releaseMissed(node, store) {
  return node.on("child.deep", ({ payload: child }) => {
    store._m.forEach((misses, address) => {
      if (node.at(address) === child) {
        misses.forEach(([messages2, clear]) => {
          child.store.apply(messages2, clear);
        });
        store._m.delete(address);
      }
    });
    if (store._m.size === 0 && store._r) {
      node.off(store._r);
      store._r = void 0;
    }
  });
}
function releaseBuffer(_messageStore, store) {
  store.buffer = false;
  store._b.forEach(([messages2, clear]) => store.apply(messages2, clear));
  store._b = [];
}
function createLedger() {
  const ledger = {};
  let n;
  return {
    count: (...args) => createCounter(n, ledger, ...args),
    init(node) {
      n = node;
      node.on("message-added.deep", add(ledger, 1));
      node.on("message-removed.deep", add(ledger, -1));
    },
    merge: (child) => merge(n, ledger, child),
    settled(counterName) {
      return has(ledger, counterName) ? ledger[counterName].promise : Promise.resolve();
    },
    unmerge: (child) => merge(n, ledger, child, true),
    value(counterName) {
      return has(ledger, counterName) ? ledger[counterName].count : 0;
    }
  };
}
function createCounter(node, ledger, counterName, condition, increment = 0) {
  condition = parseCondition(condition || counterName);
  if (!has(ledger, counterName)) {
    const counter = {
      condition,
      count: 0,
      name: counterName,
      node,
      promise: Promise.resolve(),
      resolve: () => {
      }
    };
    ledger[counterName] = counter;
    increment = node.store.reduce((sum, m) => sum + counter.condition(m) * 1, increment);
    node.each((child) => {
      child.ledger.count(counter.name, counter.condition);
      increment += child.ledger.value(counter.name);
    });
  }
  return count(ledger[counterName], increment).promise;
}
function parseCondition(condition) {
  if (typeof condition === "function") {
    return condition;
  }
  return (m) => m.type === condition;
}
function count(counter, increment) {
  const initial = counter.count;
  const post = counter.count + increment;
  counter.count = post;
  if (initial === 0 && post !== 0) {
    counter.node.emit(`unsettled:${counter.name}`, counter.count, false);
    counter.promise = new Promise((r) => counter.resolve = r);
  } else if (initial !== 0 && post === 0) {
    counter.node.emit(`settled:${counter.name}`, counter.count, false);
    counter.resolve();
  }
  counter.node.emit(`count:${counter.name}`, counter.count, false);
  return counter;
}
function add(ledger, delta) {
  return (e) => {
    for (const name in ledger) {
      const counter = ledger[name];
      if (counter.condition(e.payload)) {
        count(counter, delta);
      }
    }
  };
}
function merge(parent, ledger, child, remove = false) {
  for (const key in ledger) {
    const condition = ledger[key].condition;
    if (!remove)
      child.ledger.count(key, condition);
    const increment = child.ledger.value(key) * (remove ? -1 : 1);
    if (!parent)
      continue;
    do {
      parent.ledger.count(key, condition, increment);
      parent = parent.parent;
    } while (parent);
  }
}
var registry = /* @__PURE__ */ new Map();
var reflected = /* @__PURE__ */ new Map();
var emit = createEmitter();
var receipts = [];
function register(node) {
  if (node.props.id) {
    registry.set(node.props.id, node);
    reflected.set(node, node.props.id);
    emit(node, {
      payload: node,
      name: node.props.id,
      bubble: false,
      origin: node
    });
  }
}
function deregister(node) {
  if (reflected.has(node)) {
    const id = reflected.get(node);
    reflected.delete(node);
    registry.delete(id);
    emit(node, {
      payload: null,
      name: id,
      bubble: false,
      origin: node
    });
  }
}
function getNode$1(id) {
  return registry.get(id);
}
function watchRegistry(id, callback) {
  receipts.push(emit.on(id, callback));
}
function configChange(node, prop, value) {
  let usingFallback = true;
  !(prop in node.config._t) ? node.emit(`config:${prop}`, value, false) : usingFallback = false;
  if (!(prop in node.props)) {
    node.emit("prop", { prop, value });
    node.emit(`prop:${prop}`, value);
  }
  return usingFallback;
}
function createConfig$1(options = {}) {
  const nodes = /* @__PURE__ */ new Set();
  const target = __spreadValues(__spreadValues({}, options), {
    _add: (node) => nodes.add(node),
    _rm: (node) => node.remove(node)
  });
  const rootConfig = new Proxy(target, {
    set(t, prop, value, r) {
      if (typeof prop === "string") {
        nodes.forEach((node) => configChange(node, prop, value));
      }
      return Reflect.set(t, prop, value, r);
    }
  });
  return rootConfig;
}
function submitForm(id) {
  const formElement = document.getElementById(id);
  if (formElement instanceof HTMLFormElement) {
    const event = new Event("submit", { cancelable: true, bubbles: true });
    formElement.dispatchEvent(event);
    return;
  }
  warn(151, id);
}
function clearState(node) {
  const clear = (n) => {
    for (const key in n.store) {
      const message2 = n.store[key];
      if (message2.type === "error" || message2.type === "ui" && key === "incomplete") {
        n.store.remove(key);
      } else if (message2.type === "state") {
        n.store.set(__spreadProps(__spreadValues({}, message2), { value: false }));
      }
    }
  };
  clear(node);
  node.walk(clear);
}
function reset(id, resetTo) {
  const node = typeof id === "string" ? getNode$1(id) : id;
  if (node) {
    const initial = (n) => cloneAny(n.props.initial) || (n.type === "group" ? {} : n.type === "list" ? [] : void 0);
    node._e.pause(node);
    node.input(cloneAny(resetTo) || initial(node), false);
    node.walk((child) => child.input(initial(child), false));
    const finalInit = initial(node);
    node.input(typeof finalInit === "object" ? cloneAny(resetTo) || init(finalInit) : finalInit, false);
    node._e.play(node);
    clearState(node);
    return node;
  }
  warn(152, id);
  return;
}
var defaultConfig = {
  delimiter: ".",
  delay: 0,
  locale: "en",
  rootClasses: (key) => ({ [`formkit-${kebab(key)}`]: true })
};
var useIndex = Symbol("index");
var valueRemoved = Symbol("removed");
var valueMoved = Symbol("moved");
function isList(arg) {
  return arg.type === "list" && Array.isArray(arg._value);
}
function isNode(node) {
  return node && typeof node === "object" && node.__FKNode__ === true;
}
var invalidSetter = (node, _context, property) => {
  error(102, [node, property]);
};
var traps = {
  _c: trap(getContext, invalidSetter, false),
  add: trap(addChild),
  address: trap(getAddress, invalidSetter, false),
  at: trap(getNode),
  bubble: trap(bubble),
  calm: trap(calm),
  config: trap(false),
  define: trap(define),
  disturb: trap(disturb),
  destroy: trap(destroy),
  hydrate: trap(hydrate),
  index: trap(getIndex, setIndex, false),
  input: trap(input),
  each: trap(eachChild),
  emit: trap(emit$1),
  find: trap(find),
  on: trap(on),
  off: trap(off),
  parent: trap(false, setParent),
  plugins: trap(false),
  remove: trap(removeChild),
  root: trap(getRoot, invalidSetter, false),
  reset: trap(resetValue),
  resetConfig: trap(resetConfig),
  setErrors: trap(errors),
  submit: trap(submit),
  t: trap(text),
  use: trap(use),
  name: trap(getName, false, false),
  walk: trap(walkTree)
};
function createTraps() {
  return new Map(Object.entries(traps));
}
function trap(getter, setter, curryGetter = true) {
  return {
    get: getter ? (node, context) => curryGetter ? (...args) => getter(node, context, ...args) : getter(node, context) : false,
    set: setter !== void 0 ? setter : invalidSetter.bind(null)
  };
}
function createHooks() {
  const hooks = /* @__PURE__ */ new Map();
  return new Proxy(hooks, {
    get(_, property) {
      if (!hooks.has(property)) {
        hooks.set(property, createDispatcher());
      }
      return hooks.get(property);
    }
  });
}
var nameCount = 0;
var idCount = 0;
function resetCount() {
  nameCount = 0;
  idCount = 0;
}
function createName(options) {
  var _a, _b;
  if (((_a = options.parent) === null || _a === void 0 ? void 0 : _a.type) === "list")
    return useIndex;
  return options.name || `${((_b = options.props) === null || _b === void 0 ? void 0 : _b.type) || "input"}_${++nameCount}`;
}
function createValue(options) {
  if (options.type === "group") {
    return init(options.value && typeof options.value === "object" && !Array.isArray(options.value) ? options.value : {});
  } else if (options.type === "list") {
    return init(Array.isArray(options.value) ? options.value : []);
  }
  return options.value === null ? "" : options.value;
}
function input(node, context, value, async = true, eqBefore = true) {
  if (eqBefore && eq(context._value, value))
    return context.settled;
  context._value = validateInput(node, node.hook.input.dispatch(value));
  if (!eqBefore && eq(context._value, value))
    return context.settled;
  node.emit("input", context._value);
  if (context.isSettled)
    node.disturb();
  if (async) {
    if (context._tmo)
      clearTimeout(context._tmo);
    context._tmo = setTimeout(commit, node.props.delay, node, context);
  } else {
    commit(node, context);
  }
  return context.settled;
}
function validateInput(node, value) {
  switch (node.type) {
    case "input":
      break;
    case "group":
      if (!value || typeof value !== "object")
        error(107, [node, value]);
      break;
    case "list":
      if (!Array.isArray(value))
        error(108, [node, value]);
      break;
  }
  return value;
}
function commit(node, context, calm2 = true, hydrate2 = true) {
  if (node.type !== "input" && hydrate2)
    node.hydrate();
  context.value = node.hook.commit.dispatch(context._value);
  node.emit("commit", context.value);
  if (calm2)
    node.calm();
}
function partial(context, { name, value, from }) {
  if (isList(context)) {
    const insert = value === valueRemoved ? [] : value === valueMoved ? context._value.splice(from, 1) : [value];
    context._value.splice(name, value === valueMoved ? 0 : 1, ...insert);
    return;
  }
  if (value !== valueRemoved) {
    context._value[name] = value;
  } else {
    delete context._value[name];
  }
}
function hydrate(node, context) {
  const _value = context._value;
  context.children.forEach((child) => {
    if (typeof _value !== "object")
      return;
    if (child.name in _value) {
      const childValue = child.type !== "input" || typeof _value[child.name] === "object" ? init(_value[child.name]) : _value[child.name];
      child.input(childValue, false);
    } else {
      if (node.type !== "list" || typeof child.name === "number") {
        partial(context, { name: child.name, value: child.value });
      }
      if (!_value.__init) {
        if (child.type === "group")
          child.input({}, false);
        else if (child.type === "list")
          child.input([], false);
        else
          child.input(void 0, false);
      }
    }
  });
  return node;
}
function disturb(node, context) {
  var _a;
  if (context._d <= 0) {
    context.isSettled = false;
    node.emit("settled", false, false);
    context.settled = new Promise((resolve) => {
      context._resolve = resolve;
    });
    if (node.parent)
      (_a = node.parent) === null || _a === void 0 ? void 0 : _a.disturb();
  }
  context._d++;
  return node;
}
function calm(node, context, value) {
  var _a;
  if (value !== void 0 && node.type !== "input") {
    partial(context, value);
    return commit(node, context, true, false);
  }
  if (context._d > 0)
    context._d--;
  if (context._d === 0) {
    context.isSettled = true;
    node.emit("settled", true, false);
    if (node.parent)
      (_a = node.parent) === null || _a === void 0 ? void 0 : _a.calm({ name: node.name, value: context.value });
    if (context._resolve)
      context._resolve(context.value);
  }
}
function destroy(node) {
  node.emit("destroying", node);
  node.store.filter(() => false);
  if (node.parent) {
    node.parent.remove(node);
  }
  deregister(node);
  node.emit("destroyed", node);
}
function define(node, context, definition) {
  context.type = definition.type;
  context.props.definition = definition;
  context.value = context._value = createValue({
    type: node.type,
    value: context.value
  });
  if (definition.features) {
    definition.features.forEach((feature) => feature(node));
  }
  if (definition.props) {
    if (node.props.attrs) {
      const attrs = __spreadValues({}, node.props.attrs);
      node.props._emit = false;
      for (const attr in attrs) {
        const camelName = camel(attr);
        if (definition.props.includes(camelName)) {
          node.props[camelName] = attrs[attr];
          delete attrs[attr];
        }
      }
      const initial = cloneAny(context._value);
      node.props.initial = node.type !== "input" ? init(initial) : initial;
      node.props._emit = true;
      node.props.attrs = attrs;
    }
  }
  node.emit("defined", definition);
}
function addChild(parent, parentContext, child) {
  if (parent.type === "input")
    error(100, parent);
  if (child.parent && child.parent !== parent) {
    child.parent.remove(child);
  }
  if (!parentContext.children.includes(child)) {
    parentContext.children.push(child);
    if (!child.isSettled)
      parent.disturb();
  }
  if (child.parent !== parent) {
    child.parent = parent;
    if (child.parent !== parent) {
      parent.remove(child);
      child.parent.add(child);
      return parent;
    }
  } else {
    child.use(parent.plugins);
  }
  commit(parent, parentContext, false);
  parent.ledger.merge(child);
  parent.emit("child", child);
  return parent;
}
function setParent(child, context, _property, parent) {
  if (isNode(parent)) {
    if (child.parent && child.parent !== parent) {
      child.parent.remove(child);
    }
    context.parent = parent;
    child.resetConfig();
    !parent.children.includes(child) ? parent.add(child) : child.use(parent.plugins);
    return true;
  }
  if (parent === null) {
    context.parent = null;
    return true;
  }
  return false;
}
function removeChild(node, context, child) {
  const childIndex = context.children.indexOf(child);
  if (childIndex !== -1) {
    if (child.isSettled)
      node.disturb();
    context.children.splice(childIndex, 1);
    let preserve = undefine(child.props.preserve);
    let parent = child.parent;
    while (preserve === void 0 && parent) {
      preserve = undefine(parent.props.preserve);
      parent = parent.parent;
    }
    if (!preserve) {
      node.calm({
        name: node.type === "list" ? childIndex : child.name,
        value: valueRemoved
      });
    }
    child.parent = null;
    child.config._rmn = child;
  }
  node.ledger.unmerge(child);
  return node;
}
function eachChild(_node, context, callback) {
  context.children.forEach((child) => callback(child));
}
function walkTree(_node, context, callback, stopIfFalse = false) {
  context.children.forEach((child) => {
    if (callback(child) !== false || !stopIfFalse) {
      child.walk(callback);
    }
  });
}
function resetConfig(node, context) {
  const parent = node.parent || void 0;
  context.config = createConfig(node.config._t, parent);
  node.walk((n) => n.resetConfig());
}
function use(node, context, plugin, run = true, library = true) {
  if (Array.isArray(plugin) || plugin instanceof Set) {
    plugin.forEach((p) => use(node, context, p));
    return node;
  }
  if (!context.plugins.has(plugin)) {
    if (library && typeof plugin.library === "function")
      plugin.library(node);
    if (run && plugin(node) !== false) {
      context.plugins.add(plugin);
      node.children.forEach((child) => child.use(plugin));
    }
  }
  return node;
}
function setIndex(node, _context, _property, setIndex2) {
  if (isNode(node.parent)) {
    const children = node.parent.children;
    const index = setIndex2 >= children.length ? children.length - 1 : setIndex2 < 0 ? 0 : setIndex2;
    const oldIndex = children.indexOf(node);
    if (oldIndex === -1)
      return false;
    children.splice(oldIndex, 1);
    children.splice(index, 0, node);
    node.parent.children = children;
    if (node.parent.type === "list")
      node.parent.disturb().calm({ name: index, value: valueMoved, from: oldIndex });
    return true;
  }
  return false;
}
function getIndex(node) {
  if (node.parent) {
    const index = [...node.parent.children].indexOf(node);
    return index === -1 ? node.parent.children.length : index;
  }
  return -1;
}
function getContext(_node, context) {
  return context;
}
function getName(node, context) {
  var _a;
  if (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === "list")
    return node.index;
  return context.name !== useIndex ? context.name : node.index;
}
function getAddress(node, context) {
  return context.parent ? context.parent.address.concat([node.name]) : [node.name];
}
function getNode(node, _context, locator) {
  const address = typeof locator === "string" ? locator.split(node.config.delimiter) : locator;
  if (!address.length)
    return void 0;
  const first = address[0];
  let pointer = node.parent;
  if (!pointer) {
    if (String(address[0]) === String(node.name))
      address.shift();
    pointer = node;
  }
  if (first === "$parent")
    address.shift();
  while (pointer && address.length) {
    const name = address.shift();
    switch (name) {
      case "$root":
        pointer = node.root;
        break;
      case "$parent":
        pointer = pointer.parent;
        break;
      case "$self":
        pointer = node;
        break;
      default:
        pointer = pointer.children.find((c) => String(c.name) === String(name)) || select(pointer, name);
    }
  }
  return pointer || void 0;
}
function select(node, selector) {
  const matches = String(selector).match(/^(find)\((.*)\)$/);
  if (matches) {
    const [, action, argStr] = matches;
    const args = argStr.split(",").map((arg) => arg.trim());
    switch (action) {
      case "find":
        return node.find(args[0], args[1]);
      default:
        return void 0;
    }
  }
  return void 0;
}
function find(node, _context, searchTerm, searcher) {
  return bfs(node, searchTerm, searcher);
}
function bfs(tree, searchValue, searchGoal = "name") {
  const search2 = typeof searchGoal === "string" ? (n) => n[searchGoal] == searchValue : searchGoal;
  const stack = [tree];
  while (stack.length) {
    const node = stack.shift();
    if (search2(node, searchValue))
      return node;
    stack.push(...node.children);
  }
  return void 0;
}
function getRoot(n) {
  let node = n;
  while (node.parent) {
    node = node.parent;
  }
  return node;
}
function createConfig(target = {}, parent) {
  let node = void 0;
  return new Proxy(target, {
    get(...args) {
      const prop = args[1];
      if (prop === "_t")
        return target;
      const localValue = Reflect.get(...args);
      if (localValue !== void 0)
        return localValue;
      if (parent) {
        const parentVal = parent.config[prop];
        if (parentVal !== void 0)
          return parentVal;
      }
      if (target.rootConfig && typeof prop === "string") {
        const rootValue = target.rootConfig[prop];
        if (rootValue !== void 0)
          return rootValue;
      }
      if (prop === "delay" && (node === null || node === void 0 ? void 0 : node.type) === "input")
        return 20;
      return defaultConfig[prop];
    },
    set(...args) {
      const prop = args[1];
      const value = args[2];
      if (prop === "_n") {
        node = value;
        if (target.rootConfig)
          target.rootConfig._add(node);
        return true;
      }
      if (prop === "_rmn") {
        if (target.rootConfig)
          target.rootConfig._rm(node);
        node = void 0;
        return true;
      }
      if (!eq(target[prop], value, false)) {
        const didSet = Reflect.set(...args);
        if (node) {
          node.emit(`config:${prop}`, value, false);
          configChange(node, prop, value);
          node.walk((n) => configChange(n, prop, value), true);
        }
        return didSet;
      }
      return true;
    }
  });
}
function text(node, _context, key, type = "ui") {
  const fragment2 = typeof key === "string" ? { key, value: key, type } : key;
  const value = node.hook.text.dispatch(fragment2);
  node.emit("text", value, false);
  return value.value;
}
function submit(node) {
  const name = node.name;
  do {
    if (node.props.isForm === true)
      break;
    if (!node.parent)
      error(106, name);
    node = node.parent;
  } while (node);
  if (node.props.id) {
    submitForm(node.props.id);
  }
}
function resetValue(node, _context, value) {
  return reset(node, value);
}
function errors(node, _context, localErrors, childErrors) {
  const sourceKey = `${node.name}-set`;
  createMessages(node, localErrors, childErrors).forEach((errors2) => {
    node.store.apply(errors2, (message2) => message2.meta.source === sourceKey);
  });
}
function defaultProps(node) {
  if (!has(node.props, "id"))
    node.props.id = `input_${idCount++}`;
  return node;
}
function createProps(initial) {
  const props = {
    initial: typeof initial === "object" ? cloneAny(initial) : initial
  };
  let node;
  let isEmitting = true;
  return new Proxy(props, {
    get(...args) {
      const [_t, prop] = args;
      if (has(props, prop))
        return Reflect.get(...args);
      if (node && typeof prop === "string" && node.config[prop] !== void 0)
        return node.config[prop];
      return void 0;
    },
    set(target, property, originalValue, receiver) {
      if (property === "_n") {
        node = originalValue;
        return true;
      }
      if (property === "_emit") {
        isEmitting = originalValue;
        return true;
      }
      const { prop, value } = node.hook.prop.dispatch({
        prop: property,
        value: originalValue
      });
      if (!eq(props[prop], value, false)) {
        const didSet = Reflect.set(target, prop, value, receiver);
        if (isEmitting) {
          node.emit("prop", { prop, value });
          if (typeof prop === "string")
            node.emit(`prop:${prop}`, value);
        }
        return didSet;
      }
      return true;
    }
  });
}
function findDefinition(node, plugins) {
  if (node.props.definition)
    return node.define(node.props.definition);
  for (const plugin of plugins) {
    if (node.props.definition)
      return;
    if (typeof plugin.library === "function") {
      plugin.library(node);
    }
  }
}
function createContext(options) {
  const value = createValue(options);
  const config = createConfig(options.config || {}, options.parent);
  return {
    _d: 0,
    _e: createEmitter(),
    _resolve: false,
    _tmo: false,
    _value: value,
    children: dedupe(options.children || []),
    config,
    hook: createHooks(),
    isCreated: false,
    isSettled: true,
    ledger: createLedger(),
    name: createName(options),
    parent: options.parent || null,
    plugins: /* @__PURE__ */ new Set(),
    props: createProps(value),
    settled: Promise.resolve(value),
    store: createStore(true),
    traps: createTraps(),
    type: options.type || "input",
    value
  };
}
function nodeInit(node, options) {
  var _a;
  node.ledger.init(node.store._n = node.props._n = node.config._n = node);
  node.props._emit = false;
  if (options.props)
    Object.assign(node.props, options.props);
  node.props._emit = true;
  findDefinition(node, /* @__PURE__ */ new Set([
    ...options.plugins || [],
    ...node.parent ? node.parent.plugins : []
  ]));
  if (options.plugins) {
    for (const plugin of options.plugins) {
      use(node, node._c, plugin, true, false);
    }
  }
  defaultProps(node);
  node.each((child) => node.add(child));
  if (node.parent)
    node.parent.add(node);
  if (node.type === "input" && node.children.length)
    error(100, node);
  input(node, node._c, node._value, false, false);
  node.store.release();
  if ((_a = options.props) === null || _a === void 0 ? void 0 : _a.id)
    register(node);
  node.emit("created", node);
  node.isCreated = true;
  return node;
}
function createNode(options) {
  const ops = options || {};
  const context = createContext(ops);
  const node = new Proxy(context, {
    get(...args) {
      const [, property] = args;
      if (property === "__FKNode__")
        return true;
      const trap2 = context.traps.get(property);
      if (trap2 && trap2.get)
        return trap2.get(node, context);
      return Reflect.get(...args);
    },
    set(...args) {
      const [, property, value] = args;
      const trap2 = context.traps.get(property);
      if (trap2 && trap2.set)
        return trap2.set(node, context, property, value);
      return Reflect.set(...args);
    }
  });
  return nodeInit(node, ops);
}
function isDOM(node) {
  return typeof node !== "string" && has(node, "$el");
}
function isComponent(node) {
  return typeof node !== "string" && has(node, "$cmp");
}
function isConditional(node) {
  if (!node || typeof node === "string")
    return false;
  return has(node, "if") && has(node, "then");
}
function isSugar(node) {
  return typeof node !== "string" && "$formkit" in node;
}
function sugar(node) {
  if (typeof node === "string") {
    return {
      $el: "text",
      children: node
    };
  }
  if (isSugar(node)) {
    const _a = node, { $formkit: type, for: iterator, if: condition, children, key, bind } = _a, props = __objRest(_a, ["$formkit", "for", "if", "children", "key", "bind"]);
    return Object.assign({
      $cmp: "FormKit",
      props: __spreadProps(__spreadValues({}, props), { type })
    }, condition ? { if: condition } : {}, iterator ? { for: iterator } : {}, children ? { children } : {}, key ? { key } : {}, bind ? { bind } : {});
  }
  return node;
}
function compile(expr) {
  let provideTokens;
  const requirements = /* @__PURE__ */ new Set();
  const x = function expand(operand, tokens) {
    return typeof operand === "function" ? operand(tokens) : operand;
  };
  const operatorRegistry = [
    {
      "&&": (l, r, t) => x(l, t) && x(r, t),
      "||": (l, r, t) => x(l, t) || x(r, t)
    },
    {
      "===": (l, r, t) => !!(x(l, t) === x(r, t)),
      "!==": (l, r, t) => !!(x(l, t) !== x(r, t)),
      "==": (l, r, t) => !!(x(l, t) == x(r, t)),
      "!=": (l, r, t) => !!(x(l, t) != x(r, t)),
      ">=": (l, r, t) => !!(x(l, t) >= x(r, t)),
      "<=": (l, r, t) => !!(x(l, t) <= x(r, t)),
      ">": (l, r, t) => !!(x(l, t) > x(r, t)),
      "<": (l, r, t) => !!(x(l, t) < x(r, t))
    },
    {
      "+": (l, r, t) => x(l, t) + x(r, t),
      "-": (l, r, t) => x(l, t) - x(r, t)
    },
    {
      "*": (l, r, t) => x(l, t) * x(r, t),
      "/": (l, r, t) => x(l, t) / x(r, t),
      "%": (l, r, t) => x(l, t) % x(r, t)
    }
  ];
  const operatorSymbols = operatorRegistry.reduce((s, g) => {
    return s.concat(Object.keys(g));
  }, []);
  const operatorChars = new Set(operatorSymbols.map((key) => key.charAt(0)));
  function getOp(symbols, char, p, expression) {
    const candidates = symbols.filter((s) => s.startsWith(char));
    if (!candidates.length)
      return false;
    return candidates.find((symbol) => {
      if (expression.length >= p + symbol.length) {
        const nextChars = expression.substr(p, symbol.length);
        if (nextChars === symbol)
          return symbol;
      }
      return false;
    });
  }
  function getStep(p, expression, direction = 1) {
    let next = direction ? expression.substr(p + 1).trim() : expression.substr(0, p).trim();
    if (!next.length)
      return -1;
    if (!direction) {
      const reversed = next.split("").reverse();
      const start = reversed.findIndex((char2) => operatorChars.has(char2));
      next = reversed.slice(start).join("");
    }
    const char = next[0];
    return operatorRegistry.findIndex((operators) => {
      const symbols = Object.keys(operators);
      return !!getOp(symbols, char, 0, next);
    });
  }
  function getTail(pos, expression) {
    let tail = "";
    const length = expression.length;
    let depth = 0;
    for (let p = pos; p < length; p++) {
      const char = expression.charAt(p);
      if (char === "(") {
        depth++;
      } else if (char === ")") {
        depth--;
      } else if (depth === 0 && char === " ") {
        continue;
      }
      if (depth === 0 && getOp(operatorSymbols, char, p, expression)) {
        return [tail, p - 1];
      } else {
        tail += char;
      }
    }
    return [tail, expression.length - 1];
  }
  function parseLogicals(expression, step = 0) {
    const operators = operatorRegistry[step];
    const length = expression.length;
    const symbols = Object.keys(operators);
    let depth = 0;
    let quote = false;
    let op = null;
    let operand = "";
    let left = null;
    let operation;
    let lastChar = "";
    let char = "";
    let parenthetical = "";
    let startP = 0;
    const addTo = (depth2, char2) => {
      depth2 ? parenthetical += char2 : operand += char2;
    };
    for (let p = 0; p < length; p++) {
      lastChar = char;
      char = expression.charAt(p);
      if (!quote && (char === "'" || char === '"') && lastChar !== "\\" && depth === 0) {
        quote = char;
        addTo(depth, char);
        continue;
      } else if (quote && (char !== quote || lastChar === "\\")) {
        addTo(depth, char);
        continue;
      } else if (quote === char) {
        quote = false;
        addTo(depth, char);
        continue;
      } else if (char === " ") {
        continue;
      } else if (char === "(") {
        if (depth === 0) {
          startP = p;
        } else {
          parenthetical += char;
        }
        depth++;
      } else if (char === ")") {
        depth--;
        if (depth === 0) {
          const fn = typeof operand === "string" && operand.startsWith("$") ? operand : void 0;
          const hasTail = fn && expression.charAt(p + 1) === ".";
          let tail = "";
          if (hasTail) {
            [tail, p] = getTail(p + 2, expression);
          }
          const lStep = op ? step : getStep(startP, expression, 0);
          const rStep = getStep(p, expression);
          if (lStep === -1 && rStep === -1) {
            operand = evaluate(parenthetical, -1, fn, tail);
          } else if (op && (lStep >= rStep || rStep === -1) && step === lStep) {
            left = op.bind(null, evaluate(parenthetical, -1, fn, tail));
            op = null;
            operand = "";
          } else if (rStep > lStep && step === rStep) {
            operand = evaluate(parenthetical, -1, fn, tail);
          } else {
            operand += `(${parenthetical})${hasTail ? `.${tail}` : ""}`;
          }
          parenthetical = "";
        } else {
          parenthetical += char;
        }
      } else if (depth === 0 && (operation = getOp(symbols, char, p, expression))) {
        if (p === 0) {
          error(103, [operation, expression]);
        }
        p += operation.length - 1;
        if (p === expression.length - 1) {
          error(104, [operation, expression]);
        }
        if (!op) {
          if (left) {
            op = operators[operation].bind(null, evaluate(left, step));
            left = null;
          } else {
            op = operators[operation].bind(null, evaluate(operand, step));
            operand = "";
          }
        } else if (operand) {
          left = op.bind(null, evaluate(operand, step));
          op = operators[operation].bind(null, left);
          operand = "";
        }
        continue;
      } else {
        addTo(depth, char);
      }
    }
    if (operand && op) {
      op = op.bind(null, evaluate(operand, step));
    }
    op = !op && left ? left : op;
    if (!op && operand) {
      op = (v, t) => {
        return typeof v === "function" ? v(t) : v;
      };
      op = op.bind(null, evaluate(operand, step));
    }
    if (!op && !operand) {
      error(105, expression);
    }
    return op;
  }
  function evaluate(operand, step, fnToken, tail) {
    if (fnToken) {
      const fn = evaluate(fnToken, operatorRegistry.length);
      let userFuncReturn;
      let tailCall = tail ? compile(`$${tail}`) : false;
      if (typeof fn === "function") {
        const args = parseArgs(String(operand)).map((arg) => evaluate(arg, -1));
        return (tokens) => {
          const userFunc = fn(tokens);
          if (typeof userFunc !== "function") {
            warn(150, fnToken);
            return userFunc;
          }
          userFuncReturn = userFunc(...args.map((arg) => typeof arg === "function" ? arg(tokens) : arg));
          if (tailCall) {
            tailCall = tailCall.provide((subTokens) => {
              const rootTokens = provideTokens(subTokens);
              const t = subTokens.reduce((tokenSet, token2) => {
                const isTail = token2 === tail || (tail === null || tail === void 0 ? void 0 : tail.startsWith(`${token2}(`));
                if (isTail) {
                  const value = getAt(userFuncReturn, token2);
                  tokenSet[token2] = () => value;
                } else {
                  tokenSet[token2] = rootTokens[token2];
                }
                return tokenSet;
              }, {});
              return t;
            });
          }
          return tailCall ? tailCall() : userFuncReturn;
        };
      }
    } else if (typeof operand === "string") {
      if (operand === "true")
        return true;
      if (operand === "false")
        return false;
      if (operand === "undefined")
        return void 0;
      if (isQuotedString(operand))
        return rmEscapes(operand.substr(1, operand.length - 2));
      if (!isNaN(+operand))
        return Number(operand);
      if (step < operatorRegistry.length - 1) {
        return parseLogicals(operand, step + 1);
      } else {
        if (operand.startsWith("$")) {
          const cleaned = operand.substr(1);
          requirements.add(cleaned);
          return function getToken(tokens) {
            return cleaned in tokens ? tokens[cleaned]() : void 0;
          };
        }
        return operand;
      }
    }
    return operand;
  }
  const compiled = parseLogicals(expr.startsWith("$:") ? expr.substr(2) : expr);
  const reqs = Array.from(requirements);
  function provide(callback) {
    provideTokens = callback;
    return Object.assign(compiled.bind(null, callback(reqs)), {
      provide
    });
  }
  return Object.assign(compiled, {
    provide
  });
}
function createClasses(propertyKey, node, sectionClassList) {
  if (!sectionClassList)
    return {};
  if (typeof sectionClassList === "string") {
    const classKeys = sectionClassList.split(" ");
    return classKeys.reduce((obj, key) => Object.assign(obj, { [key]: true }), {});
  } else if (typeof sectionClassList === "function") {
    return createClasses(propertyKey, node, sectionClassList(node, propertyKey));
  }
  return sectionClassList;
}
function generateClassList(node, property, ...args) {
  const combinedClassList = args.reduce((finalClassList, currentClassList) => {
    if (!currentClassList)
      return finalClassList;
    const _a = currentClassList, { $reset } = _a, classList = __objRest(_a, ["$reset"]);
    if ($reset) {
      return classList;
    }
    return Object.assign(finalClassList, classList);
  }, {});
  return Object.keys(node.hook.classes.dispatch({ property, classes: combinedClassList }).classes).filter((key) => combinedClassList[key]).join(" ") || null;
}
function setErrors(id, localErrors, childErrors) {
  const node = getNode$1(id);
  if (node) {
    node.setErrors(localErrors, childErrors);
  } else {
    warn(651, id);
  }
}

// node_modules/@formkit/inputs/dist/index.mjs
var outer = composable("outer", () => ({
  $el: "div",
  attrs: {
    class: "$classes.outer",
    "data-type": "$type",
    "data-multiple": "$attrs.multiple",
    "data-disabled": "$disabled || undefined",
    "data-complete": "$state.complete || undefined",
    "data-invalid": "$state.valid === false && $state.validationVisible || undefined",
    "data-errors": "$state.errors || undefined",
    "data-submitted": "$state.submitted || undefined"
  }
}));
var wrapper$2 = composable("wrapper", () => ({
  $el: "div",
  attrs: {
    class: "$classes.wrapper"
  }
}));
var inner = composable("inner", () => ({
  $el: "div",
  attrs: {
    class: "$classes.inner"
  }
}));
var help = (schema = {}, children = [], target = "help", cond = "$help") => ({
  if: `$slots.${target}`,
  then: `$slots.${target}`,
  else: extend({
    $el: "div",
    attrs: {
      id: `$: "help-" + ${target == "optionHelp" ? "$option.attrs.id" : "$id"}`,
      class: `$classes.${target}`
    },
    if: cond,
    children
  }, schema)
});
var messages = composable("messages", () => ({
  $el: "ul",
  if: "$fns.length($messages)",
  attrs: {
    class: "$classes.messages",
    "aria-live": '$type === "form" && "assertive" || "polite"'
  }
}));
var message = composable("message", () => ({
  $el: "li",
  for: ["message", "$messages"],
  attrs: {
    key: "$message.key",
    class: "$classes.message",
    id: `$id + '-' + $message.key`,
    "data-message-type": "$message.type"
  }
}));
var prefix = composable("prefix", () => ({ $el: null }));
var suffix = composable("suffix", () => ({ $el: null }));
function isSchemaObject(schema) {
  return typeof schema === "object" && ("$el" in schema || "$cmp" in schema || "$formkit" in schema);
}
function extendSchema(schema, extension = {}) {
  if (typeof schema === "string") {
    return isSchemaObject(extension) || typeof extension === "string" ? extension : schema;
  } else if (Array.isArray(schema)) {
    return isSchemaObject(extension) ? extension : schema;
  }
  return extend(schema, extension);
}
function composable(key, schema) {
  return (extendWith = {}, children = void 0) => {
    const root = typeof schema === "function" ? schema(children) : typeof schema === "object" ? clone(schema) : schema;
    const isObj = isSchemaObject(root);
    if (isObj && !("children" in root) && children) {
      if (Array.isArray(children)) {
        if (children.length) {
          root.children = children;
        }
      } else {
        root.children = [children];
      }
    }
    const extended = extendSchema(root, extendWith);
    return {
      if: `$slots.${key}`,
      then: `$slots.${key}`,
      else: Array.isArray(extended) ? extended : [extended]
    };
  };
}
function useSchema(inputSchema) {
  return (extensions = {}) => {
    const input2 = composable("input", inputSchema)(extensions.input);
    return [
      outer(extensions.outer, [
        wrapper$2(extensions.wrapper, [
          label(extensions.label, "$label"),
          inner(extensions.inner, [
            prefix(extensions.prefix),
            ...Array.isArray(input2) ? input2 : [input2],
            suffix(extensions.prefix)
          ])
        ]),
        help(extensions.help, "$help"),
        messages(extensions.messages, [
          message(extensions.message, "$message.value")
        ])
      ])
    ];
  };
}
var label = composable("label", () => ({
  $el: "label",
  if: "$label",
  attrs: {
    for: "$id",
    class: "$classes.label"
  }
}));
var text$1 = composable("input", () => ({
  $el: "input",
  bind: "$attrs",
  attrs: {
    type: "$type",
    disabled: "$disabled",
    class: "$classes.input",
    name: "$node.name",
    onInput: "$handlers.DOMInput",
    onBlur: "$handlers.blur",
    value: "$_value",
    id: "$id",
    "aria-describedby": "$describedBy"
  }
}));
var textSchema$1 = (extensions = {}) => [
  outer(extensions.outer, [
    wrapper$2(extensions.wrapper, [
      label(extensions.label, "$label"),
      inner(extensions.inner, [
        prefix(extensions.prefix),
        text$1(extensions.input),
        suffix(extensions.suffix)
      ])
    ]),
    help(extensions.help, "$help"),
    messages(extensions.messages, [
      message(extensions.message, "$message.value")
    ])
  ])
];
var file$1 = composable("input", () => ({
  $el: "input",
  bind: "$attrs",
  attrs: {
    type: "file",
    foo: "bar",
    disabled: "$disabled",
    class: "$classes.input",
    name: "$node.name",
    onChange: "$handlers.files",
    onBlur: "$handlers.blur",
    id: "$id",
    "aria-describedby": "$describedBy"
  }
}));
var fileList = composable("fileList", () => ({
  $el: "ul",
  if: "$value.length",
  attrs: {
    class: "$classes.fileList",
    "data-has-multiple": {
      if: "$value.length > 1",
      then: "true"
    }
  }
}));
var fileItem = composable("fileItem", () => ({
  $el: "li",
  for: ["file", "$value"],
  attrs: {
    class: "$classes.fileItem"
  }
}));
var fileName = composable("fileName", () => ({
  $el: "span",
  attrs: {
    class: "$classes.fileName"
  }
}));
var noFiles = composable("noFiles", () => ({
  $el: "span",
  if: "$value.length == 0",
  attrs: {
    class: "$classes.noFiles"
  }
}));
var removeFiles = composable("removeFiles", () => ({
  $el: "a",
  attrs: {
    href: "#",
    class: "$classes.removeFiles",
    onClick: "$handlers.resetFiles"
  }
}));
var fileSchema = (extensions = {}) => [
  outer(extensions.outer, [
    wrapper$2(extensions.wrapper, [
      label(extensions.label, "$label"),
      inner(extensions.inner, [
        prefix(extensions.prefix),
        file$1(extensions.input),
        fileList(extensions.fileList, [
          fileItem(extensions.file, [
            fileName(extensions.fileName, "$file.name"),
            {
              if: "$value.length == 1",
              then: removeFiles(extensions.removeFiles, "$ui.remove.value")
            }
          ])
        ]),
        {
          if: "$value.length > 1",
          then: removeFiles(extensions.removeFiles, "$ui.removeAll.value")
        },
        noFiles(extensions.noFiles, "$ui.noFiles.value"),
        suffix(extensions.suffix)
      ])
    ]),
    help(extensions.help, "$help"),
    messages(extensions.messages, [
      message(extensions.message, "$message.value")
    ])
  ])
];
var textarea$1 = composable("input", () => ({
  $el: "textarea",
  bind: "$attrs",
  attrs: {
    class: "$classes.input",
    disabled: "$disabled",
    name: "$node.name",
    onInput: "$handlers.DOMInput",
    onBlur: "$handlers.blur",
    value: "$_value",
    id: "$id",
    "aria-describedby": "$describedBy"
  },
  children: "$initialValue"
}));
var textareaSchema = (extensions = {}) => [
  outer(extensions.outer, [
    wrapper$2(extensions.wrapper, [
      label(extensions.label, "$label"),
      inner(extensions.inner, [
        prefix(extensions.prefix),
        textarea$1(extensions.input),
        suffix(extensions.suffix)
      ])
    ]),
    help(extensions.help, "$help"),
    messages(extensions.messages, [
      message(extensions.message, "$message.value")
    ])
  ])
];
var hiddenSchema = (extensions = {}) => [
  text$1(extensions.input)
];
var fragment = (schema = {}, children = []) => Object.keys(schema).length || typeof children !== "string" ? extend({ $el: "div", children }, schema) : children;
var groupSchema = (extensions = {}) => {
  return [fragment(extensions.wrapper, "$slots.default")];
};
var listSchema = (extensions = {}) => {
  return [fragment(extensions.wrapper, "$slots.default")];
};
var select$1 = composable("input", (children) => ({
  $el: "select",
  bind: "$attrs",
  attrs: {
    id: "$id",
    "data-placeholder": {
      if: "$placeholder",
      then: {
        if: "$value",
        then: void 0,
        else: "true"
      }
    },
    disabled: "$disabled",
    class: "$classes.input",
    name: "$node.name",
    onInput: "$handlers.selectInput",
    onBlur: "$handlers.blur",
    "aria-describedby": "$describedBy"
  },
  children: {
    if: "$slots.default",
    then: "$slots.default",
    else: children
  }
}));
var option = (schema = {}, children = []) => ({
  if: "$slots.option",
  then: [
    {
      $el: "text",
      if: "$options.length",
      for: ["option", "$options"],
      children: "$slots.option"
    }
  ],
  else: extend({
    $el: "option",
    if: "$options.length",
    for: ["option", "$options"],
    bind: "$option.attrs",
    attrs: {
      class: "$classes.option",
      value: "$option.value",
      selected: "$fns.isSelected($option.value)"
    },
    children
  }, schema)
});
var textSchema = (extensions = {}) => [
  outer(extensions.outer, [
    wrapper$2(extensions.wrapper, [
      label(extensions.label, "$label"),
      inner(extensions.inner, [
        prefix(extensions.prefix),
        select$1(extensions.input, [option(extensions.option, "$option.label")]),
        suffix(extensions.suffix)
      ])
    ]),
    help(extensions.help, "$help"),
    messages(extensions.messages, [
      message(extensions.message, "$message.value")
    ])
  ])
];
var boxLabel = composable("label", (children) => ({
  $el: "span",
  if: typeof children === "string" ? children : "$: true",
  attrs: {
    class: "$classes.label"
  }
}));
var wrapper$1 = composable("wrapper", () => ({
  $el: "label",
  attrs: {
    class: "$classes.wrapper",
    "data-disabled": {
      if: "$options.length",
      then: void 0,
      else: "$disabled"
    }
  }
}));
var box = composable("input", () => ({
  $el: "input",
  bind: "$attrs",
  attrs: {
    type: "$type",
    class: "$classes.input",
    name: "$node.props.altName || $node.name",
    disabled: "$option.attrs.disabled || $disabled",
    onInput: "$handlers.toggleChecked",
    checked: "$_value === $onValue",
    onBlur: "$handlers.blur",
    value: "$: true",
    id: "$id",
    "aria-describedby": {
      if: "$options.length",
      then: {
        if: "$option.help",
        then: '$: "help-" + $option.attrs.id',
        else: void 0
      },
      else: {
        if: "$help",
        then: '$: "help-" + $id',
        else: void 0
      }
    }
  }
}));
var fieldset = composable("fieldset", () => ({
  $el: "fieldset",
  attrs: {
    id: "$id",
    class: "$classes.fieldset",
    "aria-describedby": {
      if: "$help",
      then: '$: "help-" + $id',
      else: void 0
    }
  }
}));
var legend = composable("legend", () => ({
  $el: "legend",
  if: "$label",
  attrs: {
    class: "$classes.legend"
  }
}));
var boxes = composable("option", () => ({
  $el: "li",
  for: ["option", "$options"],
  attrs: {
    class: "$classes.option",
    "data-disabled": "$option.attrs.disabled || $disabled"
  }
}));
var wrapper = composable("options", () => ({
  $el: "ul",
  attrs: {
    class: "$classes.options"
  }
}));
var decorator = composable("decorator", () => ({
  $el: "span",
  attrs: {
    class: "$classes.decorator",
    "aria-hidden": "true"
  }
}));
var boxSchema = (extensions = {}) => {
  const singleCheckbox = [
    wrapper$1(extensions.wrapper, [
      inner(extensions.inner, [
        prefix(extensions.prefix),
        box(extensions.input),
        decorator(extensions.decorator),
        suffix(extensions.suffix)
      ]),
      boxLabel(extensions.label, "$label")
    ]),
    help(extensions.help, "$help")
  ];
  const multiCheckbox = fieldset(extensions.fieldset, [
    legend(extensions.legend, "$label"),
    help(extensions.help, "$help"),
    wrapper(extensions.options, [
      boxes(extensions.option, [
        wrapper$1(extensions.wrapper, [
          inner(extensions.inner, [
            prefix(extensions.prefix),
            box(extend({
              bind: "$option.attrs",
              attrs: {
                id: "$option.attrs.id",
                value: "$option.value",
                checked: "$fns.isChecked($option.value)"
              }
            }, extensions.input || {})),
            decorator(extensions.decorator),
            suffix(extensions.suffix)
          ]),
          boxLabel(extensions.label, "$option.label")
        ]),
        help(extensions.optionHelp, "$option.help", "optionHelp", "$option.help")
      ])
    ])
  ]);
  return [
    outer(extensions.outer, [
      {
        if: "$options.length",
        then: multiCheckbox,
        else: singleCheckbox
      },
      messages(extensions.messages, [
        message(extensions.message, "$message.value")
      ])
    ])
  ];
};
var actions = composable("actions", () => ({
  $el: "div",
  if: "$actions",
  attrs: {
    class: "$classes.actions"
  }
}));
var form$1 = composable("form", () => ({
  $el: "form",
  bind: "$attrs",
  attrs: {
    id: "$id",
    class: "$classes.form",
    name: "$node.name",
    onSubmit: "$handlers.submit",
    "data-loading": "$state.loading || undefined"
  }
}));
var submit$1 = composable("submit", () => ({
  $cmp: "FormKit",
  bind: "$submitAttrs",
  props: {
    ignore: true,
    type: "submit",
    disabled: "$disabled",
    label: "$submitLabel"
  }
}));
var formSchema = (extensions = {}) => {
  return [
    form$1(extensions.form, [
      "$slots.default",
      messages(extensions.messages, [
        message(extensions.message, "$message.value")
      ]),
      actions(extensions.actions, [submit$1(extensions.submit)])
    ])
  ];
};
var button$1 = composable("input", () => ({
  $el: "button",
  bind: "$attrs",
  attrs: {
    type: "$type",
    disabled: "$disabled",
    class: "$classes.input",
    name: "$node.name",
    id: "$id"
  }
}));
var buttonSchema = (extensions = {}) => [
  outer(extensions.outer, [
    messages(extensions.messages, [
      message(extensions.message, "$message.value")
    ]),
    wrapper$2(extensions.wrapper, [
      button$1(extensions.input, [
        prefix(extensions.prefix),
        {
          if: "$slots.default",
          then: "$slots.default",
          else: {
            if: "$label",
            then: "$label",
            else: "$ui.submit.value"
          }
        },
        suffix(extensions.suffix)
      ])
    ]),
    help(extensions.help, "$help")
  ])
];
function normalizeOptions(options) {
  if (Array.isArray(options)) {
    return options.map((option2) => {
      if (typeof option2 === "string" || typeof option2 === "number") {
        return {
          label: option2,
          value: option2
        };
      }
      return option2;
    });
  }
  return Object.keys(options).map((value) => {
    return {
      label: options[value],
      value
    };
  });
}
function formatsOptions(node) {
  node.hook.prop((prop, next) => {
    if (prop.prop === "options") {
      const options = normalizeOptions(prop.value);
      prop.value = options;
    }
    return next(prop);
  });
}
function isSelected(node, option2) {
  node.context && node.context.value;
  return Array.isArray(node._value) ? node._value.includes(option2) : node.value === void 0 && !option2 || node._value == option2;
}
function selectInput(node, e) {
  const target = e.target;
  const value = target.hasAttribute("multiple") ? Array.from(target.selectedOptions).map((o) => o.value) : target.value;
  node.input(value);
}
function applyPlaceholder(options, placeholder) {
  if (!options.some((option2) => option2.attrs && option2.attrs["data-is-placeholder"])) {
    return [
      {
        label: placeholder,
        value: "",
        attrs: {
          hidden: true,
          disabled: true,
          "data-is-placeholder": "true"
        }
      },
      ...options
    ];
  }
  return options;
}
function selectFeatures(node) {
  node.on("created", () => {
    var _a, _b, _c;
    const isMultiple = ((_a = node.props.attrs) === null || _a === void 0 ? void 0 : _a.multiple) !== void 0;
    if (!isMultiple && node.props.placeholder && Array.isArray(node.props.options)) {
      node.hook.prop(({ prop, value }, next) => {
        if (prop === "options") {
          value = applyPlaceholder(value, node.props.placeholder);
        }
        return next({ prop, value });
      });
      node.props.options = applyPlaceholder(node.props.options, node.props.placeholder);
    }
    if (isMultiple) {
      if (node.value === void 0) {
        node.input([], false);
      }
    } else if (node.context && !node.context.options) {
      node.props.attrs = Object.assign({}, node.props.attrs, {
        value: node._value
      });
      node.on("input", ({ payload }) => {
        node.props.attrs = Object.assign({}, node.props.attrs, {
          value: payload
        });
      });
    }
    if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.handlers) {
      node.context.handlers.selectInput = selectInput.bind(null, node);
    }
    if ((_c = node.context) === null || _c === void 0 ? void 0 : _c.fns) {
      node.context.fns.isSelected = isSelected.bind(null, node);
    }
  });
  node.hook.input((value, next) => {
    var _a, _b;
    if (!node.props.placeholder && value === void 0 && Array.isArray((_a = node.props) === null || _a === void 0 ? void 0 : _a.options) && node.props.options.length && !("multiple" in ((_b = node.props) === null || _b === void 0 ? void 0 : _b.attrs))) {
      value = node.props.options[0].value;
    }
    return next(value);
  });
}
function normalizeBoxes(node) {
  return function(prop, next) {
    if (prop.prop === "options" && Array.isArray(prop.value)) {
      prop.value = prop.value.map((option2) => {
        var _a;
        if (!((_a = option2.attrs) === null || _a === void 0 ? void 0 : _a.id)) {
          return extend(option2, {
            attrs: { id: `${node.name}-option-${kebab(String(option2.value))}` }
          });
        }
        return option2;
      });
      if (node.props.type === "checkbox" && !Array.isArray(node.value)) {
        if (node.isCreated) {
          node.input([], false);
        } else {
          node.on("created", () => {
            if (!Array.isArray(node.value)) {
              node.input([], false);
            }
          });
        }
      }
    }
    return next(prop);
  };
}
function toggleChecked$1(node, e) {
  const el = e.target;
  if (el instanceof HTMLInputElement) {
    if (Array.isArray(node.props.options) && node.props.options.length) {
      if (!Array.isArray(node._value)) {
        node.input([el.value]);
      } else if (!node._value.includes(el.value)) {
        node.input([...node._value, el.value]);
      } else {
        node.input(node._value.filter((val) => val !== el.value));
      }
    } else {
      if (el.checked) {
        node.input(node.props.onValue);
      } else {
        node.input(node.props.offValue);
      }
    }
  }
}
function isChecked$1(node, value) {
  var _a, _b;
  (_a = node.context) === null || _a === void 0 ? void 0 : _a.value;
  (_b = node.context) === null || _b === void 0 ? void 0 : _b._value;
  return Array.isArray(node._value) ? node._value.includes(value) : false;
}
function checkboxes(node) {
  node.on("created", () => {
    var _a, _b;
    if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {
      node.context.handlers.toggleChecked = toggleChecked$1.bind(null, node);
    }
    if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.fns) {
      node.context.fns.isChecked = isChecked$1.bind(null, node);
    }
    if (!has(node.props, "onValue"))
      node.props.onValue = true;
    if (!has(node.props, "offValue"))
      node.props.offValue = false;
  });
  node.hook.prop(normalizeBoxes(node));
}
function toggleChecked(node, event) {
  if (event.target instanceof HTMLInputElement) {
    node.input(event.target.value);
  }
}
function isChecked(node, value) {
  var _a, _b;
  (_a = node.context) === null || _a === void 0 ? void 0 : _a.value;
  (_b = node.context) === null || _b === void 0 ? void 0 : _b._value;
  return node._value == value;
}
function radios(node) {
  node.on("created", () => {
    var _a, _b;
    if (!Array.isArray(node.props.options)) {
      warn(350, node);
    }
    if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {
      node.context.handlers.toggleChecked = toggleChecked.bind(null, node);
    }
    if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.fns) {
      node.context.fns.isChecked = isChecked.bind(null, node);
    }
  });
  node.hook.prop(normalizeBoxes(node));
}
function disablesChildren(node) {
  node.hook.prop(({ prop, value }, next) => {
    value = prop === "disabled" ? undefine(value) : value;
    return next({ prop, value });
  });
  node.on("prop:disabled", ({ payload: value }) => {
    node.config.disabled = value;
  });
  node.on("created", () => {
    node.config.disabled = undefine(node.props.disabled);
  });
}
async function handleSubmit(node, submitEvent) {
  submitEvent.preventDefault();
  await node.settled;
  node.walk((n) => {
    n.store.set(createMessage({
      key: "submitted",
      value: true,
      visible: false
    }));
  });
  if (typeof node.props.onSubmitRaw === "function") {
    node.props.onSubmitRaw(submitEvent);
  }
  if (node.ledger.value("blocking")) {
    if (node.props.incompleteMessage !== false) {
      node.store.set(createMessage({
        blocking: false,
        key: `incomplete`,
        meta: {
          localize: node.props.incompleteMessage === void 0,
          i18nArgs: [{ node }],
          showAsMessage: true
        },
        type: "ui",
        value: node.props.incompleteMessage || "Form incomplete."
      }));
    }
  } else {
    if (typeof node.props.onSubmit === "function") {
      const retVal = node.props.onSubmit(clone(node.value), node);
      if (retVal instanceof Promise) {
        const autoDisable = node.props.disabled === void 0 && node.props.submitBehavior !== "live";
        if (autoDisable)
          node.props.disabled = true;
        node.store.set(createMessage({
          key: "loading",
          value: true,
          visible: false
        }));
        await retVal;
        if (autoDisable)
          node.props.disabled = false;
        node.store.remove("loading");
      }
    } else {
      if (submitEvent.target instanceof HTMLFormElement) {
        submitEvent.target.submit();
      }
    }
  }
}
function formHandler(node) {
  node.props.isForm = true;
  node.on("created", () => {
    var _a;
    if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {
      node.context.handlers.submit = handleSubmit.bind(null, node);
    }
    if (!has(node.props, "actions")) {
      node.props.actions = true;
    }
  });
  node.on("settled:blocking", () => node.store.remove("incomplete"));
}
function localize(key, value) {
  return (node) => {
    node.store.set(createMessage({
      key,
      type: "ui",
      value: value || key,
      meta: {
        localize: true,
        i18nArgs: [node]
      }
    }));
  };
}
var isBrowser = typeof window !== "undefined";
function removeHover(e) {
  if (e.target instanceof HTMLElement && e.target.hasAttribute("data-file-hover")) {
    e.target.removeAttribute("data-file-hover");
  }
}
function preventStrayDrop(type, e) {
  if (!(e.target instanceof HTMLInputElement)) {
    e.preventDefault();
  } else if (type === "dragover") {
    e.target.setAttribute("data-file-hover", "true");
  }
  if (type === "drop") {
    removeHover(e);
  }
}
function files(node) {
  localize("noFiles", "Select file")(node);
  localize("removeAll", "Remove all")(node);
  localize("remove")(node);
  if (isBrowser) {
    if (!window._FormKit_File_Drop) {
      window.addEventListener("dragover", preventStrayDrop.bind(null, "dragover"));
      window.addEventListener("drop", preventStrayDrop.bind(null, "drop"));
      window.addEventListener("dragleave", removeHover);
      window._FormKit_File_Drop = true;
    }
  }
  node.on("created", () => {
    if (!Array.isArray(node.value)) {
      node.input([], false);
    }
    if (!node.context)
      return;
    node.context.handlers.resetFiles = (e) => {
      e.preventDefault();
      node.input([]);
      if (node.props.id && isBrowser) {
        const el = document.getElementById(node.props.id);
        if (el)
          el.value = "";
      }
    };
    node.context.handlers.files = (e) => {
      var _a, _b;
      const files2 = [];
      if (e.target instanceof HTMLInputElement && e.target.files) {
        for (let i = 0; i < e.target.files.length; i++) {
          let file2;
          if (file2 = e.target.files.item(i)) {
            files2.push({ name: file2.name, file: file2 });
          }
        }
        node.input(files2);
      }
      if (node.context)
        node.context.files = files2;
      if (typeof ((_a = node.props.attrs) === null || _a === void 0 ? void 0 : _a.onChange) === "function") {
        (_b = node.props.attrs) === null || _b === void 0 ? void 0 : _b.onChange(e);
      }
    };
  });
}
function ignore(node) {
  if (node.props.ignore === void 0) {
    node.props.ignore = true;
    node.parent = null;
  }
}
function initialValue(node) {
  node.on("created", () => {
    if (node.context) {
      node.context.initialValue = node.value || "";
    }
  });
}
var textClassification = {
  type: "input",
  schema: textSchema$1
};
var color = textClassification;
var date = textClassification;
var datetimeLocal = textClassification;
var email = textClassification;
var month = textClassification;
var number = textClassification;
var password = textClassification;
var search = textClassification;
var tel = textClassification;
var time = textClassification;
var text2 = textClassification;
var url = textClassification;
var week = textClassification;
var range = textClassification;
var textarea = {
  type: "input",
  schema: textareaSchema,
  features: [initialValue]
};
var buttonClassification = {
  type: "input",
  schema: buttonSchema,
  features: [localize("submit"), ignore]
};
var submit2 = buttonClassification;
var button = buttonClassification;
var hidden = {
  type: "input",
  schema: hiddenSchema
};
var select2 = {
  type: "input",
  schema: textSchema,
  props: ["options", "placeholder"],
  features: [formatsOptions, selectFeatures]
};
var checkbox = {
  type: "input",
  schema: boxSchema,
  props: ["options", "onValue", "offValue"],
  features: [formatsOptions, checkboxes]
};
var radio = {
  type: "input",
  schema: boxSchema,
  props: ["options"],
  features: [formatsOptions, radios]
};
var group = {
  type: "group",
  schema: groupSchema,
  features: [disablesChildren]
};
var form = {
  type: "group",
  schema: formSchema,
  props: [
    "actions",
    "submit",
    "submitLabel",
    "submitAttrs",
    "submitBehavior",
    "incompleteMessage"
  ],
  features: [formHandler, disablesChildren]
};
var list = {
  type: "list",
  schema: listSchema,
  features: [disablesChildren]
};
var file = {
  type: "input",
  schema: fileSchema,
  features: [files],
  props: ["files"]
};
var inputs = Object.freeze({
  __proto__: null,
  color,
  date,
  datetimeLocal,
  email,
  month,
  number,
  password,
  search,
  tel,
  time,
  text: text2,
  url,
  week,
  range,
  textarea,
  submit: submit2,
  button,
  hidden,
  select: select2,
  checkbox,
  radio,
  group,
  form,
  list,
  file
});
function createLibraryPlugin(...libraries) {
  const library = libraries.reduce((merged, lib) => extend(merged, lib), {});
  const plugin = () => {
  };
  plugin.library = function(node) {
    const type = camel(node.props.type);
    if (has(library, type)) {
      node.define(library[type]);
    }
  };
  return plugin;
}

export {
  token,
  has,
  eq,
  empty,
  regexForFormat,
  isPojo,
  extend,
  nodeProps,
  except,
  only,
  camel,
  kebab,
  clone,
  cloneAny,
  slugify,
  errorHandler,
  warningHandler,
  warn,
  error,
  createMessage,
  getNode$1,
  watchRegistry,
  createConfig$1,
  submitForm,
  reset,
  isNode,
  resetCount,
  createNode,
  isDOM,
  isComponent,
  isConditional,
  sugar,
  compile,
  createClasses,
  generateClassList,
  setErrors,
  extendSchema,
  composable,
  useSchema,
  localize,
  color,
  date,
  datetimeLocal,
  email,
  month,
  number,
  password,
  search,
  tel,
  time,
  text2 as text,
  url,
  week,
  range,
  textarea,
  submit2 as submit,
  button,
  hidden,
  select2 as select,
  checkbox,
  radio,
  group,
  form,
  list,
  file,
  inputs,
  createLibraryPlugin
};
//# sourceMappingURL=chunk-KH7O2Y2Z.js.map

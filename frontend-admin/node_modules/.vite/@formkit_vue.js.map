{
  "version": 3,
  "sources": ["../@formkit/rules/dist/index.mjs", "../@formkit/observer/dist/index.mjs", "../@formkit/validation/dist/index.mjs", "../@formkit/i18n/dist/index.mjs", "../@formkit/dev/dist/index.mjs", "../@formkit/vue/dist/index.mjs"],
  "sourcesContent": ["import { has, regexForFormat, eq, empty } from '@formkit/utils';\n\n/**\n * Determine if the given input's value was should be considered \"accepted\".\n * @param context - The FormKitValidationContext\n * @public\n */\nconst accepted = function accepted({ value }) {\n    return ['yes', 'on', '1', 1, true, 'true'].includes(value);\n};\n\n/**\n * Determine if the given input's value is after a given date.\n * Defaults to current time.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_after = function ({ value }, compare = false) {\n    const timestamp = Date.parse(compare || new Date());\n    const fieldValue = Date.parse(String(value));\n    return isNaN(fieldValue) ? false : fieldValue > timestamp;\n};\n\n/**\n * Determine if the given input's value is only alpha characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst alpha = function ({ value }, set = 'default') {\n    const sets = {\n        default: /^[a-zA-Z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF\u0104\u0105\u0106\u0107\u0118\u0119\u0141\u0142\u0143\u0144\u015A\u015B\u0179\u017A\u017B\u017C]+$/,\n        latin: /^[a-zA-Z]+$/,\n    };\n    const selectedSet = has(sets, set) ? set : 'default';\n    return sets[selectedSet].test(String(value));\n};\n\n/**\n * Determine if the given input's value is only alpha characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst alpha_spaces = function ({ value }, set = 'default') {\n    const sets = {\n        default: /^[a-zA-Z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF\u0104\u0105\u0106\u0107\u0118\u0119\u0141\u0142\u0143\u0144\u015A\u015B\u0179\u017A\u017B\u017C ]+$/,\n        latin: /^[a-zA-Z ]+$/,\n    };\n    const selectedSet = has(sets, set) ? set : 'default';\n    return sets[selectedSet].test(String(value));\n};\n\n/**\n * Determine if the given input's value is only alpha or numeric characters.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst alphanumeric = function ({ value }, set = 'default') {\n    const sets = {\n        default: /^[a-zA-Z0-9\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF\u0104\u0105\u0106\u0107\u0118\u0119\u0141\u0142\u0143\u0144\u015A\u015B\u0179\u017A\u017B\u017C]+$/,\n        latin: /^[a-zA-Z0-9]+$/,\n    };\n    const selectedSet = has(sets, set) ? set : 'default';\n    return sets[selectedSet].test(String(value));\n};\n\n/**\n * Determine if the given input's value before a given date.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_before = function ({ value }, compare = false) {\n    const timestamp = Date.parse(compare || new Date());\n    const fieldValue = Date.parse(String(value));\n    return isNaN(fieldValue) ? false : fieldValue < timestamp;\n};\n\n/**\n * Determine if the given input's value is between two other values.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst between = function between({ value }, from, to) {\n    if (!isNaN(value) && !isNaN(from) && !isNaN(to)) {\n        const val = 1 * value;\n        from = Number(from);\n        to = Number(to);\n        const [a, b] = from <= to ? [from, to] : [to, from];\n        return val >= 1 * a && val <= 1 * b;\n    }\n    return false;\n};\n\nconst hasConfirm = /(_confirm(?:ed)?)$/;\n/**\n * Determine if the given input's value matches another input's value\n * @param context - The FormKitValidationContext\n * @public\n */\nconst confirm = function confirm(node, address, comparison = 'loose') {\n    var _a;\n    if (!address) {\n        address = hasConfirm.test(node.name)\n            ? node.name.replace(hasConfirm, '')\n            : `${node.name}_confirm`;\n    }\n    const foreignValue = (_a = node.at(address)) === null || _a === void 0 ? void 0 : _a.value;\n    return comparison === 'strict'\n        ? node.value === foreignValue\n        : node.value == foreignValue;\n};\n\n/**\n * Determine if the given input's value is between two other dates\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_between = function date_between({ value }, dateA, dateB) {\n    dateA = dateA instanceof Date ? dateA.getTime() : Date.parse(dateA);\n    dateB = dateB instanceof Date ? dateB.getTime() : Date.parse(dateB);\n    const compareTo = value instanceof Date ? value.getTime() : Date.parse(String(value));\n    if (dateA && !dateB) {\n        dateB = dateA;\n        dateA = Date.now();\n    }\n    else if (!dateA || !compareTo) {\n        return false;\n    }\n    return compareTo >= dateA && compareTo <= dateB;\n};\n\n/**\n * Determine if the given input's value matches a specified date format\n * @param context - The FormKitValidationContext\n * @public\n */\nconst date_format = function date({ value }, format) {\n    if (format && typeof format === 'string') {\n        return regexForFormat(format).test(String(value));\n    }\n    return !isNaN(Date.parse(String(value)));\n};\n\n/**\n * Determine if the given input's value is a plausible email address.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst email = function email({ value }) {\n    const isEmail = /^(([^<>()\\[\\]\\.,;:\\s@\\\"]+(\\.[^<>()\\[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()[\\]\\.,;:\\s@\\\"]+\\.)+[^<>()[\\]\\.,;:\\s@\\\"]{2,})$/i;\n    return isEmail.test(String(value));\n};\n\n/**\n * Determine if the given input's value ends with a given string\n * @param context - The FormKitValidationContext\n * @public\n */\nconst ends_with = function ends_with({ value }, ...stack) {\n    if (typeof value === 'string' && stack.length) {\n        return stack.some((item) => {\n            return value.endsWith(item);\n        });\n    }\n    else if (typeof value === 'string' && stack.length === 0) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * Determine if the given input's value is in a set of possible values.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst is = function is({ value }, ...stack) {\n    return stack.some((item) => {\n        if (typeof item === 'object') {\n            return eq(item, value);\n        }\n        return item == value;\n    });\n};\n\n/**\n * Determine if the given input's value length is full width.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst length = function length({ value }, first = 0, second = Infinity) {\n    first = parseInt(first);\n    second = isNaN(parseInt(second)) ? Infinity : parseInt(second);\n    const min = first <= second ? first : second;\n    const max = second >= first ? second : first;\n    if (typeof value === 'string' || Array.isArray(value)) {\n        return value.length >= min && value.length <= max;\n    }\n    else if (value && typeof value === 'object') {\n        const length = Object.keys(value).length;\n        return length >= min && length <= max;\n    }\n    return false;\n};\n\n/**\n * Determine if the given input's value matches one or more values or regular expressions.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst matches = function matches({ value }, ...stack) {\n    return stack.some((pattern) => {\n        if (typeof pattern === 'string' &&\n            pattern.substr(0, 1) === '/' &&\n            pattern.substr(-1) === '/') {\n            pattern = new RegExp(pattern.substr(1, pattern.length - 2));\n        }\n        if (pattern instanceof RegExp) {\n            return pattern.test(String(value));\n        }\n        return pattern === value;\n    });\n};\n\n/**\n * Determine if the given input's value is less than the maximum\n * @param context - The FormKitValidationContext\n * @public\n */\nconst max = function max({ value }, maximum = 10) {\n    if (Array.isArray(value)) {\n        return value.length <= maximum;\n    }\n    return Number(value) <= Number(maximum);\n};\n\n/**\n * Determine if the given input's value is less than a certain value.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst min = function min({ value }, minimum = 1) {\n    if (Array.isArray(value)) {\n        return value.length >= minimum;\n    }\n    return Number(value) >= Number(minimum);\n};\n\n/**\n * Determine if the given input's value is not in a given stack\n * @param context - The FormKitValidationContext\n * @public\n */\nconst not = function not({ value }, ...stack) {\n    return !stack.some((item) => {\n        if (typeof item === 'object') {\n            return eq(item, value);\n        }\n        return item === value;\n    });\n};\n\n/**\n * Determine if the given input's value is numeric\n * @param context - The FormKitValidationContext\n * @public\n */\nconst number = function number({ value }) {\n    return !isNaN(value);\n};\n\n/**\n * Determine if the given input's value was required.\n * @param context - The FormKitValidationContext\n * @public\n */\nconst required = function required({ value }) {\n    return !empty(value);\n};\n/**\n * This rules should run even if the inputs is empty (obviously)\n */\nrequired.skipEmpty = false;\n\n/**\n * Determine if the given input's value starts with a substring\n * @param context - The FormKitValidationContext\n * @public\n */\nconst starts_with = function starts_with({ value }, ...stack) {\n    if (typeof value === 'string' && stack.length) {\n        return stack.some((item) => {\n            return value.startsWith(item);\n        });\n    }\n    else if (typeof value === 'string' && stack.length === 0) {\n        return true;\n    }\n    return false;\n};\n\n/**\n * Determine if the given input's value is an http url\n * @param context - The FormKitValidationContext\n * @public\n */\nconst url = function url({ value }, ...stack) {\n    try {\n        const protocols = stack.length ? stack : ['http:', 'https:'];\n        const url = new URL(String(value));\n        return protocols.includes(url.protocol);\n    }\n    catch {\n        return false;\n    }\n};\n\nexport { accepted, alpha, alpha_spaces, alphanumeric, between, confirm, date_after, date_before, date_between, date_format, email, ends_with, is, length, matches, max, min, not, number, required, starts_with, url };\n", "import { has } from '@formkit/utils';\nimport { isNode } from '@formkit/core';\n\n/**\n * The FormKitNode to observe.\n * @param node - Any formkit node to observe.\n * @returns\n * @public\n */\nfunction createObserver(node, dependencies) {\n    // The dependencies touched during tracking\n    const deps = dependencies || Object.assign(new Map(), { active: false });\n    // A registry of event receipts returned by the event system\n    const receipts = new Map();\n    /**\n     * Simple function to add a dependency to the deps map.\n     * @param event - The name of the event type (like commit/input etc)\n     */\n    const addDependency = function (event) {\n        var _a;\n        if (!deps.active)\n            return;\n        if (!deps.has(node))\n            deps.set(node, new Set());\n        (_a = deps.get(node)) === null || _a === void 0 ? void 0 : _a.add(event);\n    };\n    /**\n     * Proxies the props of a node so we know which ones were messed with, could\n     * potentially be more generalized in the future if we want to support\n     * more sub-objects.\n     * @param props - The props object from a node\n     * @returns\n     */\n    const observeProps = function (props) {\n        return new Proxy(props, {\n            get(...args) {\n                typeof args[1] === 'string' && addDependency(`prop:${args[1]}`);\n                return Reflect.get(...args);\n            },\n        });\n    };\n    /**\n     * Observes the FormKit ledger \"value\".\n     * @param ledger - A formkit ledger counter.\n     */\n    const observeLedger = function (ledger) {\n        return new Proxy(ledger, {\n            get(...args) {\n                if (args[1] === 'value') {\n                    return (key) => {\n                        addDependency(`count:${key}`);\n                        return ledger.value(key);\n                    };\n                }\n                return Reflect.get(...args);\n            },\n        });\n    };\n    /**\n     * Return values from our observer proxy first pass through this function\n     * which gives us a chance to listen sub-dependencies and properties.\n     */\n    const observe = function (value, property) {\n        if (isNode(value)) {\n            return createObserver(value, deps);\n        }\n        if (property === 'value')\n            addDependency('commit');\n        if (property === 'props')\n            return observeProps(value);\n        if (property === 'ledger')\n            return observeLedger(value);\n        return value;\n    };\n    /**\n     * The actual proxy object of the original node.\n     */\n    const { proxy: observed, revoke, } = Proxy.revocable(node, {\n        get(...args) {\n            switch (args[1]) {\n                case 'deps':\n                    return deps;\n                case 'watch':\n                    return (block) => watch(observed, block);\n                case 'observe':\n                    return () => {\n                        const old = new Map(deps);\n                        deps.clear();\n                        deps.active = true;\n                        return old;\n                    };\n                case 'stopObserve':\n                    return () => {\n                        const newDeps = new Map(deps);\n                        deps.active = false;\n                        return newDeps;\n                    };\n                case 'receipts':\n                    return receipts;\n                case 'kill':\n                    removeListeners(receipts);\n                    return () => revoke();\n            }\n            const value = Reflect.get(...args);\n            // If we're dealing with a function, we need to sub-call the function\n            // get that return value, and pass it through the same logic.\n            if (typeof value === 'function') {\n                return (...subArgs) => {\n                    const subValue = value(...subArgs);\n                    return observe(subValue, args[1]);\n                };\n            }\n            return observe(value, args[1]);\n        },\n    });\n    return observed;\n}\n/**\n * Given two maps (toAdd and toRemove) apply the dependencies as event listeners\n * on the underlying nodes.\n * @param node - The node to apply dependencies to\n * @param delta - The toAdd and toRemove dependency Maps\n * @public\n */\nfunction applyListeners(node, [toAdd, toRemove], callback) {\n    toAdd.forEach((events, depNode) => {\n        events.forEach((event) => {\n            node.receipts.has(depNode) || node.receipts.set(depNode, {});\n            node.receipts.set(depNode, Object.assign(node.receipts.get(depNode), {\n                [event]: depNode.on(event, callback),\n            }));\n        });\n    });\n    toRemove.forEach((events, depNode) => {\n        events.forEach((event) => {\n            if (node.receipts.has(depNode)) {\n                const nodeReceipts = node.receipts.get(depNode);\n                if (nodeReceipts && has(nodeReceipts, event)) {\n                    depNode.off(nodeReceipts[event]);\n                    delete nodeReceipts[event];\n                    node.receipts.set(depNode, nodeReceipts);\n                }\n            }\n        });\n    });\n}\n/**\n * Remove all the receipts from the observed node and subtree.\n * @param receipts - The formkit observer receipts to remove\n * @public\n */\nfunction removeListeners(receipts) {\n    receipts.forEach((events, node) => {\n        for (const event in events) {\n            node.off(events[event]);\n        }\n    });\n}\n/**\n * Observes a chunk of code to dependencies, and then re-calls that chunk of\n * code when those dependencies are manipulated.\n * @param node - The node to observer\n * @param block - The block of code to observe\n * @public\n */\nasync function watch(node, block) {\n    const oldDeps = new Map(node.deps);\n    node.observe();\n    const res = block(node);\n    if (res instanceof Promise)\n        await res;\n    const newDeps = node.stopObserve();\n    applyListeners(node, diffDeps(oldDeps, newDeps), () => watch(node, block));\n}\n/**\n * Determines which nodes should be added as dependencies and which should be\n * removed.\n * @param previous - The previous watcher dependencies\n * @param current - The new/current watcher dependencies\n * @returns\n * @public\n */\nfunction diffDeps(previous, current) {\n    const toAdd = new Map();\n    const toRemove = new Map();\n    current.forEach((events, node) => {\n        if (!previous.has(node)) {\n            toAdd.set(node, events);\n        }\n        else {\n            const eventsToAdd = new Set();\n            const previousEvents = previous.get(node);\n            events.forEach((event) => !(previousEvents === null || previousEvents === void 0 ? void 0 : previousEvents.has(event)) && eventsToAdd.add(event));\n            toAdd.set(node, eventsToAdd);\n        }\n    });\n    previous.forEach((events, node) => {\n        if (!current.has(node)) {\n            toRemove.set(node, events);\n        }\n        else {\n            const eventsToRemove = new Set();\n            const newEvents = current.get(node);\n            events.forEach((event) => !(newEvents === null || newEvents === void 0 ? void 0 : newEvents.has(event)) && eventsToRemove.add(event));\n            toRemove.set(node, eventsToRemove);\n        }\n    });\n    return [toAdd, toRemove];\n}\n\nexport { applyListeners, createObserver, diffDeps, removeListeners };\n", "import { createMessage } from '@formkit/core';\nimport { createObserver, removeListeners, applyListeners, diffDeps } from '@formkit/observer';\nimport { token, empty, clone, has } from '@formkit/utils';\n\n/**\n * Message that gets set when the node is awaiting validation.\n */\nconst validatingMessage = createMessage({\n    type: 'state',\n    blocking: true,\n    visible: false,\n    value: true,\n    key: 'validating',\n});\n/**\n * The actual validation plugin function, everything must be bootstrapped here.\n * @param node - The node to bind validation to.\n * @public\n */\nfunction createValidationPlugin(baseRules = {}) {\n    return function validationPlugin(node) {\n        const availableRules = Object.assign({}, baseRules, node.props.validationRules);\n        // create an observed node\n        const observedNode = createObserver(node);\n        const state = { input: token(), rerun: null, isPassing: true };\n        // If the node's validation prop changes, update the rules:\n        node.on('prop', (event) => {\n            if (event.payload.prop === 'validation') {\n                // Destroy all observers that may re-trigger validation on an old stack\n                removeListeners(observedNode.receipts);\n                // Remove all existing messages before re-validating\n                node.store.filter(() => false, 'validation');\n                node.props.parsedRules = parseRules(event.payload.value, availableRules);\n                validate(observedNode, node.props.parsedRules, state);\n            }\n        });\n        // Validate the field when this plugin is initialized\n        node.props.parsedRules = parseRules(node.props.validation, availableRules);\n        validate(observedNode, node.props.parsedRules, state);\n    };\n}\n/**\n * Given parsed validations, a value and a node, run the validations and set\n * the appropriate store messages on the node.\n * @param value - The value being validated\n * @param node - The Node this value belongs to\n * @param rules - The rules\n */\nfunction validate(node, validations, state) {\n    state.input = token();\n    state.isPassing = true;\n    node.store.filter((message) => !message.meta.removeImmediately, 'validation');\n    validations.forEach((validation) => validation.debounce && clearTimeout(validation.timer));\n    if (validations.length) {\n        node.store.set(validatingMessage);\n        run(0, validations, node, state, false, () => {\n            node.store.remove(validatingMessage.key);\n        });\n    }\n}\n/**\n * Runs validation rules recursively while collecting dependencies allowing for\n * cross-node validation rules that automatically re-trigger when a foreign\n * value is changed.\n * @param current - The index of the current validation rule\n * @param validations - The remaining validation rule stack to run\n * @param node - An observed node, the owner of this validation stack\n * @param state - An object of state information about this run\n * @param removeImmediately - Should messages created during this call be removed immediately when a new commit takes place?\n * @returns\n */\nfunction run(current, validations, node, state, removeImmediately, complete) {\n    const validation = validations[current];\n    if (!validation)\n        return complete();\n    const currentRun = state.input;\n    validation.state = null;\n    function next(async, result) {\n        state.isPassing = state.isPassing && !!result;\n        validation.queued = false;\n        const newDeps = node.stopObserve();\n        applyListeners(node, diffDeps(validation.deps, newDeps), () => {\n            validation.queued = true;\n            if (state.rerun)\n                clearTimeout(state.rerun);\n            state.rerun = setTimeout(validate, 0, node, validations, state);\n        });\n        validation.deps = newDeps;\n        if (state.input === currentRun) {\n            validation.state = result;\n            if (result === false) {\n                createFailedMessage(node, validation, removeImmediately || async);\n            }\n            else {\n                removeMessage(node, validation);\n            }\n            if (validations.length > current + 1) {\n                run(current + 1, validations, node, state, removeImmediately || async, complete);\n            }\n            else {\n                // The validation has completed\n                complete();\n            }\n        }\n    }\n    if ((!empty(node.value) || !validation.skipEmpty) &&\n        (state.isPassing || validation.force)) {\n        if (validation.queued) {\n            runRule(validation, node, (result) => {\n                result instanceof Promise\n                    ? result.then((r) => next(true, r))\n                    : next(false, result);\n            });\n        }\n        else {\n            // In this case our rule is not queued, so literally nothing happened that\n            // would affect it, we just need to move past this rule and make no\n            // modifications to state\n            run(current + 1, validations, node, state, removeImmediately, complete);\n        }\n    }\n    else {\n        // This rule is not being run because either:\n        //  1. The field is empty and this rule should not run when empty\n        //  2. A previous validation rule is failing and this one is not forced\n        // In this case we should call next validation.\n        if (empty(node.value) && validation.skipEmpty && state.isPassing) {\n            // This node has an empty value so its validation was skipped. So we\n            // need to queue it up, we do that by starting an observation and just\n            // touching the value attribute.\n            node.observe();\n            node.value;\n        }\n        next(false, null);\n    }\n}\n/**\n * Run a validation rule debounced or not.\n * @param validation - A validation to debounce\n */\nfunction runRule(validation, node, after) {\n    if (validation.debounce) {\n        validation.timer = setTimeout(() => {\n            node.observe();\n            after(validation.rule(node, ...validation.args));\n        }, validation.debounce);\n    }\n    else {\n        node.observe();\n        after(validation.rule(node, ...validation.args));\n    }\n}\n/**\n * The messages given to this function have already been set on the node, but\n * any other validation messages on the node that are not included in this\n * stack should be removed because they have been resolved.\n * @param node - The node to operate on.\n * @param messages - A new stack of messages\n */\nfunction removeMessage(node, validation) {\n    const key = `rule_${validation.name}`;\n    if (has(node.store, key)) {\n        node.store.remove(key);\n    }\n}\n/**\n *\n * @param value - The value that is failing\n * @param validation - The validation object\n */\nfunction createFailedMessage(node, validation, removeImmediately) {\n    const i18nArgs = createI18nArgs(node, validation);\n    const customMessage = createCustomMessage(node, validation, i18nArgs);\n    // Here we short circuit the i18n system to force the output.\n    const message = createMessage({\n        blocking: validation.blocking,\n        key: `rule_${validation.name}`,\n        meta: {\n            /**\n             * Use this key instead of the message root key to produce i18n validation\n             * messages.\n             */\n            messageKey: validation.name,\n            /**\n             * For messages that were created *by or after* a debounced or async\n             * validation rule \u2014 we make note of it so we can immediately remove them\n             * as soon as the next commit happens.\n             */\n            removeImmediately,\n            /**\n             * Determines if this message should be passed to localization.\n             */\n            localize: !customMessage,\n            /**\n             * The arguments that will be passed to the validation rules\n             */\n            i18nArgs,\n        },\n        type: 'validation',\n        value: customMessage || 'This field is not valid.',\n    });\n    node.store.set(message);\n    return message;\n}\n/**\n * Returns a custom validation message if applicable.\n * @param node - FormKit Node\n * @param validation - The validation rule being processed.\n */\nfunction createCustomMessage(node, validation, i18nArgs) {\n    const customMessage = node.props.validationMessages &&\n        has(node.props.validationMessages, validation.name)\n        ? node.props.validationMessages[validation.name]\n        : undefined;\n    if (typeof customMessage === 'function') {\n        return customMessage(...i18nArgs);\n    }\n    return customMessage;\n}\n/**\n * Creates the arguments passed to the i18n\n * @param node - The node that performed the validation\n * @param validation - The validation that failed\n */\nfunction createI18nArgs(node, validation) {\n    // If a custom message has been found, short circuit the i18n system.\n    return [\n        {\n            node,\n            name: createMessageName(node),\n            args: validation.args,\n        },\n    ];\n}\n/**\n * The name used in validation messages.\n * @param node - The node to display\n * @returns\n */\nfunction createMessageName(node) {\n    if (typeof node.props.validationLabel === 'function') {\n        return node.props.validationLabel(node);\n    }\n    return (node.props.validationLabel ||\n        node.props.label ||\n        node.props.name ||\n        String(node.name));\n}\n/**\n * Describes hints, must also be changed in the debounceExtractor.\n */\nconst hintPattern = '(?:[\\\\*+?()0-9]+)';\n/**\n * A pattern to describe rule names. Rules names can only contain letters,\n * numbers, and underscores and must start with a letter.\n */\nconst rulePattern = '[a-zA-Z][a-zA-Z0-9_]+';\n/**\n * Regular expression for extracting rule data.\n */\nconst ruleExtractor = new RegExp(`^(${hintPattern}?${rulePattern})(?:\\\\:(.*)+)?$`, 'i');\n/**\n * Validation hints are special characters preceding a validation rule, like\n * !phone\n */\nconst hintExtractor = new RegExp(`^(${hintPattern})(${rulePattern})$`, 'i');\n/**\n * Given a hint string like ^(200)? or ^? or (200)?^ extract the hints to\n * matches.\n */\nconst debounceExtractor = /([\\*+?]+)?(\\(\\d+\\))([\\*+?]+)?/;\n/**\n * Determines if a given string is in the proper debounce format.\n */\nconst hasDebounce = /\\(\\d+\\)/;\n/**\n * The default values of the available validation hints.\n */\nconst defaultHints = {\n    blocking: true,\n    debounce: 0,\n    force: false,\n    skipEmpty: true,\n    name: '',\n};\n/**\n * Parse validation intents and strings into validation rule stacks.\n * @param validation - Either a string a validation rules, or proper array of structured rules.\n * @internal\n */\nfunction parseRules(validation, rules) {\n    if (!validation)\n        return [];\n    const intents = typeof validation === 'string'\n        ? extractRules(validation)\n        : clone(validation);\n    return intents.reduce((validations, args) => {\n        let rule = args.shift();\n        const hints = {};\n        if (typeof rule === 'string') {\n            const [ruleName, parsedHints] = parseHints(rule);\n            if (has(rules, ruleName)) {\n                rule = rules[ruleName];\n                Object.assign(hints, parsedHints);\n            }\n        }\n        if (typeof rule === 'function') {\n            validations.push({\n                rule,\n                args,\n                timer: 0,\n                state: null,\n                queued: true,\n                deps: new Map(),\n                ...defaultHints,\n                ...fnHints(hints, rule),\n            });\n        }\n        return validations;\n    }, []);\n}\n/**\n * A string of validation rules written in FormKitRule notation.\n * @param validation - The string of rules\n * @internal\n */\nfunction extractRules(validation) {\n    return validation.split('|').reduce((rules, rule) => {\n        const parsedRule = parseRule(rule);\n        if (parsedRule) {\n            rules.push(parsedRule);\n        }\n        return rules;\n    }, []);\n}\n/**\n * Given a rule like confirm:password_confirm produce a FormKitValidationIntent\n * @param rule - A string representing a validation rule.\n * @returns\n */\nfunction parseRule(rule) {\n    const trimmed = rule.trim();\n    if (trimmed) {\n        const matches = trimmed.match(ruleExtractor);\n        if (matches && typeof matches[1] === 'string') {\n            const ruleName = matches[1].trim();\n            const args = matches[2] && typeof matches[2] === 'string'\n                ? matches[2].split(',').map((s) => s.trim())\n                : [];\n            return [ruleName, ...args];\n        }\n    }\n    return false;\n}\n/**\n * Given a rule name, detect if there are any additional hints like !\n * @param ruleName - string representing a rule name\n * @returns\n */\nfunction parseHints(ruleName) {\n    const matches = ruleName.match(hintExtractor);\n    if (!matches) {\n        return [ruleName, { name: ruleName }];\n    }\n    const map = {\n        '*': { force: true },\n        '+': { skipEmpty: false },\n        '?': { blocking: false },\n    };\n    const [, hints, rule] = matches;\n    const hintGroups = hasDebounce.test(hints)\n        ? hints.match(debounceExtractor) || []\n        : [, hints];\n    return [\n        rule,\n        [hintGroups[1], hintGroups[2], hintGroups[3]].reduce((hints, group) => {\n            if (!group)\n                return hints;\n            if (hasDebounce.test(group)) {\n                hints.debounce = parseInt(group.substr(1, group.length - 1));\n            }\n            else {\n                group\n                    .split('')\n                    .forEach((hint) => has(map, hint) && Object.assign(hints, map[hint]));\n            }\n            return hints;\n        }, { name: rule }),\n    ];\n}\n/**\n * Extracts hint properties from the validation rule function itself and applies\n * them if they are not already in the set of validation hints extracted from\n * strings.\n * @param existingHints - An existing set of hints already parsed\n * @param rule - The actual rule function, which can contain hint properties\n * @returns\n */\nfunction fnHints(existingHints, rule) {\n    if (!existingHints.name) {\n        existingHints.name = rule.ruleName || rule.name;\n    }\n    return ['skipEmpty', 'force', 'debounce', 'blocking'].reduce((hints, hint) => {\n        if (has(rule, hint) && !has(hints, hint)) {\n            Object.assign(hints, {\n                [hint]: rule[hint],\n            });\n        }\n        return hints;\n    }, existingHints);\n}\n\nexport { createValidationPlugin };\n", "import { has } from '@formkit/utils';\n\n/**\n * Given a string, convert it to sentence case.\n * @param item - The string to sentence case\n * @returns\n * @public\n */\nfunction sentence(str) {\n    return str[0].toUpperCase() + str.substr(1);\n}\n/**\n * Creates an oxford-comma separated list of items.\n * @param args - items to list out\n * @param conjunction - in: x, y, and z \"and\" is the conjunction to use\n * @returns\n * @public\n */\nfunction list(items, conjunction = 'or') {\n    return items.reduce((oxford, item, index) => {\n        oxford += item;\n        if (index <= items.length - 2 && items.length > 2) {\n            oxford += ', ';\n        }\n        if (index === items.length - 2) {\n            oxford += `${items.length === 2 ? ' ' : ''}${conjunction} `;\n        }\n        return oxford;\n    }, '');\n}\n/**\n * Given a string or a date return a nice human-readable version.\n * @param date - A string or a date.\n * @public\n */\nfunction date(date) {\n    const dateTime = typeof date === 'string' ? new Date(Date.parse(date)) : date;\n    if (!(dateTime instanceof Date)) {\n        return '(unknown)';\n    }\n    return new Intl.DateTimeFormat(undefined, {\n        dateStyle: 'medium',\n    }).format(dateTime);\n}\n/**\n * Orders two variables smallest to largest.\n * @param first - first argument\n * @param second - Second argument\n * @returns\n * @public\n */\nfunction order(first, second) {\n    return Number(first) >= Number(second) ? [second, first] : [first, second];\n}\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$l = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '\u0625\u0632\u0627\u0644\u0629',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: '\u0625\u0632\u0627\u0644\u0629 \u0627\u0644\u0643\u0644',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '\u0639\u0630\u0631\u0627\u060C \u0644\u0645 \u064A\u062A\u0645 \u062A\u0639\u0628\u0626\u0629 \u062C\u0645\u064A\u0639 \u0627\u0644\u062D\u0642\u0648\u0644 \u0628\u0634\u0643\u0644 \u0635\u062D\u064A\u062D.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '\u0625\u0631\u0633\u0627\u0644',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: '\u0644\u0627 \u064A\u0648\u062C\u062F \u0645\u0644\u0641 \u0645\u062E\u062A\u0627\u0631',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$l = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `\u0627\u0644\u0631\u062C\u0627\u0621 \u0642\u0628\u0648\u0644 ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0628\u0639\u062F ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0641\u064A \u0627\u0644\u0645\u0633\u062A\u0642\u0628\u0644.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `\u064A\u0645\u0643\u0646 \u0623\u0646 \u064A\u062D\u062A\u0648\u064A ${sentence(name)} \u0639\u0644\u0649 \u0623\u062D\u0631\u0641 \u0623\u0628\u062C\u062F\u064A\u0629 \u0641\u0642\u0637.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `\u064A\u0645\u0643\u0646 \u0623\u0646 \u064A\u062D\u062A\u0648\u064A ${sentence(name)} \u0639\u0644\u0649 \u0623\u062D\u0631\u0641 \u0648\u0623\u0631\u0642\u0627\u0645 \u0641\u0642\u0637.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `\u064A\u0645\u0643\u0646 \u0623\u0646 \u062A\u062D\u062A\u0648\u064A ${sentence(name)} \u0639\u0644\u0649 \u0623\u062D\u0631\u0641 \u0648\u0645\u0633\u0627\u0641\u0627\u062A \u0641\u0642\u0637.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0642\u0628\u0644 ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0641\u064A \u0627\u0644\u0645\u0627\u0636\u064A.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `\u062A\u0645\u062A \u062A\u0647\u064A\u0626\u0629 \u0647\u0630\u0627 \u0627\u0644\u062D\u0642\u0644 \u0628\u0634\u0643\u0644 \u063A\u064A\u0631 \u0635\u062D\u064A\u062D \u0648\u0644\u0627 \u064A\u0645\u0643\u0646 \u0625\u0631\u0633\u0627\u0644\u0647.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0645\u0627 \u0628\u064A\u0646 ${a} \u0648 ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} \u063A\u064A\u0631 \u0645\u062A\u0637\u0627\u0628\u0642.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} \u0644\u064A\u0633 \u062A\u0627\u0631\u064A\u062E\u064B\u0627 \u0635\u0627\u0644\u062D\u064B\u0627 \u060C \u064A\u0631\u062C\u0649 \u0627\u0633\u062A\u062E\u062F\u0627\u0645 \u0627\u0644\u062A\u0646\u0633\u064A\u0642 ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '\u062A\u0645\u062A \u062A\u0647\u064A\u0626\u0629 \u0647\u0630\u0627 \u0627\u0644\u062D\u0642\u0644 \u0628\u0634\u0643\u0644 \u063A\u064A\u0631 \u0635\u062D\u064A\u062D \u0648\u0644\u0627 \u064A\u0645\u0643\u0646 \u0625\u0631\u0633\u0627\u0644\u0647';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0628\u064A\u0646 ${date(args[0])} \u0648 ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '\u0627\u0644\u0631\u062C\u0627\u0621 \u0623\u062F\u062E\u0627\u0644 \u0628\u0631\u064A\u062F \u0625\u0644\u064A\u0643\u062A\u0631\u0648\u0646\u064A \u0635\u0627\u0644\u062D.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `\u0644\u0627 \u064A\u0646\u062A\u0647\u064A ${sentence(name)} \u0628\u0640 ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} \u0644\u064A\u0633\u062A \u0642\u064A\u0645\u0629 \u0645\u0633\u0645\u0648\u062D \u0628\u0647\u0627.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u062D\u0631\u0641\u064B\u0627 \u0648\u0627\u062D\u062F\u064B\u0627 \u0639\u0644\u0649 \u0627\u0644\u0623\u0642\u0644.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0623\u0642\u0644 \u0645\u0646 \u0623\u0648 \u064A\u0633\u0627\u0648\u064A ${max} \u062D\u0631\u0641\u064B\u0627.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0623\u0643\u0628\u0631 \u0645\u0646 \u0623\u0648 \u064A\u0633\u0627\u0648\u064A ${min} \u062D\u0631\u0641\u064B\u0627.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0628\u064A\u0646 ${min} \u0648 ${max} \u062D\u0631\u0641\u064B\u0627.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} \u0644\u064A\u0633\u062A \u0642\u064A\u0645\u0629 \u0645\u0633\u0645\u0648\u062D \u0628\u0647\u0627.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `\u0644\u0627 \u064A\u0645\u0643\u0646 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0623\u0643\u062B\u0631 \u0645\u0646 ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0623\u0642\u0644 \u0645\u0646 \u0623\u0648 \u064A\u0633\u0627\u0648\u064A ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\u0644\u0627 \u064A\u0633\u0645\u062D \u0628\u062A\u0646\u0633\u064A\u0642\u0627\u062A \u0627\u0644\u0645\u0644\u0641\u0627\u062A.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0645\u0646 \u0627\u0644\u0646\u0648\u0639: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `\u0644\u0627 \u064A\u0645\u0643\u0646 \u0623\u0646 \u064A\u0643\u0648\u0646 \u0623\u0642\u0644 \u0645\u0646 ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `\u064A\u062C\u0628 \u0623\u0646 \u064A\u0643\u0648\u0646 ${sentence(name)} \u0639\u0644\u0649 \u0627\u0644\u0623\u0642\u0644 ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D \u0644\u064A\u0633 ${name} \u0645\u0633\u0645\u0648\u062D\u064B\u0627 \u0628\u0647.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} \u064A\u062C\u0628 \u0627\u0646 \u064A\u0643\u0648\u0646 \u0631\u0642\u0645\u0627\u064B`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} \u0645\u0637\u0644\u0648\u0628.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `\u0644\u0627 \u064A\u0628\u062F\u0623 ${sentence(name)} \u0628\u0640 ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `\u0627\u0644\u0631\u062C\u0627\u0621 \u062A\u0636\u0645\u064A\u0646 \u0639\u0646\u0648\u0627\u0646 \u0631\u0627\u0628\u0637 \u0635\u062D\u064A\u062D.`;\n        /* </i18n> */\n    },\n};\n\nvar ar = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$l,\n    validation: validation$l\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$k = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Odebrat',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Odebrat v\u0161e',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Pardon, ale ne v\u0161echna pole jsou vypln\u011Bna spr\u00E1vn\u011B.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Odeslat',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: '\u017D\u00E1dn\u00FD soubor nebyl vybr\u00E1n',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$k = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Pros\u00EDm, za\u0161krtn\u011Bte ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} mus\u00ED b\u00FDt po ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} mus\u00ED b\u00FDt v budoucnosti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} m\u016F\u017Ee obsahovat pouze p\u00EDsmena.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} m\u016F\u017Ee obsahovat pouze p\u00EDsmena a \u010D\u00EDsla.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} mus\u00ED b\u00FDt p\u0159ed ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} mus\u00ED b\u00FDt v minulosti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Toto pole bylo \u0161patn\u011B nakonfigurov\u00E1no a nem\u016F\u017Ee b\u00FDt odesl\u00E1no.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} mus\u00ED b\u00FDt mezi ${a} a ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} nejsou shodn\u00E1.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} nen\u00ED platn\u00E9 datum, pros\u00EDm, pou\u017Eijte form\u00E1t ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Toto pole bylo \u0161patn\u011B nakonfigurov\u00E1no a nem\u016F\u017Ee b\u00FDt odesl\u00E1no.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} mus\u00ED b\u00FDt mezi ${date(args[0])} a ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Pros\u00EDm, zadejte platnou e-mailovou adresu.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} nekon\u010D\u00ED na ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} nen\u00ED povolen\u00E1 hodnota.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} mus\u00ED m\u00EDt nejm\u00E9n\u011B jeden znak.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} m\u016F\u017Ee m\u00EDt maxim\u00E1ln\u011B ${max} znak\u016F.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} mus\u00ED obsahovat minim\u00E1ln\u011B ${min} znak\u016F.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} mus\u00ED b\u00FDt dlouh\u00E9 ${min} a\u017E ${max} znak\u016F.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} nen\u00ED povolen\u00E1 hodnota.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Nelze pou\u017E\u00EDt v\u00EDce ne\u017E ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} mus\u00ED m\u00EDt men\u0161\u00ED nebo rovno ne\u017E ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Nejsou nakonfigurov\u00E1ny povolen\u00E9 typy soubor\u016F.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} mus\u00ED b\u00FDt typu: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Nelze m\u00EDt m\u00E9n\u011B ne\u017E ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} mus\u00ED b\u00FDt minim\u00E1ln\u011B ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D nen\u00ED dovolen\u00E1 hodnota pro ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} mus\u00ED b\u00FDt \u010D\u00EDslo.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} je povinn\u00E9.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} neza\u010D\u00EDn\u00E1 na ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Zadejte, pros\u00EDm, platnou URL adresu.`;\n        /* </i18n> */\n    },\n};\n\nvar cs = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$k,\n    validation: validation$k\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$j = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Fjern',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Fjern alle',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Alle felter er ikke korrekt udfyldt.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Send',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Ingen filer valgt',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$j = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Accepter venligst ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} skal v\u00E6re senere end ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} skal v\u00E6re i fremtiden.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} kan kun indeholde bogstaver.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} kan kun indeholde bogstaver og tal.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} kan kun indeholde bogstaver og mellemrum.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} skal v\u00E6re f\u00F8r ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} skal v\u00E6re f\u00F8r i dag.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Dette felt er ikke konfigureret korrekt og kan derfor ikke blive sendt.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} skal v\u00E6re mellem ${a} og ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} matcher ikke.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} er ikke gyldig, brug venligst formatet ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Dette felt er ikke konfigureret korrekt og kan derfor ikke blive sendt.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} skal v\u00E6re mellem ${date(args[0])} og ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Indtast venligst en gyldig email-adresse.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} slutter ikke med ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} er ikke en gyldig v\u00E6rdi.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} skal v\u00E6re p\u00E5 mindst \u00E9t tegn.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} skal v\u00E6re p\u00E5 h\u00F8jst ${max} tegn.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} skal v\u00E6re p\u00E5 mindst ${min} tegn.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} skal v\u00E6re p\u00E5 mindst ${min} og h\u00F8jst ${max} tegn.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} er ikke en gyldig v\u00E6rdi.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Kan ikke have flere end ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} skal v\u00E6re mindre eller lig med ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Ingen filformater tilladt.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} skal v\u00E6re af filtypen: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Kan ikke have mindre end ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} skal v\u00E6re mindst ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D er ikke en tilladt ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} skal v\u00E6re et tal.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} er p\u00E5kr\u00E6vet.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} starter ikke med ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Indtast venligst en gyldig URL.`;\n        /* </i18n> */\n    },\n};\n\nvar da = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$j,\n    validation: validation$j\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$i = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Entfernen',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Alles entfernen',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Entschuldigung, nicht alle Felder wurden korrekt ausgef\u00FCllt.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Senden',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Keine Datei ausgew\u00E4hlt',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$i = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Bitte ${name} akzeptieren.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} muss nach dem ${date(args[0])} liegen.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} muss in der Zukunft liegen.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} darf nur Buchstaben enthalten.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} darf nur Buchstaben und Zahlen enthalten.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} d\u00FCrfen nur Buchstaben und Leerzeichen enthalten.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} muss vor dem ${date(args[0])} liegen.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} muss in der Vergangenheit liegen.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Dieses Feld wurde falsch konfiguriert und kann nicht \u00FCbermittelt werden.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} muss zwischen ${args[0]} und ${args[1]} sein.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} stimmt nicht \u00FCberein.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} ist kein g\u00FCltiges Datum im Format ${args[0]}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Dieses Feld wurde falsch konfiguriert und kann nicht \u00FCbermittelt werden.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} muss zwischen ${date(args[0])} und ${date(args[1])} liegen.`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'E-Mail Adresse ist ung\u00FCltig.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} endet nicht mit ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} enth\u00E4lt einen ung\u00FCltigen Wert.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} muss mindestens ein Zeichen enthalten.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} darf maximal ${max} Zeichen enthalten.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} muss mindestens ${min} Zeichen enthalten.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} muss zwischen ${min} und ${max} Zeichen enthalten.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} enth\u00E4lt einen ung\u00FCltigen Wert.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Darf maximal ${args[0]} ${name} haben.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} darf maximal ${args[0]} sein.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Keine Dateiformate konfiguriert.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} muss vom Typ ${args[0]} sein.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Mindestens ${args[0]} ${name} erforderlich.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} muss mindestens ${args[0]} sein.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D ist kein g\u00FCltiger Wert f\u00FCr ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} muss eine Zahl sein.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} ist erforderlich.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} beginnt nicht mit ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `URL ist ung\u00FCltig.`;\n        /* </i18n> */\n    },\n};\n\nvar de = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$i,\n    validation: validation$i\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$h = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Remove',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Remove all',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Sorry, not all fields are filled out correctly.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Submit',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'No file chosen',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$h = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Please accept the ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} must be after ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} must be in the future.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} can only contain alphabetical characters.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} can only contain letters and numbers.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} can only contain letters and spaces.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} must be before ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} must be in the past.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `This field was configured incorrectly and can\u2019t be submitted.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} must be between ${a} and ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} does not match.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} is not a valid date, please use the format ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'This field was configured incorrectly and can\u2019t be submitted';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} must be between ${date(args[0])} and ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Please enter a valid email address.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} doesn\u2019t end with ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} is not an allowed value.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} must be at least one character.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} must be less than or equal to ${max} characters.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} must be greater than or equal to ${min} characters.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} must be between ${min} and ${max} characters.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} is not an allowed value.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Cannot have more than ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} must be less than or equal to ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'No file formats allowed.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} must be of the type: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Cannot have less than ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} must be at least ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D is not an allowed ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} must be a number.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} is required.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} doesn\u2019t start with ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Please include a valid url.`;\n        /* </i18n> */\n    },\n};\n\nvar en = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$h,\n    validation: validation$h\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$g = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Quitar',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Quitar todos',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Disc\u00FAlpe, los campos no fueron completados correctamente.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Enviar',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Archivo no seleccionado',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$g = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Acepte el ${name} por favor.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} debe ser posterior a ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} debe ser una fecha futura.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} debe contener solo caract\u00E9res alfab\u00E9ticos.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} debe ser alfanum\u00E9rico.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} espacios alfa solo pueden contener letras y espacios.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} debe ser anterior a ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} debe ser una fecha pasada.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `El campo no fue completado correctamente y no puede ser enviado.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} debe estar entre ${a} y ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} no coincide.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} no es una fecha v\u00E1lida, por favor utilice el formato ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'El campo no fue completado correctamente y no puede ser enviado.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} debe estar entre ${date(args[0])} y ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Ingrese una direcci\u00F3n de correo electr\u00F3nico v\u00E1lida por favor.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} no termina con ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} no es un valor permitido.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} debe tener al menos una letra.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} debe tener como m\u00E1ximo ${max} caract\u00E9res.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} debe tener como m\u00EDnimo ${min} caract\u00E9res.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} debe tener entre ${min} y ${max} caract\u00E9res.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} no es un valor permitido.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Cannot have more than ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} debe ser menor o igual a ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'No existen formatos de archivos permitidos.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} debe ser del tipo: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Cannot have less than ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} debe ser de al menos ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D no es un valor permitido de ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} debe ser un n\u00FAmero.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} es requerido.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} debe comenzar con ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Proporcione una URL v\u00E1lida por favor.`;\n        /* </i18n> */\n    },\n};\n\nvar es = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$g,\n    validation: validation$g\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$f = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '\u062D\u0630\u0641',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: '\u0647\u0645\u0647 \u0631\u0627 \u062D\u0630\u0641 \u06A9\u0646\u06CC\u062F',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '\u0647\u0645\u0647 \u0641\u06CC\u0644\u062F\u0647\u0627 \u0628\u0647\u200C\u062F\u0631\u0633\u062A\u06CC \u067E\u0631 \u0646\u0634\u062F\u0647\u200C\u0627\u0646\u062F',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '\u062B\u0628\u062A',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: '\u0647\u06CC\u0686 \u0641\u0627\u06CC\u0644\u06CC \u0627\u0646\u062A\u062E\u0627\u0628 \u0646\u0634\u062F\u0647 \u0627\u0633\u062A',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$f = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `\u0644\u0637\u0641\u0627\u064B ${name} \u0631\u0627 \u0628\u067E\u0630\u06CC\u0631\u06CC\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u0639\u062F \u0627\u0632 \u062A\u0627\u0631\u06CC\u062E ${date(args[0])} \u0628\u0627\u0634\u062F.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0645\u0631\u0628\u0648\u0637 \u0628\u0647 \u0622\u06CC\u0646\u062F\u0647 \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} \u0641\u0642\u0637 \u0645\u06CC\u062A\u0648\u0627\u0646\u062F \u0634\u0627\u0645\u0644 \u062D\u0631\u0648\u0641 \u0627\u0644\u0641\u0628\u0627 \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} \u0641\u0642\u0637 \u0645\u06CC\u062A\u0648\u0627\u0646\u062F \u0634\u0627\u0645\u0644 \u062D\u0631\u0648\u0641 \u0648 \u0627\u0639\u062F\u0627\u062F \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} \u0641\u0642\u0637 \u0645\u06CC \u062A\u0648\u0627\u0646\u062F \u0634\u0627\u0645\u0644 \u062D\u0631\u0648\u0641 \u0648 \u0641\u0627\u0635\u0644\u0647 \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0642\u0628\u0644 \u0627\u0632 \u062A\u0627\u0631\u06CC\u062E ${date(args[0])} \u0628\u0627\u0634\u062F.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0645\u0631\u0628\u0648\u0637 \u0628\u0647 \u06AF\u0630\u0634\u062A\u0647 \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `\u0627\u06CC\u0646 \u0641\u06CC\u0644\u062F \u0628\u0647 \u0627\u0634\u062A\u0628\u0627\u0647 \u067E\u06CC\u06A9\u0631\u0628\u0646\u062F\u06CC \u0634\u062F\u0647 \u0627\u0633\u062A \u0648 \u0642\u0627\u0628\u0644 \u0627\u0631\u0633\u0627\u0644 \u0646\u06CC\u0633\u062A`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u06CC\u0646 ${args[0]} \u0648 ${args[1]} \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} \u0645\u0637\u0627\u0628\u0642\u062A \u0646\u062F\u0627\u0631\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} \u062A\u0627\u0631\u06CC\u062E \u0645\u0639\u062A\u0628\u0631\u06CC \u0646\u06CC\u0633\u062A\u060C \u0644\u0637\u0641\u0627\u064B \u0627\u0632 \u0642\u0627\u0644\u0628 ${args[0]} \u0627\u0633\u062A\u0641\u0627\u062F\u0647 \u06A9\u0646\u06CC\u062F\n`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '\u0627\u06CC\u0646 \u0641\u06CC\u0644\u062F \u0628\u0647 \u0627\u0634\u062A\u0628\u0627\u0647 \u067E\u06CC\u06A9\u0631\u0628\u0646\u062F\u06CC \u0634\u062F\u0647 \u0627\u0633\u062A \u0648 \u0642\u0627\u0628\u0644 \u0627\u0631\u0633\u0627\u0644 \u0646\u06CC\u0633\u062A';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u06CC\u0646 ${date(args[0])} \u0648 ${date(args[1])} \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '\u0644\u0637\u0641\u0627 \u0622\u062F\u0631\u0633 \u0627\u06CC\u0645\u06CC\u0644 \u0645\u0639\u062A\u0628\u0631 \u0648\u0627\u0631\u062F \u06A9\u0646\u06CC\u062F.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u0647 ${list(args)} \u062E\u062A\u0645 \u0634\u0648\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} \u0645\u062C\u0627\u0632 \u0646\u06CC\u0633\u062A.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} \u0628\u0627\u06CC\u062F \u062D\u062F\u0627\u0642\u0644 \u06CC\u06A9 \u06A9\u0627\u0631\u0627\u06A9\u062A\u0631 \u0628\u0627\u0634\u062F.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} \u0628\u0627\u06CC\u062F \u06A9\u0645\u062A\u0631 \u06CC\u0627 \u0628\u0631\u0627\u0628\u0631 \u0628\u0627 ${max} \u06A9\u0627\u0631\u0627\u06A9\u062A\u0631 \u0628\u0627\u0634\u062F.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u0632\u0631\u06AF\u062A\u0631 \u06CC\u0627 \u0628\u0631\u0627\u0628\u0631 \u0628\u0627 ${min} \u06A9\u0627\u0631\u0627\u06A9\u062A\u0631 \u0628\u0627\u0634\u062F.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u06CC\u0646 ${min} \u0648 ${max} \u06A9\u0627\u0631\u0627\u06A9\u062A\u0631 \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} \u0645\u062C\u0627\u0632 \u0646\u06CC\u0633\u062A.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${name} \u0646\u0645\u06CC \u062A\u0648\u0627\u0646\u062F \u0628\u06CC\u0634 \u0627\u0632 ${args[0]} \u0628\u0627\u0634\u062F.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u06A9\u0645\u062A\u0631 \u06CC\u0627 \u0628\u0631\u0627\u0628\u0631 \u0628\u0627 ${args[0]} \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\u0641\u0631\u0645\u062A \u0641\u0627\u06CC\u0644 \u0645\u062C\u0627\u0632 \u0646\u06CC\u0633\u062A.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0627\u0632 \u0627\u06CC\u0646 \u0646\u0648\u0639 \u0628\u0627\u0634\u062F: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${name} \u0646\u0645\u06CC \u062A\u0648\u0627\u0646\u062F \u06A9\u0645\u062A\u0631 \u0627\u0632 ${args[0]} \u0628\u0627\u0634\u062F.\n`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u062D\u062F\u0627\u0642\u0644 ${args[0]} \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\"${value}\" \u06CC\u06A9 ${name} \u0645\u062C\u0627\u0632 \u0646\u06CC\u0633\u062A.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0639\u062F\u062F \u0628\u0627\u0634\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `\u067E\u0631 \u06A9\u0631\u062F\u0646 ${sentence(name)} \u0627\u062C\u0628\u0627\u0631\u06CC \u0627\u0633\u062A.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} \u0628\u0627\u06CC\u062F \u0628\u0627 ${list(args)} \u0634\u0631\u0648\u0639 \u0634\u0648\u062F.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `\u0644\u0637\u0641\u0627\u064B \u0622\u062F\u0631\u0633 \u0627\u06CC\u0646\u062A\u0631\u0646\u062A\u06CC \u0645\u0639\u062A\u0628\u0631 \u0648\u0627\u0631\u062F \u06A9\u0646\u06CC\u062F.`;\n        /* </i18n> */\n    },\n};\n\nvar fa = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$f,\n    validation: validation$f\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$e = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Poista',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Poista kaikki',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Kaikkia kentti\u00E4 ei ole t\u00E4ytetty oikein.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Tallenna',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Ei valittuja tiedostoja',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$e = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Ole hyv\u00E4 ja hyv\u00E4ksy ${name}`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} tulee olla ${date(args[0])} j\u00E4lkeen.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} on oltava tulevaisuudessa.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} saa sis\u00E4lt\u00E4\u00E4 vain kirjaimia.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} saa sis\u00E4lt\u00E4\u00E4 vain kirjaimia ja numeroita.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} voivat sis\u00E4lt\u00E4\u00E4 vain kirjaimia ja v\u00E4lily\u00F6ntej\u00E4.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} tulee olla ennen: ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} on oltava menneisyydess\u00E4.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `T\u00E4m\u00E4 kentt\u00E4 on t\u00E4ytetty virheellisesti joten sit\u00E4 ei voitu l\u00E4hett\u00E4\u00E4.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} on oltava v\u00E4lill\u00E4 ${a} - ${b} `;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} ei t\u00E4sm\u00E4\u00E4.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} ei ole validi p\u00E4iv\u00E4m\u00E4\u00E4r\u00E4, ole hyv\u00E4 ja sy\u00F6t\u00E4 muodossa: ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'T\u00E4m\u00E4 kentt\u00E4 on t\u00E4ytetty virheellisesti joten sit\u00E4 ei voitu l\u00E4hett\u00E4\u00E4.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} on oltava v\u00E4lill\u00E4 ${date(args[0])} - ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Sy\u00F6t\u00E4 validi s\u00E4hk\u00F6postiosoite.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} tulee p\u00E4\u00E4tty\u00E4 ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} ei ole sallittu vaihtoehto.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} on oltava v\u00E4hint\u00E4\u00E4n yksi merkki.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} on oltava ${max} tai alle merkki\u00E4.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} on oltava v\u00E4hint\u00E4\u00E4n ${min} merkki\u00E4.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} on oltava v\u00E4hint\u00E4\u00E4n ${min}, enint\u00E4\u00E4n ${max} merkki\u00E4.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} ei ole sallittu arvo.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Valitse enint\u00E4\u00E4n ${args[0]} ${name} vaihtoehtoa.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} on oltava ${args[0]} tai alle.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Tiedostoja ei sallita.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} tulee olla ${args[0]}-tiedostotyyppi\u00E4.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Valitse v\u00E4hint\u00E4\u00E4n ${args[0]} ${name} vaihtoehtoa.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} tulee olla ${args[0]} tai suurempi.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D ei ole sallittu ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `Kent\u00E4n ${sentence(name)} tulee olla numero.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} vaaditaan.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} on alettava ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Sy\u00F6t\u00E4 validi url-osoite.`;\n        /* </i18n> */\n    },\n};\n\nvar fi = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$e,\n    validation: validation$e\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$d = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Supprimer',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Enlever tout',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'D\u00E9sol\u00E9, tous les champs ne sont pas remplis correctement.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Valider',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Aucun fichier choisi',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$d = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Veuillez accepter le ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} doit \u00EAtre post\u00E9rieure au ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} doit \u00EAtre dans le futur.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} ne peut contenir que des caract\u00E8res alphab\u00E9tiques.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} ne peut contenir que des lettres et des chiffres.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} ne peuvent contenir que des lettres et des espaces.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} doit \u00EAtre ant\u00E9rieure au ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} doit \u00EAtre dans le pass\u00E9.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Ce champ a \u00E9t\u00E9 configur\u00E9 de mani\u00E8re incorrecte et ne peut pas \u00EAtre soumis.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} doit \u00EAtre comprise entre ${a} et ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} ne correspond pas.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} n'est pas une date valide, veuillez utiliser le format ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Ce champ a \u00E9t\u00E9 configur\u00E9 de mani\u00E8re incorrecte et ne peut pas \u00EAtre soumis.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} doit \u00EAtre comprise entre ${date(args[0])} et ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Veuillez saisir une adresse email valide.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ne se termine pas par ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} n'est pas une valeur autoris\u00E9e.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} doit comporter au moins un caract\u00E8re.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} doit \u00EAtre inf\u00E9rieur ou \u00E9gal \u00E0 ${max} caract\u00E8res.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} doit \u00EAtre sup\u00E9rieur ou \u00E9gal \u00E0 ${min} caract\u00E8res.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} doit \u00EAtre comprise entre ${min} et ${max} caract\u00E8res.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} n'est pas une valeur autoris\u00E9e.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Ne peut pas avoir plus de ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} doit \u00EAtre inf\u00E9rieur ou \u00E9gal \u00E0 ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Aucun format de fichier n\u2019est autoris\u00E9';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} doit \u00EAtre du type: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Ne peut pas avoir moins de ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} doit \u00EAtre au moins de ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D n'est pas un ${name} autoris\u00E9.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} doit \u00EAtre un nombre.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} est requis.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ne commence pas par ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Veuillez saisir une url valide.`;\n        /* </i18n> */\n    },\n};\n\nvar fr = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$d,\n    validation: validation$d\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$c = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Ferwider',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Ferwider alles',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Sorry, net alle fjilden binne korrekt ynfolle.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Ferstjoere',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Gjin best\u00E2n keazen',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$c = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Akseptearje de ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} moat nei ${date(args[0])} w\u00EAze.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} moat yn de takomst lizze.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} mei allinne alfabetyske tekens befetsje.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} mei allinne letters en sifers befetsje.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} moat foar ${date(args[0])} falle.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} moat yn it ferline w\u00EAze.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Dit fjild is ferkeard konfigurearre en kin net ferstjoerd wurde.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} moat tusken ${a} en ${b} lizze.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} komt net oerien.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} is gjin jildige datum, br\u00FBk de notaasje ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Dit fjild is ferkeard konfigurearre en kin net ferstjoerd wurde';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} moat tusken ${date(args[0])} en ${date(args[1])} lizze`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Folje in jildich e-mailadres yn.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} einiget net mei ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} is gjin tastiene wearde.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} moat minimaal ien teken w\u00EAze.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} moat lytser w\u00EAze as of gelyk w\u00EAze oan ${max} tekens.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} moat grutter w\u00EAze as of gelyk w\u00EAze oan ${min} tekens.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} moat tusken de ${min} en ${max} tekens befetsje.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} is gjin tastiene wearde.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Mei net mear as ${args[0]} ${name} hawwe.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} moat lytser w\u00EAze as of gelyk w\u00EAze oan ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Gjin best\u00E2nsnotaasjes tastien.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} moat fan it type: ${args[0]} w\u00EAze`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Mei net minder as ${args[0]} ${name} hawwe.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} moat minimaal ${args[0]} w\u00EAze.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\"${value}\" is gjin tastiene ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} moat in getal w\u00EAze.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} is ferplicht.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} begjint net mei ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Doch der in jildige url by.`;\n        /* </i18n> */\n    },\n};\n\nvar fy = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$c,\n    validation: validation$c\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$b = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '\u05DE\u05D7\u05E7',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '\u05E9\u05D9\u05DD \u05DC\u05D1, \u05DC\u05D0 \u05DB\u05DC \u05D4\u05E9\u05D3\u05D5\u05EA \u05DE\u05DC\u05D0\u05D9\u05DD \u05DB\u05E8\u05D0\u05D5\u05D9.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '\u05E9\u05DC\u05D7',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$b = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `\u05D0\u05E0\u05D0 \u05D0\u05E9\u05E8 \u05D0\u05EA ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05D0\u05D7\u05E8\u05D9 ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05D1\u05E2\u05EA\u05D9\u05D3.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05DB\u05D9\u05DC \u05D0\u05D5\u05EA\u05D9\u05D5\u05EA \u05D0\u05DC\u05E4\u05D1\u05EA.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05DB\u05D9\u05DC \u05E8\u05E7 \u05DE\u05E1\u05E4\u05E8\u05D9\u05DD \u05D5\u05D0\u05D5\u05EA\u05D9\u05D5\u05EA.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05DB\u05D9\u05DC \u05E8\u05E7 \u05D0\u05D5\u05EA\u05D9\u05D5\u05EA \u05D5\u05E8\u05D5\u05D5\u05D7\u05D9\u05DD.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DC\u05E4\u05E0\u05D9 ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05D1\u05E2\u05D1\u05E8`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `\u05E9\u05D3\u05D4 \u05D6\u05D4 \u05DC\u05D0 \u05D4\u05D5\u05D2\u05D3\u05E8 \u05DB\u05E8\u05D0\u05D5\u05D9 \u05D5\u05DC\u05D0 \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05D9\u05E9\u05DC\u05D7.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05D1\u05D9\u05DF ${args[0]} \u05D5-${args[1]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} \u05DC\u05D0 \u05DE\u05EA\u05D0\u05D9\u05DD.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} \u05D4\u05D5\u05D0 \u05DC\u05D0 \u05EA\u05D0\u05E8\u05D9\u05DA \u05EA\u05E7\u05D9\u05DF, \u05D0\u05E0\u05D0 \u05D4\u05E9\u05EA\u05DE\u05E9 \u05D1\u05E4\u05D5\u05E8\u05DE\u05D8 ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '\u05E9\u05D3\u05D4 \u05D6\u05D4 \u05DC\u05D0 \u05D4\u05D5\u05D2\u05D3\u05E8 \u05DB\u05E8\u05D0\u05D5\u05D9 \u05D5\u05DC\u05D0 \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05D9\u05E9\u05DC\u05D7.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05D1\u05D9\u05DF ${date(args[0])} \u05D5- ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '\u05D0\u05E0\u05D0 \u05D4\u05E7\u05DC\u05D3 \u05D0\u05D9\u05DE\u05D9\u05D9\u05DC \u05EA\u05E7\u05D9\u05DF.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} \u05DC\u05D0 \u05DE\u05E1\u05EA\u05D9\u05D9\u05DD \u05D1- ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} \u05D4\u05D5\u05D0 \u05DC\u05D0 \u05E2\u05E8\u05DA \u05DE\u05D5\u05E8\u05E9\u05D4.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DC\u05E4\u05D7\u05D5\u05EA \u05EA\u05D5 \u05D0\u05D7\u05D3.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05E4\u05D7\u05D5\u05EA \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC- ${max} \u05EA\u05D5\u05D5\u05D9\u05DD.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D9\u05D5\u05EA \u05D2\u05D3\u05D5\u05DC \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC- ${min} \u05EA\u05D5\u05D5\u05D9\u05DD.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05D1\u05D9\u05DF ${min} \u05D5- ${max} \u05EA\u05D5\u05D5\u05D9\u05DD.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} \u05D4\u05D5\u05D0 \u05DC\u05D0 \u05E2\u05E8\u05DA \u05EA\u05E7\u05D9\u05DF.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${name} \u05DC\u05D0 \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05D9\u05D5\u05EA \u05E2\u05DD \u05D9\u05D5\u05EA\u05E8 \u05DE- ${args[0]}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05E4\u05D7\u05D5\u05EA \u05D0\u05D5 \u05E9\u05D5\u05D5\u05D4 \u05DC- ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\u05E4\u05D5\u05E8\u05DE\u05D8 \u05D4\u05E7\u05D5\u05D1\u05E5 \u05DC\u05D0 \u05DE\u05D5\u05E8\u05E9\u05D4.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05E1\u05D5\u05D2: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${name} \u05DC\u05D0 \u05D9\u05DB\u05D5\u05DC \u05DC\u05D4\u05D9\u05D5\u05EA \u05E2\u05DD \u05E4\u05D7\u05D5\u05EA \u05DE- ${args[0]}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DC\u05E4\u05D7\u05D5\u05EA ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D \u05DC\u05D0 \u05DE\u05EA\u05D0\u05D9\u05DD \u05DC- ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} \u05D7\u05D9\u05D9\u05D1 \u05DC\u05D4\u05D9\u05D5\u05EA \u05DE\u05E1\u05E4\u05E8.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} \u05D4\u05D9\u05E0\u05D5 \u05D7\u05D5\u05D1\u05D4.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} \u05DC\u05D0 \u05DE\u05EA\u05D7\u05D9\u05DC \u05D1- ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `\u05D0\u05E0\u05D0 \u05D4\u05E7\u05DC\u05D3 \u05E7\u05D9\u05E9\u05D5\u05E8 \u05EA\u05E7\u05D9\u05DF.`;\n        /* </i18n> */\n    },\n};\n\nvar he = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$b,\n    validation: validation$b\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$a = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Ukloni',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Pojedina polja nisu ispravno ispunjena.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Predaj',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$a = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Potrebno je potvrditi ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} mora biti u periodu poslije ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} mora biti u budu\u0107nosti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} mora sadr\u017Eavati samo slova.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} mora sadr\u017Eavati slova i brojeve.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} mogu sadr\u017Eavati samo slova i razmake..`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} mora biti prije ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} mora biti u pro\u0161losti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Format sadr\u017Eaja nije ispravan i ne mo\u017Ee biti predan.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} mora biti izme\u0111u ${args[0]} i ${args[1]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} ne odgovara zadanoj vrijednosti.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} nije ispravan format datuma. Molimo koristite sljede\u0107i format: ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Ovo polje nije ispravno postavljeno i ne mo\u017Ee biti predano.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} mora biti vrijednost izme\u0111u ${date(args[0])} i ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Molimo upi\u0161ite ispravnu email adresu.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ne zavr\u0161ava s ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} nije dopu\u0161tena vrijednost.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} mora sadr\u017Eavati barem jedan znak.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} mora imati ${max} ili manje znakova.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} mora imati barem ${min} znakova.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `Broj znakova za polje ${sentence(name)} mora biti izme\u0111u ${min} i ${max}.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} nije dozvoljena vrijednost.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Ne smije imati vi\u0161e od ${args[0]} ${name} polja.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} mora imati vrijednost manju ili jednaku ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Format datoteke nije dozvoljen.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `Format datoteke na polju ${sentence(name)} mora odgovarati: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Broj upisanih vrijednosti na polju ${name} mora biti barem ${args[0]}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} mora biti barem ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D nije dozvoljena vrijednost na polju ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} mora biti broj.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} je obavezno.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ne po\u010Dinje s ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Molimo unesite ispravnu poveznicu.`;\n        /* </i18n> */\n    },\n};\n\nvar hr = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$a,\n    validation: validation$a\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$9 = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '\uC81C\uAC70',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: '\uBAA8\uB450 \uC81C\uAC70',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '\uBAA8\uB4E0 \uAC12\uC744 \uCC44\uC6CC\uC8FC\uC138\uC694',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '\uC81C\uCD9C\uD558\uAE30',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: '\uC120\uD0DD\uB41C \uD30C\uC77C\uC774 \uC5C6\uC2B5\uB2C8\uB2E4',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$9 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `${name} \uC62C\uBC14\uB978 \uAC12\uC744 \uC120\uD0DD \uD574\uC8FC\uC138\uC694`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} ${date(args[0])} \uC774\uD6C4\uC5EC\uC57C \uD569\uB2C8\uB2E4`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \uBBF8\uB798\uC758 \uB0A0\uC9DC\uC5EC\uC57C\uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} \uC54C\uD30C\uBCB3 \uBB38\uC790\uB9CC \uD3EC\uD568\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} \uBB38\uC790\uC640 \uC22B\uC790\uB9CC \uD3EC\uD568\uB420 \uC218 \uC788\uC2B5\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} \uBB38\uC790\uC640 \uACF5\uBC31\uB9CC \uD3EC\uD568\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} ${date(args[0])} \uC774\uC804\uC5EC\uC57C \uD569\uB2C8\uB2E4`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} \uACFC\uAC70\uC758 \uB0A0\uC9DC\uC5EC\uC57C\uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `\uC798\uBABB\uB41C \uAD6C\uC131\uC73C\uB85C \uC81C\uCD9C\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} ${a}\uC640 ${b} \uC0AC\uC774\uC5EC\uC57C \uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} \uC77C\uCE58\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} \uC720\uD6A8\uD55C \uB0A0\uC9DC\uAC00 \uC544\uB2D9\uB2C8\uB2E4. ${args[0]}\uACFC \uAC19\uC740 \uD615\uC2DD\uC744 \uC0AC\uC6A9\uD574\uC8FC\uC138\uC694`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '\uC798\uBABB\uB41C \uAD6C\uC131\uC73C\uB85C \uC81C\uCD9C\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} ${date(args[0])}\uC5D0\uC11C ${date(args[1])} \uC0AC\uC774\uC5EC\uC57C \uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '\uC62C\uBC14\uB978 \uC774\uBA54\uC77C \uC8FC\uC18C\uB97C \uC785\uB825\uD574\uC8FC\uC138\uC694',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ${list(args)}\uB85C \uB05D\uB098\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} \uD5C8\uC6A9\uB418\uB294 \uAC12\uC774 \uC544\uB2D9\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} \uD558\uB098 \uC774\uC0C1\uC758 \uBB38\uC790\uC5EC\uC57C \uD569\uB2C8\uB2E4`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} ${max}\uC790 \uC774\uD558\uC5EC\uC57C \uD569\uB2C8\uB2E4`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} ${min} \uBB38\uC790\uBCF4\uB2E4 \uD06C\uAC70\uB098 \uAC19\uC544\uC57C \uD569\uB2C8\uB2E4`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} ${min}\uC5D0\uC11C ${max}\uC790 \uC0AC\uC774\uC5EC\uC57C \uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} \uD5C8\uC6A9\uB418\uB294 \uAC12\uC774 \uC544\uB2D9\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${args[0]} ${name} \uCD08\uACFC\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} ${args[0]}\uBCF4\uB2E4 \uC791\uAC70\uB098 \uAC19\uC544\uC57C \uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\uD30C\uC77C \uD615\uC2DD\uC774 \uD5C8\uC6A9\uB418\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} ${args[0]} \uC720\uD615\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${args[0]} ${name}\uBCF4\uB2E4 \uC791\uC744 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} ${args[0]} \uC774\uC0C1\uC774\uC5B4\uC57C \uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `${value}\" \uD5C8\uC6A9\uB418\uC9C0 \uC54A\uB294 ${name}\uC785\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} \uC22B\uC790\uC5EC\uC57C \uD569\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} \uD544\uC218 \uAC12\uC785\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ${list(args)}\uB85C \uC2DC\uC791\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `\uC62C\uBC14\uB978 URL\uC744 \uC785\uB825\uD574\uC8FC\uC138\uC694`;\n        /* </i18n> */\n    },\n};\n\nvar ko = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$9,\n    validation: validation$9\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$8 = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Hapus',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Hapus semua',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Maaf, tidak semua bidang formulir terisi dengan benar',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Kirim',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Tidak ada file yang dipilih',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$8 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Tolong terima kolom ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} nilainya harus lebih dari waktu ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} harus berisi waktu di masa depan.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} hanya bisa diisi huruf alfabet.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} hanya bisa diisi huruf dan angka.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} hanya boleh berisi huruf dan spasi..`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} nilainya harus kurang dari waktu ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} harus berisi waktu yang sudah lampau.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Kolom ini tidak diisi dengan benar sehingga tidak bisa dikirim`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} harus bernilai diantara ${a} dan ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} nilainya tidak cocok.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} waktu tidak cocok, mohon gunakan format waktu ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Kolom ini tidak diisi dengan benar sehingga tidak bisa dikirim';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} harus diantara waktu ${date(args[0])} dan waktu ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Tolong tulis alamat email yang benar.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} nilainya tidak berakhiran dengan ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} adalah nilai yang tidak diizinkan.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} nilainya setidaknya berisi satu karakter.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} jumlah karakternya harus kurang dari atau sama dengan ${max} karakter.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} jumlah karakternya harus lebih dari atau sama dengan ${min} karakter.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} jumlah karakternya hanya bisa antara ${min} dan ${max} karakter.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} nilainya tidak diizinkan.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Tidak bisa memiliki lebih dari ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} harus lebih kecil atau sama dengan ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Format file tidak diizinkan';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} hanya bisa bertipe: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Tidak boleh kurang dari ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} setidaknya harus berisi ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D adalah nilai yang tidak diperbolehkan untuk ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} harus berupa angka.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} harus diisi.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} tidak dimulai dengan ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Mohon tuliskan url yang benar.`;\n        /* </i18n> */\n    },\n};\n\nvar id = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$8,\n    validation: validation$8\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$7 = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Rimuovi',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Rimuovi tutti',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Ci dispiace, non tutti i campi sono compilati correttamente.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Invia',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Nessun file selezionato',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$7 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Si prega di accettare ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `la data ${sentence(name)} deve essere successiva ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `la data ${sentence(name)} deve essere nel futuro.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} pu\u00F2 contenere solo caratteri alfanumerici.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} pu\u00F2 contenere solo lettere e numeri.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} pu\u00F2 contenere solo lettere e spazi.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `la data ${sentence(name)} deve essere antecedente ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} deve essere nel passato.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Questo campo \u00E8 stato configurato male e non pu\u00F2 essere inviato.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} deve essere tra ${a} e ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} non corrisponde.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} non \u00E8 una data valida, per favore usa il formato ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Questo campo \u00E8 stato configurato in modo errato e non pu\u00F2 essere inviato.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} deve essere tra ${date(args[0])} e ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Per favore inserire un indirizzo email valido.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} non termina con ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} non \u00E8 un valore consentito.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} deve contenere almeno un carattere.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} deve essere minore o uguale a ${max} caratteri.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} deve essere maggiore o uguale a ${min} caratteri.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} deve essere tra ${min} e ${max} caratteri.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} non \u00E8 un valore consentito.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Non pu\u00F2 avere pi\u00F9 di ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} deve essere minore o uguale a ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Formato file non consentito.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} deve essere di tipo: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Non pu\u00F2 avere meno di ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} deve essere almeno ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\"${value}\" non \u00E8 un ${name} consentito.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} deve essere un numero.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} \u00E8 richiesto.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} non inizia con ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Per favore utilizare un url valido.`;\n        /* </i18n> */\n    },\n};\n\nvar it = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$7,\n    validation: validation$7\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$6 = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Verwijder',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Verwijder alles',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Sorry, niet alle velden zijn correct ingevuld.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Versturen',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Geen bestand gekozen',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$6 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Accepteer de ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} moet na ${date(args[0])} zijn.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} moet in de toekomst liggen.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} mag alleen alfabetische tekens bevatten.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} mag alleen letters en cijfers bevatten.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} kunnen alleen letters en spaties bevatten.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} moet v\u00F3\u00F3r ${date(args[0])} vallen.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} moet in het verleden zijn.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Dit veld is onjuist geconfigureerd en kan niet worden verzonden.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} moet tussen ${a} en ${b} liggen.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} komt niet overeen.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} is geen geldige datum, gebruik de notatie ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Dit veld is onjuist geconfigureerd en kan niet worden verzonden';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} moet tussen ${date(args[0])} en ${date(args[1])} liggen`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Vul een geldig e-mailadres in.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} eindigt niet met ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} is geen toegestane waarde.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} moet minimaal \u00E9\u00E9n teken zijn.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} moet kleiner zijn dan of gelijk zijn aan ${max} tekens.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} moet groter zijn dan of gelijk zijn aan ${min} tekens.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} moet tussen de ${min} en ${max} tekens bevatten.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} is geen toegestane waarde.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Mag niet meer dan ${args[0]} ${name} hebben.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} moet kleiner zijn dan of gelijk zijn aan ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Geen bestandsformaten toegestaan.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} moet van het type: ${args[0]} zijn`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Mag niet minder dan ${args[0]} ${name} hebben.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} moet minimaal ${args[0]} zijn.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\"${value}\" is geen toegestane ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} moet een getal zijn.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} is verplicht.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} begint niet met ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Voeg een geldige url toe.`;\n        /* </i18n> */\n    },\n};\n\nvar nl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$6,\n    validation: validation$6\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$5 = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Usu\u0144',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Usu\u0144 wszystko',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Nie wszystkie pola zosta\u0142y wype\u0142nione poprawnie.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Wy\u015Blij',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Nie wybrano pliku',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$5 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Prosz\u0119 zaakceptowa\u0107 ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} musi by\u0107 po ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} musi by\u0107 w przysz\u0142o\u015Bci.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} mo\u017Ce tylko zawiera\u0107 znaki alfabetyczne.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} mo\u017Ce tylko zawiera\u0107 znaki alfanumeryczne.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} mog\u0105 zawiera\u0107 tylko litery i spacje.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} musi by\u0107 przed ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} musi by\u0107 w przesz\u0142o\u015Bci.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Pole zosta\u0142o wype\u0142nione niepoprawnie i nie mo\u017Ce zosta\u0107 wys\u0142ane.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} musi by\u0107 pomi\u0119dzy ${a} i ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} nie zgadza si\u0119.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} nie jest poprawn\u0105 dat\u0105, prosz\u0119 u\u017Cy\u0107 formatu ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'To pole zosta\u0142o wype\u0142nione niepoprawnie i nie mo\u017Ce zosta\u0107 wys\u0142ane';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} musi by\u0107 pomi\u0119dzy ${date(args[0])} i ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Prosz\u0119 wpisa\u0107 poprawny adres email.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} nie ko\u0144czy si\u0119 na ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} nie jest dozwolon\u0105 warto\u015Bci\u0105.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} musi posiada\u0107 minimum jeden znak.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} musi zawiera\u0107 ${max} lub mniej znak\u00F3w.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} musi zawiera\u0107 ${min} lub wi\u0119cej znak\u00F3w.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} musi mie\u0107 ${min}-${max} znak\u00F3w.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} nie jest dozwolon\u0105 warto\u015Bci\u0105.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `Nie mo\u017Cna mie\u0107 wi\u0119cej ni\u017C ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} musi by\u0107 mniejsze lub r\u00F3wne ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Nie podano dozwolonych typ\u00F3w plik\u00F3w.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} musi by\u0107 typem: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `Musisz poda\u0107 wi\u0119cej ni\u017C ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return ` Musisz poda\u0107 conajmniej ${args[0]} ${sentence(name)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D nie jest dozwolonym ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} musi by\u0107 numerem.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} jest wymagany.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} nie zaczyna si\u0119 od ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Prosz\u0119 poda\u0107 prawid\u0142owy adres url.`;\n        /* </i18n> */\n    },\n};\n\nvar pl = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$5,\n    validation: validation$5\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$4 = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Remover',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Deletar tudo',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Desculpe, nem todos os campos foram preenchidos corretamente.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'Enviar',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Nenhum arquivo',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$4 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `Por favor aceite o ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} deve ser posterior a ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} deve ser no futuro.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} s\u00F3 pode conter caracteres do alfabeto.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} s\u00F3 pode ter letras e n\u00FAmeros.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} s\u00F3 podem conter letras e espa\u00E7os.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} deve ser anterior a ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} deve ser anterior a data atual.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `O campo foi configurado incorretamente e n\u00E3o pode ser enviado.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} deve estar entre ${args[0]} e ${args[1]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} n\u00E3o confere.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} n\u00E3o \u00E9 uma data v\u00E1lida, por favor use o formato ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'O campo foi configurado incorretamente e n\u00E3o pode ser enviado.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} deve ser entre ${date(args[0])} e ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'Por favor informe um e-mail v\u00E1lido.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} n\u00E3o termina com ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} n\u00E3o \u00E9 um valor permitido.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} deve ter ao menos um caractere.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} n\u00E3o pode ter mais que ${max} caracteres.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} deve ter no m\u00EDnimo ${min} caracteres.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} deve ter entre ${min} e ${max} caracteres.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} n\u00E3o \u00E9 um valor permitido.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `N\u00E3o pode ter mais que ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} deve ser igual ou menor que ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Nenhum formato de arquivo permitido.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} deve ser do tipo: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `N\u00E3o pode ter menos que ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} deve ter pelo menos ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D n\u00E3o permite ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} deve ser um n\u00FAmero.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} \u00E9 obrigat\u00F3rio.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} n\u00E3o come\u00E7a com ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `Por favor informe um url v\u00E1lido.`;\n        /* </i18n> */\n    },\n};\n\nvar pt = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$4,\n    validation: validation$4\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$3 = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '\u0423\u0434\u0430\u043B\u0438\u0442\u044C',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: '\u0423\u0431\u0440\u0430\u0442\u044C \u0432\u0441\u0435',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '\u0418\u0437\u0432\u0438\u043D\u0438\u0442\u0435, \u043D\u0435 \u0432\u0441\u0435 \u043F\u043E\u043B\u044F \u0437\u0430\u043F\u043E\u043B\u043D\u0435\u043D\u044B \u0432\u0435\u0440\u043D\u043E.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '\u041E\u0442\u043F\u0440\u0430\u0432\u0438\u0442\u044C',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: '\u0424\u0430\u0439\u043B \u043D\u0435 \u0432\u044B\u0431\u0440\u0430\u043D',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$3 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u043F\u0440\u0438\u043C\u0438\u0442\u0435 ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `\u0414\u0430\u0442\u0430 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u043F\u043E\u0437\u0436\u0435 ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `\u0414\u0430\u0442\u0430 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u0432 \u0431\u0443\u0434\u0443\u0449\u0435\u043C.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u043C\u043E\u0436\u0435\u0442 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u0442\u043E\u043B\u044C\u043A\u043E \u0431\u0443\u043A\u0432\u044B.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u043C\u043E\u0436\u0435\u0442 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u0442\u043E\u043B\u044C\u043A\u043E \u0431\u0443\u043A\u0432\u044B \u0438 \u0446\u0438\u0444\u0440\u044B.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} \u043C\u043E\u0433\u0443\u0442 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u0442\u043E\u043B\u044C\u043A\u043E \u0431\u0443\u043A\u0432\u044B \u0438 \u043F\u0440\u043E\u0431\u0435\u043B\u044B.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `\u0414\u0430\u0442\u0430 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u0440\u0430\u043D\u044C\u0448\u0435 ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `\u0414\u0430\u0442\u0430 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u0432 \u043F\u0440\u043E\u0448\u043B\u043E\u043C.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `\u042D\u0442\u043E \u043F\u043E\u043B\u0435 \u0437\u0430\u043F\u043E\u043B\u043D\u0435\u043D\u043E \u043D\u0435\u0432\u0435\u0440\u043D\u043E \u0438 \u043D\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u043E.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043C\u0435\u0436\u0434\u0443 ${a} \u0438 ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u043D\u0435 \u0441\u043E\u0432\u043F\u0430\u0434\u0430\u0435\u0442.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0438\u043C\u0435\u0435\u0442 \u043D\u0435\u0432\u0435\u0440\u043D\u0443\u044E \u0434\u0430\u0442\u0443. \u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0439\u0442\u0435 \u0444\u043E\u0440\u043C\u0430\u0442 ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '\u042D\u0442\u043E \u043F\u043E\u043B\u0435 \u0437\u0430\u043F\u043E\u043B\u043D\u0435\u043D\u043E \u043D\u0435\u0432\u0435\u0440\u043D\u043E \u0438 \u043D\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u043E\u0442\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u043E.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `\u0414\u0430\u0442\u0430 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u043C\u0435\u0436\u0434\u0443 ${date(args[0])} \u0438 ${date(args[1])}`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0432\u0432\u0435\u0434\u0438\u0442\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 \u044D\u043B\u0435\u043A\u0442\u0440\u043E\u043D\u043D\u044B\u0439 \u0430\u0434\u0440\u0435\u0441.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u043D\u0435 \u0434\u043E\u043B\u0436\u043D\u043E \u0437\u0430\u043A\u0430\u043D\u0447\u0438\u0432\u0430\u0442\u044C\u0441\u044F \u043D\u0430 ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0438\u043C\u0435\u0435\u0442 \u043D\u0435\u043F\u043E\u0434\u0443\u0441\u0442\u0438\u043C\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u043E \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u043C\u0438\u043D\u0438\u043C\u0443\u043C \u043E\u0434\u0438\u043D \u0441\u0438\u043C\u0432\u043E\u043B.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `\u0414\u043B\u0438\u043D\u0430 \u043F\u043E\u043B\u044F ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u043C\u0435\u043D\u044C\u0448\u0435 \u0438\u043B\u0438 \u0440\u0430\u0432\u043D\u0430 ${max} \u0441\u0438\u043C\u0432\u043E\u043B\u0430\u043C.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `\u0414\u043B\u0438\u043D\u0430 \u043F\u043E\u043B\u044F ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u0431\u043E\u043B\u044C\u0448\u0435 \u0438\u043B\u0438 \u0440\u0430\u0432\u043D\u0430 ${min} \u0441\u0438\u043C\u0432\u043E\u043B\u0430\u043C.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `\u0414\u043B\u0438\u043D\u0430 \u043F\u043E\u043B\u044F ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u0430 \u0431\u044B\u0442\u044C \u043C\u0435\u0436\u0434\u0443 ${min} \u0438 ${max} \u0441\u0438\u043C\u0432\u043E\u043B\u0430\u043C\u0438.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0438\u043C\u0435\u0435\u0442 \u043D\u0435\u0434\u043E\u043F\u0443\u0441\u0442\u0438\u043C\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `\u041D\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u0432\u044B\u0431\u0440\u0430\u043D\u043E \u0431\u043E\u043B\u044C\u0448\u0435, \u0447\u0435\u043C ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043C\u0435\u043D\u044C\u0448\u0435 \u0438\u043B\u0438 \u0440\u0430\u0432\u043D\u043E ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\u041D\u0435 \u0443\u043A\u0430\u0437\u0430\u043D\u044B \u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0430\u0432\u0435\u043C\u044B\u0435 \u0444\u043E\u0440\u043C\u0430\u0442\u044B \u0444\u0430\u0439\u043B\u0430.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `\u0424\u043E\u0440\u043C\u0430\u0442 \u0444\u0430\u0439\u043B\u0430 \u0432 \u043F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u0435\u043D \u0431\u044B\u0442\u044C: ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `\u041D\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u0432\u044B\u0431\u0440\u0430\u043D\u043E \u043C\u0435\u043D\u044C\u0448\u0435, \u0447\u0435\u043C ${args[0]} ${name}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u043D\u0435 \u043C\u0435\u043D\u0435\u0435, \u0447\u0435\u043C ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D \u043D\u0435 \u043F\u043E\u0434\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0435\u0442\u0441\u044F \u0432 \u043F\u043E\u043B\u0435 ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u043E \u0431\u044B\u0442\u044C \u0447\u0438\u0441\u043B\u043E\u043C.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u043E\u0431\u044F\u0437\u0430\u0442\u0435\u043B\u044C\u043D\u043E \u0434\u043B\u044F \u0437\u0430\u043F\u043E\u043B\u043D\u0435\u043D\u0438\u044F.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `\u041F\u043E\u043B\u0435 ${sentence(name)} \u0434\u043E\u043B\u0436\u043D\u043E \u043D\u0430\u0447\u0438\u043D\u0430\u0442\u044C\u0441\u044F \u0441 ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0432\u0432\u0435\u0434\u0438\u0442\u0435 \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 URL \u0430\u0434\u0440\u0435\u0441.`;\n        /* </i18n> */\n    },\n};\n\nvar ru = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$3,\n    validation: validation$3\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$2 = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Kald\u0131r',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Hepsini kald\u0131r',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Maalesef, t\u00FCm alanlar do\u011Fru doldurulmad\u0131.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'G\u00F6nder',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Dosya yok',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$2 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `L\u00FCtfen ${name}'yi kabul edin.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} ${date(args[0])}'den sonra olmal\u0131d\u0131r.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} gelecekte bir zaman olmal\u0131d\u0131r.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} sadece alfabetik karakterler i\u00E7erebilir.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} sadece alfabetik karakterler ve say\u0131 i\u00E7erebilir.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} yaln\u0131zca harf ve bo\u015Fluk i\u00E7erebilir.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} ${date(args[0])} tarihinden \u00F6nce olmal\u0131.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} ge\u00E7mi\u015Fte olmal\u0131.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Alan yanl\u0131\u015F yap\u0131land\u0131r\u0131lm\u0131\u015F ve g\u00F6nderilemez.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} ${args[0]} ve ${args[1]} aral\u0131\u011F\u0131nda olmal\u0131.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} e\u015Fle\u015Fmiyor.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} ge\u00E7erli bir tarih de\u011Fil, l\u00FCtfen ${args[0]} bi\u00E7imini kullan\u0131n.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Alan yanl\u0131\u015F yap\u0131land\u0131r\u0131lm\u0131\u015F ve g\u00F6nderilemez.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)}, ${date(args[0])} ve ${date(args[1])} aral\u0131\u011F\u0131nda olmal\u0131.`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'L\u00FCtfen ge\u00E7erli bir e-mail adresi girin.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ${list(args)} ile bitmiyor.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} izin verilen bir de\u011Fer de\u011Fil.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} en az\u0131ndan bir karakter uzunlu\u011Funda olmal\u0131.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} ${max}'e e\u015Fit veya daha k\u00FC\u00E7\u00FCk olmal\u0131.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} ${min}'e e\u015Fit veya daha b\u00FCy\u00FCk olmal\u0131.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)}, ${min} ve ${max} karakter uzunlu\u011Fu aral\u0131\u011F\u0131nda olmal\u0131.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} izin verilen bir de\u011Fer de\u011Fil.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${name}'in uzunlu\u011Fu ${args[0]}'dan daha uzun olamaz.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} en az\u0131ndan ${args[0]} uzunlu\u011Funda veya ona e\u015Fit olmal\u0131.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return 'Hi\u00E7bir dosya t\u00FCr\u00FCne izin verilmez.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} \u015Fu tiplerden biri olmal\u0131: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${name}'in uzunlu\u011Fu ${args[0]}'dan daha k\u0131sa olamaz.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} en az\u0131ndan ${args[0]} uzunlu\u011Funda olmal\u0131.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D ${name} olamaz.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} say\u0131 olmal\u0131.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} gerekli.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} ${list(args)} ile ba\u015Flam\u0131yor.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `L\u00FCtfen ge\u00E7erli bir url dahil edin.`;\n        /* </i18n> */\n    },\n};\n\nvar tr = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$2,\n    validation: validation$2\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui$1 = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: 'Xo\u00E1',\n    /**\n     * Shown when there are multiple items to remove at the same time.\n     */\n    removeAll: 'Xo\u00E1 t\u1EA5t c\u1EA3',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: 'Xin l\u1ED7i, kh\u00F4ng ph\u1EA3i t\u1EA5t c\u1EA3 c\u00E1c tr\u01B0\u1EDDng \u0111\u1EC1u \u0111\u01B0\u1EE3c nh\u1EADp \u0111\u00FAng.',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: 'G\u1EEDi',\n    /**\n     * Shown when no files are selected.\n     */\n    noFiles: 'Ch\u01B0a ch\u1ECDn file',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation$1 = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `H\u00E3y \u0111\u1ED3ng \u00FD v\u1EDBi ${name}.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)} ph\u1EA3i sau ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} ph\u1EA3i trong t\u01B0\u01A1ng lai.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)} c\u00F3 th\u1EC3 ch\u1EC9 bao g\u1ED3m c\u00E1c ch\u1EEF c\u00E1i alphabet.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)} c\u00F3 th\u1EC3 ch\u1EC9 bao g\u1ED3m c\u00E1c ch\u1EEF c\u00E1i v\u00E0 ch\u1EEF s\u1ED1.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)} ch\u1EC9 c\u00F3 th\u1EC3 ch\u1EE9a c\u00E1c ch\u1EEF c\u00E1i v\u00E0 kho\u1EA3ng tr\u1EAFng.`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)} ph\u1EA3i tr\u01B0\u1EDBc ${date(args[0])}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)} ph\u1EA3i trong qu\u00E1 kh\u1EE9.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `Tr\u01B0\u1EDDng n\u00E0y \u0111\u00E3 \u0111\u01B0\u1EE3c thi\u1EBFt l\u1EADp sai v\u00E0 kh\u00F4ng th\u1EC3 g\u1EEDi.`;\n            /* </i18n> */\n        }\n        const [a, b] = order(args[0], args[1]);\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)} ph\u1EA3i \u1EDF gi\u1EEFa ${a} v\u00E0 ${b}.`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)} kh\u00F4ng kh\u1EDBp.`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)} kh\u00F4ng ph\u1EA3i ng\u00E0y h\u1EE3p l\u1EC7, h\u00E3y s\u1EED d\u1EE5ng \u0111\u1ECBnh d\u1EA1ng ${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return 'Tr\u01B0\u1EDDng n\u00E0y \u0111\u00E3 \u0111\u01B0\u1EE3c thi\u1EBFt l\u1EADp sai v\u00E0 kh\u00F4ng th\u1EC3 g\u1EEDi.';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)} ph\u1EA3i \u1EDF gi\u1EEFa kho\u1EA3ng t\u1EEB ${date(args[0])} \u0111\u1EBFn ${date(args[1])}.`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: 'H\u00E3y nh\u1EADp m\u1ED9t \u0111\u1ECBa ch\u1EC9 email h\u1EE3p l\u1EC7.',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)} kh\u00F4ng k\u1EBFt th\u00FAc v\u1EDBi ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)} kh\u00F4ng ph\u1EA3i m\u1ED9t gi\u00E1 tr\u1ECB \u0111\u01B0\u1EE3c cho ph\u00E9p.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = Number(first) <= Number(second) ? first : second;\n        const max = Number(second) >= Number(first) ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)} ph\u1EA3i c\u00F3 \u0111\u1ED9 d\u00E0i t\u1ED1i thi\u1EC3u m\u1ED9t k\u00FD t\u1EF1.`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)} ph\u1EA3i c\u00F3 \u0111\u1ED9 d\u00E0i t\u1ED1i \u0111a ${max} k\u00FD t\u1EF1.`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)} ph\u1EA3i c\u00F3 \u0111\u1ED9 d\u00E0i t\u1ED1i thi\u1EC3u ${min} k\u00FD t\u1EF1.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)} ph\u1EA3i c\u00F3 \u0111\u1ED9 d\u00E0i t\u1ED1i \u0111a trong kho\u1EA3ng t\u1EEB ${min} \u0111\u1EBFn ${max} k\u00FD t\u1EF1.`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)} kh\u00F4ng ph\u1EA3i m\u1ED9t gi\u00E1 tr\u1ECB \u0111\u01B0\u1EE3c cho ph\u00E9p.`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${name} kh\u00F4ng th\u1EC3 l\u1EDBn h\u01A1n ${args[0]}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)} ph\u1EA3i t\u1ED1i \u0111a b\u1EB1ng ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\u0110\u1ECBnh d\u1EA1ng t\u1EC7p tin n\u00E0y kh\u00F4ng \u0111\u01B0\u1EE3c ph\u00E9p.';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)} ph\u1EA3i l\u00E0 m\u1ED9t trong c\u00E1c d\u1EA1ng: ${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${name} kh\u00F4ng th\u1EC3 nh\u1ECF h\u01A1n ${args[0]}.`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)} ph\u1EA3i t\u1ED1i thi\u1EC3u b\u1EB1ng ${args[0]}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\"${value}\" kh\u00F4ng ph\u1EA3i gi\u00E1 tr\u1ECB ${name} \u0111\u01B0\u1EE3c ph\u00E9p.`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)} ph\u1EA3i l\u00E0 m\u1ED9t s\u1ED1.`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)} l\u00E0 b\u1EAFt bu\u1ED9c.`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)} kh\u00F4ng b\u1EAFt \u0111\u1EA7u v\u1EDBi ${list(args)}.`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `H\u00E3y nh\u1EADp m\u1ED9t URL h\u1EE3p l\u1EC7.`;\n        /* </i18n> */\n    },\n};\n\nvar vi = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui$1,\n    validation: validation$1\n});\n\n/**\n * Here we can import additional helper functions to assist in formatting our\n * language. Feel free to add additional helper methods to libs/formats if it\n * assists in creating good validation messages for your locale.\n */\n/**\n * Standard language for interface features.\n * @public\n */\nconst ui = {\n    /**\n     * Shown when a button to remove items is visible.\n     */\n    remove: '\u79FB\u9664',\n    /**\n     * Shown when all fields are not filled out correctly.\n     */\n    incomplete: '\u5BF9\u4E0D\u8D77\uFF0C\u6709\u4E9B\u5B57\u6BB5\u672A\u88AB\u6B63\u786E\u586B\u5199',\n    /**\n     * Shown in a button inside a form to submit the form.\n     */\n    submit: '\u63D0\u4EA4',\n};\n/**\n * These are all the possible strings that pertain to validation messages.\n * @public\n */\nconst validation = {\n    /**\n     * The value is not an accepted value.\n     * @see {@link https://docs.formkit.com/essentials/validation#accepted}\n     */\n    accepted({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a valid 'accepted' value.\"> */\n        return `\u8BF7\u63A5\u53D7${name}`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not after\n     * @see {@link https://docs.formkit.com/essentials/validation#date-after}\n     */\n    date_after({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not after the date supplied to the rule.\"> */\n            return `${sentence(name)}\u5FC5\u987B\u665A\u4E8E${date(args[0])}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not after today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)}\u5FC5\u987B\u662F\u672A\u6765\u7684\u65E5\u671F`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a letter.\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha}\n     */\n    alpha({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical characters.\"> */\n        return `${sentence(name)}\u4EC5\u80FD\u5305\u542B\u5B57\u6BCD\u5B57\u7B26`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not alphanumeric\n     * @see {@link https://docs.formkit.com/essentials/validation#alphanumeric}\n     */\n    alphanumeric({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphanumeric characters.\"> */\n        return `${sentence(name)}\u4EC5\u80FD\u5305\u542B\u5B57\u6BCD\u548C\u6570\u5B57`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not letter and/or spaces\n     * @see {@link https://docs.formkit.com/essentials/validation#alpha-spaces}\n     */\n    alpha_spaces({ name }) {\n        /* <i18n case=\"Shown when the user-provided value contains non-alphabetical and non-space characters.\"> */\n        return `${sentence(name)}\u53EA\u80FD\u5305\u542B\u5B57\u6BCD\u548C\u7A7A\u683C`;\n        /* </i18n> */\n    },\n    /**\n     * The date is not before\n     * @see {@link https://docs.formkit.com/essentials/validation#date-before}\n     */\n    date_before({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date is not before the date supplied to the rule.\"> */\n            return `${sentence(name)}\u5FC5\u987B\u65E9\u4E8E${date(args[0])}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided date is not before today's date, since no date was supplied to the rule.\"> */\n        return `${sentence(name)}\u5FC5\u987B\u662F\u8FC7\u53BB\u7684\u65E5\u671F`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not between two numbers\n     * @see {@link https://docs.formkit.com/essentials/validation#between}\n     */\n    between({ name, args }) {\n        if (isNaN(args[0]) || isNaN(args[1])) {\n            /* <i18n case=\"Shown when any of the arguments supplied to the rule were not a number.\"> */\n            return `\u8BE5\u5B57\u6BB5\u672A\u88AB\u6B63\u786E\u8BBE\u7F6E\u800C\u65E0\u6CD5\u88AB\u63D0\u4EA4`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is not between two numbers.\"> */\n        return `${sentence(name)}\u5FC5\u987B\u5728${args[0]}\u548C${args[1]}\u4E4B\u95F4`;\n        /* </i18n> */\n    },\n    /**\n     * The confirmation field does not match\n     * @see {@link https://docs.formkit.com/essentials/validation#confirm}\n     */\n    confirm({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not equal the value of the matched input.\"> */\n        return `${sentence(name)}\u4E0D\u5339\u914D`;\n        /* </i18n> */\n    },\n    /**\n     * The value is not a valid date\n     * @see {@link https://docs.formkit.com/essentials/validation#date-format}\n     */\n    date_format({ name, args }) {\n        if (Array.isArray(args) && args.length) {\n            /* <i18n case=\"Shown when the user-provided date does not satisfy the date format supplied to the rule.\"> */\n            return `${sentence(name)}\u4E0D\u662F\u4E00\u4E2A\u5408\u6CD5\u65E5\u671F\uFF0C\u8BF7\u4F7F\u7528\u6B64\u683C\u5F0F${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when no date argument was supplied to the rule.\"> */\n        return '\u8BE5\u5B57\u6BB5\u672A\u88AB\u6B63\u786E\u8BBE\u7F6E\u800C\u65E0\u6CD5\u88AB\u63D0\u4EA4';\n        /* </i18n> */\n    },\n    /**\n     * Is not within expected date range\n     * @see {@link https://docs.formkit.com/essentials/validation#date-between}\n     */\n    date_between({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided date is not between the start and end dates supplied to the rule. \"> */\n        return `${sentence(name)}\u5FC5\u987B\u5728${date(args[0])}\u548C${date(args[1])}\u4E4B\u95F4`;\n        /* </i18n> */\n    },\n    /**\n     * Shown when the user-provided value is not a valid email address.\n     * @see {@link https://docs.formkit.com/essentials/validation#email}\n     */\n    email: '\u8BF7\u8F93\u5165\u4E00\u4E2A\u5408\u6CD5\u7684\u7535\u5B50\u90AE\u4EF6\u5730\u5740',\n    /**\n     * Does not end with the specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#ends-with}\n     */\n    ends_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not end with the substring supplied to the rule.\"> */\n        return `${sentence(name)}\u5E76\u672A\u4EE5${list(args)}\u7ED3\u5C3E`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#is}\n     */\n    is({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not one of the values supplied to the rule.\"> */\n        return `${sentence(name)}\u4E0D\u662F\u4E00\u4E2A\u5141\u8BB8\u503C`;\n        /* </i18n> */\n    },\n    /**\n     * Does not match specified length\n     * @see {@link https://docs.formkit.com/essentials/validation#length}\n     */\n    length({ name, args: [first = 0, second = Infinity] }) {\n        const min = first <= second ? first : second;\n        const max = second >= first ? second : first;\n        if (min == 1 && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is not at least one character.\"> */\n            return `${sentence(name)}\u81F3\u5C11\u8981\u6709\u4E00\u4E2A\u5B57\u7B26`;\n            /* </i18n> */\n        }\n        if (min == 0 && max) {\n            /* <i18n case=\"Shown when first argument supplied to the rule is 0, and the user-provided value is longer than the max (the 2nd argument) supplied to the rule.\"> */\n            return `${sentence(name)}\u5FC5\u987B\u5C11\u4E8E\u6216\u7B49\u4E8E${max}\u4E2A\u5B57\u7B26`;\n            /* </i18n> */\n        }\n        if (min && max === Infinity) {\n            /* <i18n case=\"Shown when the length of the user-provided value is less than the minimum supplied to the rule and there is no maximum supplied to the rule.\"> */\n            return `${sentence(name)}\u5FC5\u987B\u591A\u4E8E\u6216\u7B49\u4E8E${min}\u4E2A\u5B57\u7B26`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the length of the user-provided value is between the two lengths supplied to the rule.\"> */\n        return `${sentence(name)}\u5FC5\u987B\u6709${min}\u81F3${max}\u4E2A\u5B57\u7B26`;\n        /* </i18n> */\n    },\n    /**\n     * Value is not a match\n     * @see {@link https://docs.formkit.com/essentials/validation#matches}\n     */\n    matches({ name }) {\n        /* <i18n case=\"Shown when the user-provided value does not match any of the values or RegExp patterns supplied to the rule. \"> */\n        return `${sentence(name)}\u4E0D\u662F\u4E00\u4E2A\u5141\u8BB8\u503C`;\n        /* </i18n> */\n    },\n    /**\n     * Exceeds maximum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#max}\n     */\n    max({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is longer than the max supplied to the rule.\"> */\n            return `${name}\u4E0D\u80FD\u8D85\u8FC7${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is greater than the maximum number supplied to the rule.\"> */\n        return `${sentence(name)}\u5FC5\u987B\u5C0F\u4E8E\u6216\u7B49\u4E8E${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * The (field-level) value does not match specified mime type\n     * @see {@link https://docs.formkit.com/essentials/validation#mime}\n     */\n    mime({ name, args }) {\n        if (!args[0]) {\n            /* <i18n case=\"Shown when no file formats were supplied to the rule.\"> */\n            return '\u65E0\u5141\u8BB8\u7684\u6587\u4EF6\u683C\u5F0F';\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the mime type of user-provided file does not match any mime types supplied to the rule.\"> */\n        return `${sentence(name)}\u5FC5\u987B\u4E3A\u6B64\u7C7B\u578B\uFF1A${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Does not fulfill minimum allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#min}\n     */\n    min({ name, node: { value }, args }) {\n        if (Array.isArray(value)) {\n            /* <i18n case=\"Shown when the length of the array of user-provided values is shorter than the min supplied to the rule.\"> */\n            return `${name}\u4E0D\u80FD\u5C11\u4E8E${args[0]}`;\n            /* </i18n> */\n        }\n        /* <i18n case=\"Shown when the user-provided value is less than the minimum number supplied to the rule.\"> */\n        return `${sentence(name)}\u4E0D\u80FD\u5C0F\u4E8E${args[0]}`;\n        /* </i18n> */\n    },\n    /**\n     * Is not an allowed value\n     * @see {@link https://docs.formkit.com/essentials/validation#not}\n     */\n    not({ name, node: { value } }) {\n        /* <i18n case=\"Shown when the user-provided value matches one of the values supplied to (and thus disallowed by) the rule.\"> */\n        return `\u201C${value}\u201D\u4E0D\u662F\u4E00\u4E2A\u88AB\u5141\u8BB8\u7684${name}`;\n        /* </i18n> */\n    },\n    /**\n     *  Is not a number\n     * @see {@link https://docs.formkit.com/essentials/validation#number}\n     */\n    number({ name }) {\n        /* <i18n case=\"Shown when the user-provided value is not a number.\"> */\n        return `${sentence(name)}\u5FC5\u987B\u662F\u4E00\u4E2A\u6570\u5B57`;\n        /* </i18n> */\n    },\n    /**\n     * Required field.\n     * @see {@link https://docs.formkit.com/essentials/validation#required}\n     */\n    required({ name }) {\n        /* <i18n case=\"Shown when a user does not provide a value to a required input.\"> */\n        return `${sentence(name)}\u5FC5\u987B\u586B\u5199`;\n        /* </i18n> */\n    },\n    /**\n     * Does not start with specified value\n     * @see {@link https://docs.formkit.com/essentials/validation#starts-with}\n     */\n    starts_with({ name, args }) {\n        /* <i18n case=\"Shown when the user-provided value does not start with the substring supplied to the rule.\"> */\n        return `${sentence(name)}\u6CA1\u6709\u4EE5${list(args)}\u5F00\u5934`;\n        /* </i18n> */\n    },\n    /**\n     * Is not a url\n     * @see {@link https://docs.formkit.com/essentials/validation#url}\n     */\n    url() {\n        /* <i18n case=\"Shown when the user-provided value is not a valid url.\"> */\n        return `\u8BF7\u5305\u542B\u4E00\u4E2A\u5408\u6CD5\u7684url`;\n        /* </i18n> */\n    },\n};\n\nvar zh = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ui: ui,\n    validation: validation\n});\n\n/**\n * Create a new internationalization plugin for FormKit.\n * @param locales - Creates the i18n plugin.\n * @public\n */\nfunction createI18nPlugin(registry) {\n    return function i18nPlugin(node) {\n        let localeKey = parseLocale(node.config.locale, registry);\n        let locale = localeKey ? registry[localeKey] : {};\n        /* If the locale prop changes, update the active locale */\n        node.on('prop:locale', ({ payload: lang }) => {\n            localeKey = parseLocale(lang, registry);\n            locale = localeKey ? registry[localeKey] : {};\n            // Run through all the messages in the store and update with new locale\n            node.store.touch();\n        });\n        /**\n         * Hook into the core text or t() hook to perform localization on the\n         * output of core functionality.\n         */\n        node.hook.text((fragment, next) => {\n            var _a, _b;\n            const key = ((_a = fragment.meta) === null || _a === void 0 ? void 0 : _a.messageKey) || fragment.key;\n            if (has(locale, fragment.type) && has(locale[fragment.type], key)) {\n                const t = locale[fragment.type][key];\n                if (typeof t === 'function') {\n                    fragment.value = Array.isArray((_b = fragment.meta) === null || _b === void 0 ? void 0 : _b.i18nArgs)\n                        ? t(...fragment.meta.i18nArgs) // eslint-disable-line @typescript-eslint/no-non-null-assertion\n                        : t(fragment);\n                }\n                else {\n                    fragment.value = t;\n                }\n            }\n            return next(fragment);\n        });\n    };\n}\n/**\n * @param locale - An ISO 639-1 and (optionally) ISO 639-2 language tag. For\n * example these are valid locale keys:\n * zh\n * zh-CN\n * zh-HK\n * en\n * en-GB\n * @param availableLocales - An array of locales that may be valid.\n */\nfunction parseLocale(locale, availableLocales) {\n    if (has(availableLocales, locale)) {\n        return locale;\n    }\n    const [lang] = locale.split('-');\n    if (has(availableLocales, lang)) {\n        return lang;\n    }\n    for (const locale in availableLocales) {\n        return locale;\n    }\n    return false;\n}\n\n/**\n * Export all the available locales at once.\n * @public\n */\nconst locales = {\n    ar,\n    cs,\n    da,\n    de,\n    en,\n    es,\n    fa,\n    fi,\n    fr,\n    fy,\n    he,\n    hr,\n    id,\n    it,\n    ko,\n    nl,\n    pl,\n    pt,\n    ru,\n    tr,\n    vi,\n    zh,\n};\n\nexport { ar, createI18nPlugin, cs, da, date, de, en, es, fa, fi, fr, fy, he, hr, id, it, ko, list, locales, nl, order, pl, pt, ru, sentence, tr, vi, zh };\n", "import { errorHandler, warningHandler } from '@formkit/core';\n\nlet registered = false;\n/**\n * Catalog of the error message codes in FormKit.\n * @public\n */\nconst errors = {\n    /**\n     * FormKit errors:\n     */\n    100: ({ data: node }) => `Only groups, lists, and forms can have children (${node.name}).`,\n    101: ({ data: node }) => `You cannot directly modify the store (${node.name}). See: https://formkit.com/advanced/core#message-store`,\n    102: ({ data: [node, property], }) => `You cannot directly assign node.${property} (${node.name})`,\n    103: ({ data: [operator] }) => `Schema expressions cannot start with an operator (${operator})`,\n    104: ({ data: [operator, expression] }) => `Schema expressions cannot end with an operator (${operator} in \"${expression}\")`,\n    105: ({ data: expression }) => `Invalid schema expression: ${expression}`,\n    106: ({ data: name }) => `Cannot submit because (${name}) is not in a form.`,\n    107: ({ data: [node, value] }) => `Cannot set ${node.name} to non object value: ${value}`,\n    108: ({ data: [node, value] }) => `Cannot set ${node.name} to non array value: ${value}`,\n    /**\n     * FormKit vue errors:\n     */\n    600: ({ data: node }) => `Unknown input type${typeof node.props.type === 'string' ? ' \"' + node.props.type + '\"' : ''} (\"${node.name}\")`,\n    601: ({ data: node }) => `Input definition${typeof node.props.type === 'string' ? ' \"' + node.props.type + '\"' : ''} is missing a schema or component property (${node.name}).`,\n};\n/**\n * Catalog of the warning message codes in FormKit.\n * @public\n */\nconst warnings = {\n    /**\n     * Core warnings:\n     */\n    150: ({ data: fn }) => `Schema function \"${fn}()\" is not a valid function.`,\n    151: ({ data: id }) => `No form element with id: ${id}`,\n    152: ({ data: id }) => `No input element with id: ${id}`,\n    /**\n     * Input specific warnings:\n     */\n    350: ({ data: node }) => `Invalid options prop for radio input (${node.name}). See https://formkit.com/inputs/radio`,\n    /**\n     * Vue warnings:\n     */\n    650: 'Schema \"$get()\" must use the id of an input to access.',\n    651: ({ data: id }) => `Cannot setErrors() on \"${id}\" because no such id exists.`,\n};\n/**\n * Decodes an error that is being emitted and console logs it.\n * @param error - The error currently being handled\n * @param next - Call additional handlers\n * @returns\n */\nconst decodeErrors = (error, next) => {\n    if (error.code in errors) {\n        const err = errors[error.code];\n        error.message = typeof err === 'function' ? err(error) : err;\n    }\n    return next(error);\n};\nif (!registered)\n    errorHandler(decodeErrors);\n/**\n * Decodes an error that is being emitted and console logs it.\n * @param error - The error currently being handled\n * @param next - Call additional handlers\n * @returns\n */\nconst decodeWarnings = (warning, next) => {\n    if (warning.code in warnings) {\n        const warn = warnings[warning.code];\n        warning.message = typeof warn === 'function' ? warn(warning) : warn;\n    }\n    return next(warning);\n};\nif (!registered)\n    warningHandler(decodeWarnings);\nregistered = true;\n\nexport { errors, warnings };\n", "import { warn, getNode, watchRegistry, isNode, sugar, isDOM, isComponent as isComponent$1, isConditional, compile, error, createConfig, setErrors, submitForm, reset, createNode, createMessage, createClasses, generateClassList } from '@formkit/core';\nexport { errorHandler, reset, resetCount, setErrors, submitForm } from '@formkit/core';\nimport { defineComponent, getCurrentInstance, watch, watchEffect, reactive, ref, createTextVNode, resolveComponent, h, inject, provide, onUnmounted, markRaw, computed } from 'vue';\nimport { has, isPojo, cloneAny, extend, camel, kebab, nodeProps, only, except, slugify, empty, eq } from '@formkit/utils';\nimport { useSchema, createLibraryPlugin, inputs } from '@formkit/inputs';\nimport * as defaultRules from '@formkit/rules';\nimport { createValidationPlugin } from '@formkit/validation';\nimport { createI18nPlugin, en } from '@formkit/i18n';\nimport { createObserver } from '@formkit/observer';\nimport '@formkit/dev';\n\n/**\n * A registry of memoized schemas (in JSON) to their respective render function\n * and provider registry.\n */\nconst memo = {};\n/**\n * This symbol represents the current component instance during render. It is\n * critical for linking the current instance to the data required for render.\n */\nlet instanceKey;\n/**\n * A registry of scoped data produced during runtime that is keyed by the\n * instance symbol. For example data from: for-loop instances and slot data.\n */\nconst instanceScopes = new Map();\n/**\n * Indicates the a section of the schema is raw.\n */\nconst raw = '__raw__';\n/**\n * Is a class prop.\n */\nconst isClassProp = /[a-zA-Z0-9\\-][cC]lass$/;\n/**\n * Returns a reference as a placeholder to a specific location on an object.\n * @param data - A reactive data object\n * @param token - A dot-syntax string representing the object path\n * @returns\n */\nfunction getRef(token, data) {\n    const value = ref(null);\n    const nodeRef = ref(undefined);\n    if (token === 'get') {\n        value.value = get.bind(null, nodeRef);\n        return value;\n    }\n    const path = token.split('.');\n    watchEffect(() => (value.value = getValue(data, path)));\n    return value;\n}\n/**\n * Returns a value inside a set of data objects.\n * @param sets - An array of objects to search through\n * @param path - A array of string paths easily produced by split()\n * @returns\n */\nfunction getValue(set, path) {\n    if (Array.isArray(set)) {\n        for (const subset of set) {\n            const value = subset !== false && getValue(subset, path);\n            if (value !== undefined)\n                return value;\n        }\n        return undefined;\n    }\n    let foundValue = undefined;\n    path.reduce((obj, segment, i, arr) => {\n        if (typeof obj !== 'object') {\n            foundValue = undefined;\n            return arr.splice(1); // Forces an exit\n        }\n        const currentValue = obj[segment];\n        if (i === path.length - 1 && currentValue !== undefined) {\n            foundValue = currentValue;\n        }\n        return obj[segment];\n    }, set);\n    return foundValue;\n}\n/**\n * Get the node from the global registry\n * @param id - A dot-syntax string where the node is located.\n */\nfunction get(nodeRef, id) {\n    if (typeof id !== 'string')\n        return warn(650);\n    if (nodeRef.value === undefined) {\n        nodeRef.value = null;\n        const root = getNode(id);\n        if (root)\n            nodeRef.value = root.context;\n        watchRegistry(id, ({ payload: node }) => {\n            nodeRef.value = isNode(node) ? node.context : node;\n        });\n    }\n    return nodeRef.value;\n}\n/**\n *\n * @param library - A library of concrete components to use\n * @param schema -\n * @returns\n */\nfunction parseSchema(library, schema) {\n    /**\n     * Given an if/then/else schema node, pre-compile the node and return the\n     * artifacts for the render function.\n     * @param data - The schema context object\n     * @param library - The available components\n     * @param node - The node to parse\n     */\n    function parseCondition(library, node) {\n        const condition = provider(compile(node.if), { if: true });\n        const children = createElements(library, node.then);\n        const alternate = node.else ? createElements(library, node.else) : null;\n        return [condition, children, alternate];\n    }\n    /**\n     * Parses a conditional if/then/else attribute statement.\n     * @param data - The data object\n     * @param attr - The attribute\n     * @param _default - The default value\n     * @returns\n     */\n    function parseConditionAttr(attr, _default) {\n        var _a, _b;\n        const condition = provider(compile(attr.if));\n        let b = () => _default;\n        let a = () => _default;\n        if (typeof attr.then === 'object') {\n            a = parseAttrs(attr.then, undefined);\n        }\n        else if (typeof attr.then === 'string' && ((_a = attr.then) === null || _a === void 0 ? void 0 : _a.startsWith('$'))) {\n            a = provider(compile(attr.then));\n        }\n        else {\n            a = () => attr.then;\n        }\n        if (has(attr, 'else')) {\n            if (typeof attr.else === 'object') {\n                b = parseAttrs(attr.else);\n            }\n            else if (typeof attr.else === 'string' && ((_b = attr.else) === null || _b === void 0 ? void 0 : _b.startsWith('$'))) {\n                b = provider(compile(attr.else));\n            }\n            else {\n                b = () => attr.else;\n            }\n        }\n        return () => (condition() ? a() : b());\n    }\n    /**\n     * Parse attributes for dynamic content.\n     * @param attrs - Object of attributes\n     * @returns\n     */\n    function parseAttrs(unparsedAttrs, bindExp, _default = {}) {\n        const explicitAttrs = new Set(Object.keys(unparsedAttrs || {}));\n        const boundAttrs = bindExp ? provider(compile(bindExp)) : () => ({});\n        const staticAttrs = {};\n        const setters = [\n            (attrs) => {\n                const bound = boundAttrs();\n                for (const attr in bound) {\n                    if (!explicitAttrs.has(attr)) {\n                        attrs[attr] = bound[attr];\n                    }\n                }\n            },\n        ];\n        if (unparsedAttrs) {\n            if (isConditional(unparsedAttrs)) {\n                // This is a root conditional object that must produce an object of\n                // attributes.\n                const condition = parseConditionAttr(unparsedAttrs, _default);\n                return condition;\n            }\n            // Some attributes are explicitly bound, we need to parse those ones\n            // using the compiler and create a dynamic \"setter\".\n            for (let attr in unparsedAttrs) {\n                const value = unparsedAttrs[attr];\n                let getValue;\n                const isStr = typeof value === 'string';\n                if (attr.startsWith(raw)) {\n                    // attributes prefixed with __raw__ should not be parsed\n                    attr = attr.substring(7);\n                    getValue = () => value;\n                }\n                else if (isStr &&\n                    value.startsWith('$') &&\n                    value.length > 1 &&\n                    !(value.startsWith('$reset') && isClassProp.test(attr))) {\n                    // Most attribute values starting with $ should be compiled\n                    // -class attributes starting with `$reset` should not be compiled\n                    getValue = provider(compile(value));\n                }\n                else if (typeof value === 'object' && isConditional(value)) {\n                    // Conditional attrs require further processing\n                    getValue = parseConditionAttr(value, undefined);\n                }\n                else if (typeof value === 'object' && isPojo(value)) {\n                    // Sub-parse pojos\n                    getValue = parseAttrs(value);\n                }\n                else {\n                    // In all other cases, the value is static\n                    getValue = () => value;\n                    staticAttrs[attr] = value;\n                }\n                setters.push((attrs) => {\n                    attrs[attr] = getValue();\n                });\n            }\n        }\n        return () => {\n            const attrs = {};\n            setters.forEach((setter) => setter(attrs));\n            return attrs;\n        };\n    }\n    /**\n     * Given a single schema node, parse it and extract the value.\n     * @param data - A state object provided to each node\n     * @param node - The schema node being parsed\n     * @returns\n     */\n    function parseNode(library, _node) {\n        let element = null;\n        let attrs = () => null;\n        let condition = false;\n        let children = null;\n        let alternate = null;\n        let iterator = null;\n        let resolve = false;\n        const node = sugar(_node);\n        if (isDOM(node)) {\n            // This is an actual HTML DOM element\n            element = node.$el;\n            attrs =\n                node.$el !== 'text' ? parseAttrs(node.attrs, node.bind) : () => null;\n        }\n        else if (isComponent$1(node)) {\n            // This is a Vue Component\n            if (typeof node.$cmp === 'string') {\n                if (has(library, node.$cmp)) {\n                    element = library[node.$cmp];\n                }\n                else {\n                    element = node.$cmp;\n                    resolve = true;\n                }\n            }\n            else {\n                // in this case it must be an actual component\n                element = node.$cmp;\n            }\n            attrs = parseAttrs(node.props, node.bind);\n        }\n        else if (isConditional(node)) {\n            [condition, children, alternate] = parseCondition(library, node);\n        }\n        // This is the same as a \"v-if\" statement \u2014 not an if/else statement\n        if (!isConditional(node) && 'if' in node) {\n            condition = provider(compile(node.if));\n        }\n        else if (!isConditional(node) && element === null) {\n            // In this odd case our element is actually a partial and\n            // we only want to render the children.\n            condition = () => true;\n        }\n        // Compile children down to a function\n        if ('children' in node && node.children) {\n            if (typeof node.children === 'string') {\n                // We are dealing with a raw string value\n                if (node.children.startsWith('$slots.')) {\n                    // this is a lone text node, turn it into a slot\n                    element = element === 'text' ? 'slot' : element;\n                    children = provider(compile(node.children));\n                }\n                else if (node.children.startsWith('$') && node.children.length > 1) {\n                    const value = provider(compile(node.children));\n                    children = () => String(value());\n                }\n                else {\n                    children = () => String(node.children);\n                }\n            }\n            else if (Array.isArray(node.children)) {\n                // We are dealing with node sub-children\n                children = createElements(library, node.children);\n            }\n            else {\n                // This is a conditional if/else clause\n                const [childCondition, c, a] = parseCondition(library, node.children);\n                children = (iterationData) => childCondition && childCondition()\n                    ? c && c(iterationData)\n                    : a && a(iterationData);\n            }\n        }\n        if (isComponent$1(node)) {\n            if (children) {\n                // Children of components need to be provided as an object of slots\n                // so we provide an object with the default slot provided as children.\n                // We also create a new scope for this default slot, and then on each\n                // render pass the scoped slot props to the scope.\n                const produceChildren = children;\n                children = (iterationData) => {\n                    return {\n                        default(slotData, key) {\n                            var _a, _b, _c, _d;\n                            // We need to switch the current instance key back to the one that\n                            // originally called this component's render function.\n                            const currentKey = instanceKey;\n                            if (key)\n                                instanceKey = key;\n                            if (slotData)\n                                (_a = instanceScopes.get(instanceKey)) === null || _a === void 0 ? void 0 : _a.unshift(slotData);\n                            if (iterationData)\n                                (_b = instanceScopes.get(instanceKey)) === null || _b === void 0 ? void 0 : _b.unshift(iterationData);\n                            const c = produceChildren(iterationData);\n                            // Ensure our instance key never changed during runtime\n                            if (slotData)\n                                (_c = instanceScopes.get(instanceKey)) === null || _c === void 0 ? void 0 : _c.shift();\n                            if (iterationData)\n                                (_d = instanceScopes.get(instanceKey)) === null || _d === void 0 ? void 0 : _d.shift();\n                            instanceKey = currentKey;\n                            return c;\n                        },\n                    };\n                };\n                children.slot = true;\n            }\n            else {\n                // If we dont have any children, we still need to provide an object\n                // instead of an empty array (which raises a warning in vue)\n                children = () => ({});\n            }\n        }\n        // Compile the for loop down\n        if ('for' in node && node.for) {\n            const values = node.for.length === 3 ? node.for[2] : node.for[1];\n            const getValues = typeof values === 'string' && values.startsWith('$')\n                ? provider(compile(values))\n                : () => values;\n            iterator = [\n                getValues,\n                node.for[0],\n                node.for.length === 3 ? String(node.for[1]) : null,\n            ];\n        }\n        return [condition, element, attrs, children, alternate, iterator, resolve];\n    }\n    /**\n     * Given a particular function that produces children, ensure that the second\n     * argument of all these slots is the original instance key being used to\n     * render the slots.\n     * @param children - The children() function that will produce slots\n     */\n    function createSlots(children, iterationData) {\n        const slots = children(iterationData);\n        const currentKey = instanceKey;\n        return Object.keys(slots).reduce((allSlots, slotName) => {\n            const slotFn = slots && slots[slotName];\n            allSlots[slotName] = (data) => {\n                return (slotFn && slotFn(data, currentKey)) || null;\n            };\n            return allSlots;\n        }, {});\n    }\n    /**\n     * Creates an element\n     * @param data - The context data available to the node\n     * @param node - The schema node to render\n     * @returns\n     */\n    function createElement(library, node) {\n        // Parses the schema node into pertinent parts\n        const [condition, element, attrs, children, alternate, iterator, resolve] = parseNode(library, node);\n        // This is a sub-render function (called within a render function). It must\n        // only use pre-compiled features, and be organized in the most efficient\n        // manner possible.\n        let createNodes = ((iterationData) => {\n            if (condition && element === null && children) {\n                // Handle conditional if/then statements\n                return condition()\n                    ? children(iterationData)\n                    : alternate && alternate(iterationData);\n            }\n            if (element && (!condition || condition())) {\n                // handle text nodes\n                if (element === 'text' && children) {\n                    return createTextVNode(String(children()));\n                }\n                // Handle lone slots\n                if (element === 'slot' && children)\n                    return children(iterationData);\n                // Handle resolving components\n                const el = resolve ? resolveComponent(element) : element;\n                // If we are rendering slots as children, ensure their instanceKey is properly added\n                const slots = (children === null || children === void 0 ? void 0 : children.slot)\n                    ? createSlots(children, iterationData)\n                    : null;\n                // Handle dom elements and components\n                return h(el, attrs(), (slots || (children ? children(iterationData) : [])));\n            }\n            return typeof alternate === 'function'\n                ? alternate(iterationData)\n                : alternate;\n        });\n        if (iterator) {\n            const repeatedNode = createNodes;\n            const [getValues, valueName, keyName] = iterator;\n            createNodes = (() => {\n                const _v = getValues();\n                const values = !isNaN(_v)\n                    ? Array(Number(_v))\n                        .fill(0)\n                        .map((_, i) => i)\n                    : _v;\n                const fragment = [];\n                if (typeof values !== 'object')\n                    return null;\n                const instanceScope = instanceScopes.get(instanceKey) || [];\n                for (const key in values) {\n                    const iterationData = Object.defineProperty({\n                        ...instanceScope.reduce((previousIterationData, scopedData) => {\n                            if (previousIterationData.__idata) {\n                                return { ...previousIterationData, ...scopedData };\n                            }\n                            return scopedData;\n                        }, {}),\n                        [valueName]: values[key],\n                        ...(keyName !== null ? { [keyName]: key } : {}),\n                    }, '__idata', { enumerable: false, value: true });\n                    instanceScope.unshift(iterationData);\n                    fragment.push(repeatedNode.bind(null, iterationData)());\n                    instanceScope.shift();\n                }\n                return fragment;\n            });\n        }\n        return createNodes;\n    }\n    /**\n     * Given a schema, parse it and return the resulting renderable nodes.\n     * @param data - The schema context object\n     * @param library - The available components\n     * @param node - The node to parse\n     * @returns\n     */\n    function createElements(library, schema) {\n        if (Array.isArray(schema)) {\n            const els = schema.map(createElement.bind(null, library));\n            return (iterationData) => els.map((element) => element(iterationData));\n        }\n        // Single node to render\n        const element = createElement(library, schema);\n        return (iterationData) => element(iterationData);\n    }\n    /**\n     * Data providers produced as a result of the compiler.\n     */\n    const providers = [];\n    /**\n     * Append the requisite compiler provider and return the compiled function.\n     * @param compiled - A compiled function\n     * @returns\n     */\n    function provider(compiled, hints = {}) {\n        const compiledFns = {};\n        providers.push((callback, key) => {\n            compiledFns[key] = compiled.provide((tokens) => callback(tokens, hints));\n        });\n        return () => compiledFns[instanceKey]();\n    }\n    /**\n     * Creates a new instance of a given schema \u2014 this either comes from a\n     * memoized copy of the parsed schema or a freshly parsed version. An symbol\n     * instance key, and dataProvider functions are passed in.\n     * @param providerCallback - A function that is called for each required provider\n     * @param key - a symbol representing the current instance\n     */\n    return function createInstance(providerCallback, key) {\n        const memoKey = JSON.stringify(schema);\n        const [render, compiledProviders] = has(memo, memoKey)\n            ? memo[memoKey]\n            : [createElements(library, schema), providers];\n        memo[memoKey] = [render, compiledProviders];\n        compiledProviders.forEach((compiledProvider) => {\n            compiledProvider(providerCallback, key);\n        });\n        return () => {\n            instanceKey = key;\n            return render();\n        };\n    };\n}\n/**\n * Checks the current runtime scope for data.\n * @param token - The token to lookup in the current scope\n * @param defaultValue - The default ref value to use if no scope is found.\n */\nfunction useScope(token, defaultValue) {\n    const scopedData = instanceScopes.get(instanceKey) || [];\n    let scopedValue = undefined;\n    if (scopedData.length) {\n        scopedValue = getValue(scopedData, token.split('.'));\n    }\n    return scopedValue === undefined ? defaultValue : scopedValue;\n}\n/**\n * Get the current scoped data and flatten it.\n */\nfunction slotData(data, key) {\n    return new Proxy(data, {\n        get(...args) {\n            let data = undefined;\n            const property = args[1];\n            if (typeof property === 'string') {\n                const prevKey = instanceKey;\n                instanceKey = key;\n                data = useScope(property, undefined);\n                instanceKey = prevKey;\n            }\n            return data !== undefined ? data : Reflect.get(...args);\n        },\n    });\n}\n/**\n * Provides data to a parsed schema.\n * @param provider - The SchemaProvider (output of calling parseSchema)\n * @param data - Data to fetch values from\n * @returns\n */\nfunction createRenderFn(instanceCreator, data, instanceKey) {\n    return instanceCreator((requirements, hints = {}) => {\n        return requirements.reduce((tokens, token) => {\n            if (token.startsWith('slots.')) {\n                const slot = token.substring(6);\n                const hasSlot = data.slots && has(data.slots, slot);\n                if (hints.if) {\n                    // If statement \u2014 dont render the slot, check if it exists\n                    tokens[token] = () => hasSlot;\n                }\n                else if (data.slots && hasSlot) {\n                    // Render the slot with current scope data\n                    const scopedData = slotData(data, instanceKey);\n                    tokens[token] = () => data.slots[slot](scopedData);\n                    return tokens;\n                }\n            }\n            const value = getRef(token, data);\n            tokens[token] = () => useScope(token, value.value);\n            return tokens;\n        }, {});\n    }, instanceKey);\n}\nlet i = 0;\n/**\n * The FormKitSchema vue component:\n * @public\n */\nconst FormKitSchema = defineComponent({\n    name: 'FormKitSchema',\n    props: {\n        schema: {\n            type: [Array, Object],\n            required: true,\n        },\n        data: {\n            type: Object,\n            default: () => ({}),\n        },\n        library: {\n            type: Object,\n            default: () => ({}),\n        },\n    },\n    setup(props, context) {\n        const instance = getCurrentInstance();\n        let instanceKey = Symbol(String(i++));\n        instanceScopes.set(instanceKey, []);\n        let provider = parseSchema(props.library, props.schema);\n        let render;\n        let data;\n        // Re-parse the schema if it changes:\n        watch(() => props.schema, (newSchema, oldSchema) => {\n            var _a;\n            instanceKey = Symbol(String(i++));\n            provider = parseSchema(props.library, props.schema);\n            render = createRenderFn(provider, data, instanceKey);\n            if (newSchema === oldSchema) {\n                ((_a = instance === null || instance === void 0 ? void 0 : instance.proxy) === null || _a === void 0 ? void 0 : _a.$forceUpdate)();\n            }\n        }, { deep: true });\n        // Watch the data object explicitly\n        watchEffect(() => {\n            data = Object.assign(reactive(props.data), {\n                slots: context.slots,\n            });\n            render = createRenderFn(provider, data, instanceKey);\n        });\n        return () => render();\n    },\n});\n\n/**\n * All the explicit FormKit props.\n */\nconst nativeProps = {\n    config: {\n        type: Object,\n        default: {},\n    },\n    classes: {\n        type: Object,\n        required: false,\n    },\n    delay: {\n        type: Number,\n        required: false,\n    },\n    errors: {\n        type: Array,\n        default: [],\n    },\n    inputErrors: {\n        type: Object,\n        default: () => ({}),\n    },\n    id: {\n        type: String,\n        required: false,\n    },\n    modelValue: {\n        required: false,\n    },\n    name: {\n        type: String,\n        required: false,\n    },\n    parent: {\n        type: Object,\n        required: false,\n    },\n    plugins: {\n        type: Array,\n        default: [],\n    },\n    sectionsSchema: {\n        type: Object,\n        default: {},\n    },\n    type: {\n        type: [String, Object],\n        default: 'text',\n    },\n    validation: {\n        type: [String, Array],\n        required: false,\n    },\n    validationMessages: {\n        type: Object,\n        required: false,\n    },\n    validationRules: {\n        type: Object,\n        required: false,\n    },\n    validationLabel: {\n        type: [String, Function],\n        required: false,\n    },\n};\n/**\n * The FormKit props object.\n * @internal\n */\nconst props = nativeProps;\n\n/**\n * The symbol that represents the formkit parent injection value.\n */\nconst parentSymbol = Symbol('FormKitParent');\n/**\n * The root FormKit component.\n * @public\n */\nconst FormKit = defineComponent({\n    props,\n    emits: {\n        /* eslint-disable @typescript-eslint/no-unused-vars */\n        input: (_value) => true,\n        'update:modelValue': (_value) => true,\n        node: (node) => !!node,\n        submit: (_data, _node) => true,\n        submitRaw: (_event) => true,\n        /* eslint-enable @typescript-eslint/no-unused-vars */\n    },\n    inheritAttrs: false,\n    setup(props, context) {\n        const node = useInput(props, context);\n        if (!node.props.definition)\n            error(600, node);\n        if (node.props.definition.component) {\n            return () => {\n                var _a;\n                return h((_a = node.props.definition) === null || _a === void 0 ? void 0 : _a.component, {\n                    context: node.context,\n                }, { ...context.slots });\n            };\n        }\n        const schemaDefinition = node.props.definition.schema;\n        if (!schemaDefinition)\n            error(601, node);\n        const schema = typeof schemaDefinition === 'function'\n            ? schemaDefinition({ ...props.sectionsSchema })\n            : schemaDefinition;\n        context.emit('node', node);\n        const library = node.props.definition.library;\n        // Expose the FormKitNode to template refs.\n        context.expose({ node });\n        return () => h(FormKitSchema, { schema, data: node.context, library }, { ...context.slots });\n    },\n});\n\n/**\n * The Create a new instance of the FormKit plugin for Vue.\n * @param app - A Vue application\n * @param config - FormKit Vue plugin configuration options\n */\nfunction createPlugin(app, options) {\n    app\n        .component(options.alias || 'FormKit', FormKit)\n        .component(options.schemaAlias || 'FormKitSchema', FormKitSchema);\n    return {\n        get: getNode,\n        setLocale: (locale) => {\n            var _a;\n            if ((_a = options.config) === null || _a === void 0 ? void 0 : _a.rootConfig) {\n                options.config.rootConfig.locale = locale;\n            }\n        },\n        setErrors,\n        submit: submitForm,\n        reset,\n    };\n}\n/**\n * The symbol key for accessing the FormKit node options.\n * @public\n */\nconst optionsSymbol = Symbol.for('FormKitOptions');\n/**\n * The symbol key for accessing FormKit root configuration.\n * @public\n */\nconst configSymbol = Symbol.for('FormKitConfig');\n/**\n * Create the FormKit plugin.\n * @public\n */\nconst plugin = {\n    install(app, _options) {\n        /**\n         * Extend the default configuration options.\n         */\n        const options = Object.assign({\n            alias: 'FormKit',\n            schemaAlias: 'FormKitSchema',\n        }, typeof _options === 'function' ? _options() : _options);\n        /**\n         * The root configuration options.\n         */\n        const rootConfig = createConfig(options.config || {});\n        /**\n         * We dont want to explicitly provide any \"config\" options, only a root\n         * config option \u2014 so here we override the existing config options.\n         */\n        options.config = { rootConfig };\n        /**\n         * Register the global $formkit plugin property.\n         */\n        app.config.globalProperties.$formkit = createPlugin(app, options);\n        /**\n         * Provide the config to the application for injection.\n         */\n        app.provide(optionsSymbol, options);\n        /**\n         * Provide the root config to the application.\n         */\n        app.provide(configSymbol, rootConfig);\n    },\n};\n\n/**\n * Props that are extracted from the attrs object.\n * TODO: Currently local, this should probably exported to a inputs or another\n * package.\n */\nconst pseudoProps = [\n    'help',\n    'label',\n    'ignore',\n    'disabled',\n    'preserve',\n    /^[a-z]+(?:-visibility|Visibility)$/,\n    /^[a-zA-Z-]+(?:-class|Class)$/,\n];\n/**\n * Given some props, map those props to individualized props internally.\n * @param node - A formkit node\n * @param props - Some props that may include a classes object\n */\nfunction classesToNodeProps(node, props) {\n    if (props.classes) {\n        Object.keys(props.classes).forEach((key) => {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            node.props[`_${key}Class`] = props.classes[key];\n        });\n    }\n}\n/**\n * Extracts known FormKit listeners.\n * @param props - Extract known FormKit listeners.\n * @returns\n */\nfunction onlyListeners(props) {\n    if (!props)\n        return {};\n    const knownListeners = ['Submit', 'SubmitRaw'].reduce((listeners, listener) => {\n        const name = `on${listener}`;\n        if (name in props) {\n            if (typeof props[name] === 'function') {\n                listeners[name] = props[name];\n            }\n        }\n        return listeners;\n    }, {});\n    return knownListeners;\n}\n/**\n * A composable for creating a new FormKit node.\n * @param type - The type of node (input, group, list)\n * @param attrs - The FormKit \"props\" \u2014 which is really the attrs list.\n * @returns\n * @public\n */\nfunction useInput(props, context, options = {}) {\n    /**\n     * The configuration options, these are provided by either the plugin or by\n     * explicit props.\n     */\n    const config = Object.assign({}, inject(optionsSymbol) || {}, options);\n    /**\n     * The parent node.\n     */\n    const parent = props.parent || inject(parentSymbol, null);\n    /**\n     * The current instance.\n     */\n    const instance = getCurrentInstance();\n    /**\n     * Extracts the listeners.\n     */\n    const listeners = onlyListeners(instance === null || instance === void 0 ? void 0 : instance.vnode.props);\n    /**\n     * Define the initial component\n     */\n    const value = props.modelValue !== undefined\n        ? props.modelValue\n        : cloneAny(context.attrs.value);\n    /**\n     * Creates the node's initial props from the context, props, and definition\n     * @returns\n     */\n    function createInitialProps() {\n        const initialProps = {\n            ...nodeProps(props),\n            ...listeners,\n        };\n        const attrs = except(nodeProps(context.attrs), pseudoProps);\n        initialProps.attrs = attrs;\n        const propValues = only(nodeProps(context.attrs), pseudoProps);\n        for (const propName in propValues) {\n            initialProps[camel(propName)] = propValues[propName];\n        }\n        const classesProps = { props: {} };\n        classesToNodeProps(classesProps, props);\n        Object.assign(initialProps, classesProps.props);\n        if (typeof initialProps.type !== 'string') {\n            initialProps.definition = initialProps.type;\n            delete initialProps.type;\n        }\n        return initialProps;\n    }\n    /**\n     * Create the FormKitNode.\n     */\n    const initialProps = createInitialProps();\n    const node = createNode(extend(config || {}, {\n        name: props.name || undefined,\n        value,\n        parent: initialProps.ignore ? null : parent,\n        plugins: (config.plugins || []).concat(props.plugins),\n        config: props.config,\n        props: initialProps,\n    }, false, true));\n    /**\n     * If no definition has been assigned at this point \u2014 we're out!\n     */\n    if (!node.props.definition)\n        error(600, node);\n    /**\n     * These prop names must be assigned.\n     */\n    const pseudoPropNames = pseudoProps\n        .concat(node.props.definition.props || [])\n        .reduce((names, prop) => {\n        if (typeof prop === 'string') {\n            names.push(camel(prop));\n            names.push(kebab(prop));\n        }\n        else {\n            names.push(prop);\n        }\n        return names;\n    }, []);\n    /* Splits Classes object into discrete props for each key */\n    watchEffect(() => classesToNodeProps(node, props));\n    /**\n     * The props object already has properties even if they start as \"undefined\"\n     * so we can loop over them and individual watchEffect to prevent responding\n     * inappropriately.\n     */\n    const passThrough = nodeProps(props);\n    for (const prop in passThrough) {\n        watch(() => props[prop], () => {\n            if (props[prop] !== undefined) {\n                node.props[prop] = props[prop];\n            }\n        });\n    }\n    /**\n     * Watch \"pseudoProp\" attributes explicitly.\n     */\n    const pseudoPropsValues = only(nodeProps(context.attrs), pseudoPropNames);\n    for (const prop in pseudoPropsValues) {\n        const camelName = camel(prop);\n        watch(() => context.attrs[prop], () => {\n            node.props[camelName] = context.attrs[prop];\n        });\n    }\n    /**\n     * Watch and dynamically set attribute values, those values that are not\n     * props and are not pseudoProps\n     */\n    watchEffect(() => {\n        const attrs = except(nodeProps(context.attrs), pseudoPropNames);\n        node.props.attrs = Object.assign({}, node.props.attrs || {}, attrs);\n    });\n    /**\n     * Add any/all \"prop\" errors to the store.\n     */\n    watchEffect(() => {\n        const messages = props.errors.map((error) => createMessage({\n            key: slugify(error),\n            type: 'error',\n            value: error,\n            meta: { source: 'prop' },\n        }));\n        node.store.apply(messages, (message) => message.type === 'error' && message.meta.source === 'prop');\n    });\n    /**\n     * Add input errors.\n     */\n    if (node.type !== 'input') {\n        const sourceKey = `${node.name}-prop`;\n        watchEffect(() => {\n            const keys = Object.keys(props.inputErrors);\n            const messages = keys.reduce((messages, key) => {\n                let value = props.inputErrors[key];\n                if (typeof value === 'string')\n                    value = [value];\n                if (Array.isArray(value)) {\n                    messages[key] = value.map((error) => createMessage({\n                        key: error,\n                        type: 'error',\n                        value: error,\n                        meta: { source: sourceKey },\n                    }));\n                }\n                return messages;\n            }, {});\n            node.store.apply(messages, (message) => message.type === 'error' && message.meta.source === sourceKey);\n        });\n    }\n    /**\n     * Watch the config prop for any changes.\n     */\n    watchEffect(() => Object.assign(node.config, props.config));\n    /**\n     * Produce another parent object.\n     */\n    if (node.type !== 'input') {\n        provide(parentSymbol, node);\n    }\n    /**\n     * Explicitly watch the input value, and emit changes (lazy)\n     */\n    watch(() => { var _a; return (_a = node.context) === null || _a === void 0 ? void 0 : _a.value; }, () => {\n        var _a, _b;\n        // Emit the values after commit\n        context.emit('input', (_a = node.context) === null || _a === void 0 ? void 0 : _a.value);\n        context.emit('update:modelValue', (_b = node.context) === null || _b === void 0 ? void 0 : _b.value);\n    });\n    /**\n     * Enabled support for v-model, using this for groups/lists is not recommended\n     */\n    if (props.modelValue !== undefined) {\n        // Warning that v-model isnt the most performant for non-inputs:\n        // if (node.type !== 'input') warn()\n        watch(() => props.modelValue, (value) => {\n            node.input(value, false);\n        }, {\n            deep: true,\n        });\n    }\n    /**\n     * When this input shuts down, we need to \"delete\" the node too.\n     */\n    onUnmounted(() => node.destroy());\n    return node;\n}\n\nlet totalCreated = 1;\n/**\n * Determine if the given object is a vue component.\n *\n * @param obj - Object or function\n * @returns\n * @public\n */\nfunction isComponent(obj) {\n    return ((typeof obj === 'function' && obj.length === 2) ||\n        (typeof obj === 'object' &&\n            !Array.isArray(obj) &&\n            !('$el' in obj) &&\n            !('$cmp' in obj) &&\n            !('if' in obj)));\n}\n/**\n * Creates a new input from schema or a Vue component with the \"standard\"\n * FormKit features in place such as labels, help text, validation messages, and\n * class support.\n *\n * @param schemaOrComponent - The actual schema of the input.\n * @public\n */\nfunction createInput(schemaOrComponent, definitionOptions = {}) {\n    const definition = {\n        type: 'input',\n        ...definitionOptions,\n    };\n    let schema = undefined;\n    if (isComponent(schemaOrComponent)) {\n        const cmpName = `SchemaComponent${totalCreated++}`;\n        schema = () => ({\n            $cmp: cmpName,\n            props: {\n                context: '$node.context',\n            },\n        });\n        definition.library = { [cmpName]: markRaw(schemaOrComponent) };\n    }\n    else {\n        schema = schemaOrComponent;\n    }\n    // Use the default wrapping schema\n    definition.schema = useSchema(schema || 'Schema undefined');\n    return definition;\n}\n\n/**\n * A plugin that creates Vue-specific context object on each given node.\n * @param node - FormKitNode to create the context on.\n * @public\n */\nconst vueBindings = function vueBindings(node) {\n    /**\n     * Start a validity counter on all blocking messages.\n     */\n    node.ledger.count('blocking', (m) => m.blocking);\n    const isValid = ref(!node.ledger.value('blocking'));\n    /**\n     * Start an error message counter.\n     */\n    node.ledger.count('errors', (m) => m.type === 'error');\n    const hasErrors = ref(!!node.ledger.value('errors'));\n    /**\n     * All messages with the visibility state set to true.\n     */\n    const availableMessages = reactive(node.store.reduce((store, message) => {\n        if (message.visible) {\n            store[message.key] = message;\n        }\n        return store;\n    }, {}));\n    /**\n     * A flag that determines when validation messages should be displayed.\n     */\n    const validationVisibility = ref(node.props.validationVisibility || 'blur');\n    node.on('props:validationVisibility', ({ payload }) => {\n        validationVisibility.value = payload;\n    });\n    /**\n     * Keep track of if this input has ever shown validation errors.\n     */\n    const hasShownErrors = ref(validationVisibility.value === 'live');\n    /**\n     * The current visibility state of validation messages.\n     */\n    const validationVisible = computed(() => {\n        if (context.state.submitted)\n            return true;\n        if (!hasShownErrors.value && !context.state.settled) {\n            return false;\n        }\n        switch (validationVisibility.value) {\n            case 'live':\n                return true;\n            case 'blur':\n                return context.state.blurred;\n            case 'dirty':\n                return context.state.dirty;\n            default:\n                return false;\n        }\n    });\n    /**\n     * Determines if the input should be considered \"complete\".\n     */\n    const isComplete = computed(() => {\n        return hasValidation.value\n            ? isValid.value && !hasErrors.value\n            : context.state.dirty && !empty(context.value);\n    });\n    /**\n     * If the input has validation rules or not.\n     */\n    const hasValidation = ref(Array.isArray(node.props.parsedRules) && node.props.parsedRules.length > 0);\n    node.on('prop:parsedRules', ({ payload: rules }) => {\n        hasValidation.value = Array.isArray(rules) && rules.length > 0;\n    });\n    /**\n     * All messages that are currently on display to an end user. This changes\n     * based on the current message type visibility, like errorVisibility.\n     */\n    const messages = computed(() => {\n        const visibleMessages = {};\n        for (const key in availableMessages) {\n            const message = availableMessages[key];\n            if (message.type !== 'validation' || validationVisible.value) {\n                visibleMessages[key] = message;\n            }\n        }\n        return visibleMessages;\n    });\n    /**\n     * UI Messages.\n     */\n    const ui = reactive(node.store.reduce((messages, message) => {\n        if (message.type === 'ui' && message.visible)\n            messages[message.key] = message;\n        return messages;\n    }, {}));\n    /**\n     * This is the reactive data object that is provided to all schemas and\n     * forms. It is a subset of data in the core node object.\n     */\n    let inputElement = null;\n    const cachedClasses = reactive({});\n    const classes = new Proxy(cachedClasses, {\n        get(...args) {\n            const [target, property] = args;\n            let className = Reflect.get(...args);\n            if (!className && typeof property === 'string') {\n                if (!has(target, property) && !property.startsWith('__v')) {\n                    const observedNode = createObserver(node);\n                    observedNode.watch((node) => {\n                        const rootClasses = typeof node.config.rootClasses === 'function'\n                            ? node.config.rootClasses(property, node)\n                            : {};\n                        const globalConfigClasses = node.config.classes\n                            ? createClasses(property, node, node.config.classes[property])\n                            : {};\n                        const classesPropClasses = createClasses(property, node, node.props[`_${property}Class`]);\n                        const sectionPropClasses = createClasses(property, node, node.props[`${property}Class`]);\n                        className = generateClassList(node, property, rootClasses, globalConfigClasses, classesPropClasses, sectionPropClasses);\n                        target[property] = className;\n                    });\n                }\n            }\n            return className;\n        },\n    });\n    const describedBy = computed(() => {\n        const describers = [];\n        if (context.help) {\n            describers.push(`help-${node.props.id}`);\n        }\n        for (const key in messages.value) {\n            describers.push(`${node.props.id}-${key}`);\n        }\n        return describers.length ? describers.join(' ') : undefined;\n    });\n    const context = reactive({\n        _value: node.value,\n        attrs: node.props.attrs,\n        disabled: node.props.disabled,\n        describedBy,\n        fns: {\n            length: (obj) => Object.keys(obj).length,\n            number: (value) => Number(value),\n            string: (value) => String(value),\n            json: (value) => JSON.stringify(value),\n        },\n        handlers: {\n            blur: () => node.store.set(createMessage({ key: 'blurred', visible: false, value: true })),\n            touch: () => {\n                node.store.set(createMessage({ key: 'dirty', visible: false, value: true }));\n            },\n            DOMInput: (e) => {\n                inputElement = e.target;\n                node.input(e.target.value);\n            },\n        },\n        help: node.props.help,\n        id: node.props.id,\n        label: node.props.label,\n        messages,\n        node,\n        options: node.props.options,\n        state: {\n            blurred: false,\n            complete: isComplete,\n            dirty: false,\n            submitted: false,\n            settled: node.isSettled,\n            valid: isValid,\n            errors: hasErrors,\n            rules: hasValidation,\n            validationVisible,\n        },\n        type: node.props.type,\n        ui,\n        value: node.value,\n        classes,\n    });\n    /**\n     * Ensure the context object is properly configured after booting up.\n     */\n    node.on('created', () => {\n        if (!eq(context.value, node.value)) {\n            context._value = node.value;\n            context.value = node.value;\n        }\n    });\n    /**\n     * Sets the settled state.\n     */\n    node.on('settled', ({ payload: isSettled }) => {\n        context.state.settled = isSettled;\n    });\n    /**\n     * Observes node.props properties explicitly and updates them in the context\n     * object.\n     * @param observe - Props to observe and register as context data.\n     */\n    function observeProps(observe) {\n        observe.forEach((prop) => {\n            prop = camel(prop);\n            if (!has(context, prop) && has(node.props, prop)) {\n                context[prop] = node.props[prop];\n            }\n            node.on(`prop:${prop}`, ({ payload }) => {\n                context[prop] = payload;\n            });\n        });\n    }\n    /**\n     * We use a node observer to individually observe node props.\n     */\n    const rootProps = [\n        'help',\n        'label',\n        'disabled',\n        'options',\n        'type',\n        'attrs',\n        'id',\n    ];\n    observeProps(rootProps);\n    /**\n     * Once the input is defined, deal with it.\n     * @param definition - Type definition.\n     */\n    function definedAs(definition) {\n        if (definition.props)\n            observeProps(definition.props);\n    }\n    node.props.definition\n        ? definedAs(node.props.definition)\n        : node.on('defined', ({ payload }) => definedAs(payload));\n    /**\n     * Watch for input events from core.\n     */\n    node.on('input', ({ payload }) => {\n        context._value = payload;\n        if (inputElement) {\n            inputElement.value = context._value;\n        }\n    });\n    /**\n     * Watch for input commits from core.\n     */\n    node.on('commit', ({ payload }) => {\n        switch (node.type) {\n            case 'group':\n                context.value = { ...payload };\n                break;\n            case 'list':\n                context.value = [...payload];\n                break;\n            default:\n                context.value = payload;\n        }\n        // The input is dirty after a value has been input by a user\n        if (!context.state.dirty && node.isCreated)\n            context.handlers.touch();\n    });\n    /**\n     * Update the local state in response to messages.\n     * @param message - A formkit message\n     */\n    const updateState = async (message) => {\n        if (message.type === 'ui' &&\n            message.visible &&\n            !message.meta.showAsMessage) {\n            ui[message.key] = message;\n        }\n        else if (message.visible) {\n            availableMessages[message.key] = message;\n        }\n        else if (message.type === 'state') {\n            // await node.settled\n            context.state[message.key] = !!message.value;\n        }\n    };\n    /**\n     * Listen to message events and modify the local message data values.\n     */\n    node.on('message-added', (e) => updateState(e.payload));\n    node.on('message-updated', (e) => updateState(e.payload));\n    node.on('message-removed', ({ payload: message }) => {\n        delete ui[message.key];\n        delete availableMessages[message.key];\n        delete context.state[message.key];\n    });\n    node.on('settled:blocking', () => {\n        isValid.value = true;\n    });\n    node.on('unsettled:blocking', () => {\n        isValid.value = false;\n    });\n    node.on('settled:errors', () => {\n        hasErrors.value = false;\n    });\n    node.on('unsettled:errors', () => {\n        hasErrors.value = true;\n    });\n    /**\n     * Watch the validation visible prop and set the hasShownErrors state.\n     */\n    watch(validationVisible, (value) => {\n        if (value) {\n            hasShownErrors.value = true;\n        }\n    });\n    node.context = context;\n    // The context is complete\n    node.emit('context', node, false);\n};\n\n/**\n * Default configuration options. Includes all validation rules,\n * en i18n messages.\n * @public\n */\nconst defaultConfig = (options = {}) => {\n    const { rules = {}, locales = {}, inputs: inputs$1 = {}, messages = {}, locale = undefined, ...nodeOptions } = options;\n    /**\n     * The default configuration includes the validation plugin,\n     * with all core-available validation rules.\n     */\n    const validation = createValidationPlugin({\n        ...defaultRules,\n        ...(rules || {}),\n    });\n    /**\n     * Includes the i18n plugin with only the english language\n     * messages.\n     */\n    const i18n = createI18nPlugin(extend({ en, ...(locales || {}) }, messages));\n    /**\n     * Create the library of inputs that are generally available. This default\n     * config imports all \"native\" inputs by default, but\n     */\n    const library = createLibraryPlugin(inputs, inputs$1);\n    return extend({\n        plugins: [library, vueBindings, i18n, validation],\n        ...(!locale ? {} : { config: { locale } }),\n    }, nodeOptions || {}, true);\n};\n\nexport { FormKit, FormKitSchema, vueBindings as bindings, configSymbol, createInput, defaultConfig, optionsSymbol, plugin, useInput };\n"],
  "mappings": "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",
  "names": []
}

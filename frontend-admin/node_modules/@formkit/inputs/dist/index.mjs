import { extend, clone, kebab, has, undefine, camel } from '@formkit/utils';
import { warn, createMessage } from '@formkit/core';

const outer = composable('outer', () => ({
    $el: 'div',
    attrs: {
        class: '$classes.outer',
        'data-type': '$type',
        'data-multiple': '$attrs.multiple',
        'data-disabled': '$disabled || undefined',
        'data-complete': '$state.complete || undefined',
        'data-invalid': '$state.valid === false && $state.validationVisible || undefined',
        'data-errors': '$state.errors || undefined',
        'data-submitted': '$state.submitted || undefined',
    },
}));

const wrapper$2 = composable('wrapper', () => ({
    $el: 'div',
    attrs: {
        class: '$classes.wrapper',
    },
}));

const inner = composable('inner', () => ({
    $el: 'div',
    attrs: {
        class: '$classes.inner',
    },
}));

const help = (schema = {}, children = [], target = 'help', cond = '$help') => ({
    if: `$slots.${target}`,
    then: `$slots.${target}`,
    else: extend({
        $el: 'div',
        attrs: {
            id: `$: "help-" + ${target == 'optionHelp' ? '$option.attrs.id' : '$id'}`,
            class: `$classes.${target}`,
        },
        if: cond,
        children,
    }, schema),
});

const messages = composable('messages', () => ({
    $el: 'ul',
    if: '$fns.length($messages)',
    attrs: {
        class: '$classes.messages',
        'aria-live': '$type === "form" && "assertive" || "polite"',
    },
}));

const message = composable('message', () => ({
    $el: 'li',
    for: ['message', '$messages'],
    attrs: {
        key: '$message.key',
        class: '$classes.message',
        id: `$id + '-' + $message.key`,
        'data-message-type': '$message.type',
    },
}));

const prefix = composable('prefix', () => ({ $el: null }));

const suffix = composable('suffix', () => ({ $el: null }));

/**
 * Type guard for schema objects.
 * @param schema - returns true if the node is a schema node but not a string or conditional.
 */
function isSchemaObject(schema) {
    return (typeof schema === 'object' &&
        ('$el' in schema || '$cmp' in schema || '$formkit' in schema));
}
/**
 * Extends a single schema node with an extension. The extension can be any partial node including strings.
 * @param schema - Extend a base schema node.
 * @param extension - The values to extend on the base schema node.
 * @returns
 * @public
 */
function extendSchema(schema, extension = {}) {
    if (typeof schema === 'string') {
        return isSchemaObject(extension) || typeof extension === 'string'
            ? extension
            : schema;
    }
    else if (Array.isArray(schema)) {
        return isSchemaObject(extension) ? extension : schema;
    }
    return extend(schema, extension);
}
/**
 * Creates a new section key.
 *
 * @param key - A new section key name.
 * @param schema - The default schema in this composable slot.
 * @returns
 * @public
 */
function composable(key, schema) {
    return (extendWith = {}, children = undefined) => {
        const root = typeof schema === 'function'
            ? schema(children)
            : typeof schema === 'object'
                ? clone(schema)
                : schema;
        const isObj = isSchemaObject(root);
        if (isObj && !('children' in root) && children) {
            if (Array.isArray(children)) {
                if (children.length) {
                    root.children = children;
                }
            }
            else {
                root.children = [children];
            }
        }
        const extended = extendSchema(root, extendWith);
        return {
            if: `$slots.${key}`,
            then: `$slots.${key}`,
            else: Array.isArray(extended) ? extended : [extended],
        };
    };
}
/**
 * Creates an input schema with all of the wrapping base schema.
 * @param inputSchema - Content to store in the input section key location.
 * @public
 */
function useSchema(inputSchema) {
    return (extensions = {}) => {
        const input = composable('input', inputSchema)(extensions.input);
        return [
            outer(extensions.outer, [
                wrapper$2(extensions.wrapper, [
                    label(extensions.label, '$label'),
                    inner(extensions.inner, [
                        prefix(extensions.prefix),
                        ...(Array.isArray(input) ? input : [input]),
                        suffix(extensions.prefix),
                    ]),
                ]),
                help(extensions.help, '$help'),
                messages(extensions.messages, [
                    message(extensions.message, '$message.value'),
                ]),
            ]),
        ];
    };
}

const label = composable('label', () => ({
    $el: 'label',
    if: '$label',
    attrs: {
        for: '$id',
        class: '$classes.label',
    },
}));

const text$1 = composable('input', () => ({
    $el: 'input',
    bind: '$attrs',
    attrs: {
        type: '$type',
        disabled: '$disabled',
        class: '$classes.input',
        name: '$node.name',
        onInput: '$handlers.DOMInput',
        onBlur: '$handlers.blur',
        value: '$_value',
        id: '$id',
        'aria-describedby': '$describedBy',
    },
}));

/**
 * The schema for text classifications.
 * @public
 */
const textSchema$1 = (extensions = {}) => [
    outer(extensions.outer, [
        wrapper$2(extensions.wrapper, [
            label(extensions.label, '$label'),
            inner(extensions.inner, [
                prefix(extensions.prefix),
                text$1(extensions.input),
                suffix(extensions.suffix),
            ]),
        ]),
        help(extensions.help, '$help'),
        messages(extensions.messages, [
            message(extensions.message, '$message.value'),
        ]),
    ]),
];

const file$1 = composable('input', () => ({
    $el: 'input',
    bind: '$attrs',
    attrs: {
        type: 'file',
        foo: 'bar',
        disabled: '$disabled',
        class: '$classes.input',
        name: '$node.name',
        onChange: '$handlers.files',
        onBlur: '$handlers.blur',
        id: '$id',
        'aria-describedby': '$describedBy',
    },
}));

const fileList = composable('fileList', () => ({
    $el: 'ul',
    if: '$value.length',
    attrs: {
        class: '$classes.fileList',
        'data-has-multiple': {
            if: '$value.length > 1',
            then: 'true',
        },
    },
}));

const fileItem = composable('fileItem', () => ({
    $el: 'li',
    for: ['file', '$value'],
    attrs: {
        class: '$classes.fileItem',
    },
}));

const fileName = composable('fileName', () => ({
    $el: 'span',
    attrs: {
        class: '$classes.fileName',
    },
}));

const noFiles = composable('noFiles', () => ({
    $el: 'span',
    if: '$value.length == 0',
    attrs: {
        class: '$classes.noFiles',
    },
}));

const removeFiles = composable('removeFiles', () => ({
    $el: 'a',
    attrs: {
        href: '#',
        class: '$classes.removeFiles',
        onClick: '$handlers.resetFiles',
    },
}));

/**
 * The schema for text classifications.
 * @public
 */
const fileSchema = (extensions = {}) => [
    outer(extensions.outer, [
        wrapper$2(extensions.wrapper, [
            label(extensions.label, '$label'),
            inner(extensions.inner, [
                prefix(extensions.prefix),
                file$1(extensions.input),
                fileList(extensions.fileList, [
                    fileItem(extensions.file, [
                        fileName(extensions.fileName, '$file.name'),
                        {
                            if: '$value.length == 1',
                            then: removeFiles(extensions.removeFiles, '$ui.remove.value'),
                        },
                    ]),
                ]),
                {
                    if: '$value.length > 1',
                    then: removeFiles(extensions.removeFiles, '$ui.removeAll.value'),
                },
                noFiles(extensions.noFiles, '$ui.noFiles.value'),
                suffix(extensions.suffix),
            ]),
        ]),
        help(extensions.help, '$help'),
        messages(extensions.messages, [
            message(extensions.message, '$message.value'),
        ]),
    ]),
];

const textarea$1 = composable('input', () => ({
    $el: 'textarea',
    bind: '$attrs',
    attrs: {
        class: '$classes.input',
        disabled: '$disabled',
        name: '$node.name',
        onInput: '$handlers.DOMInput',
        onBlur: '$handlers.blur',
        value: '$_value',
        id: '$id',
        'aria-describedby': '$describedBy',
    },
    children: '$initialValue',
}));

/**
 * The schema for textarea classifications.
 * @public
 */
const textareaSchema = (extensions = {}) => [
    outer(extensions.outer, [
        wrapper$2(extensions.wrapper, [
            label(extensions.label, '$label'),
            inner(extensions.inner, [
                prefix(extensions.prefix),
                textarea$1(extensions.input),
                suffix(extensions.suffix),
            ]),
        ]),
        help(extensions.help, '$help'),
        messages(extensions.messages, [
            message(extensions.message, '$message.value'),
        ]),
    ]),
];

/**
 * The schema for text classifications.
 * @public
 */
const hiddenSchema = (extensions = {}) => [
    text$1(extensions.input),
];

const fragment = (schema = {}, children = []) => (Object.keys(schema).length || typeof children !== 'string'
    ? extend({ $el: 'div', children }, schema)
    : children);

const groupSchema = (extensions = {}) => {
    return [fragment(extensions.wrapper, '$slots.default')];
};

const listSchema = (extensions = {}) => {
    return [fragment(extensions.wrapper, '$slots.default')];
};

const select$1 = composable('input', (children) => ({
    $el: 'select',
    bind: '$attrs',
    attrs: {
        id: '$id',
        'data-placeholder': {
            if: '$placeholder',
            then: {
                if: '$value',
                then: undefined,
                else: 'true',
            },
        },
        disabled: '$disabled',
        class: '$classes.input',
        name: '$node.name',
        onInput: '$handlers.selectInput',
        onBlur: '$handlers.blur',
        'aria-describedby': '$describedBy',
    },
    children: {
        if: '$slots.default',
        then: '$slots.default',
        else: children,
    },
}));

const option = (schema = {}, children = []) => ({
    if: '$slots.option',
    then: [
        {
            $el: 'text',
            if: '$options.length',
            for: ['option', '$options'],
            children: '$slots.option',
        },
    ],
    else: extend({
        $el: 'option',
        if: '$options.length',
        for: ['option', '$options'],
        bind: '$option.attrs',
        attrs: {
            class: '$classes.option',
            value: '$option.value',
            selected: '$fns.isSelected($option.value)',
        },
        children,
    }, schema),
});

/**
 * The schema for text classifications.
 * @public
 */
const textSchema = (extensions = {}) => [
    outer(extensions.outer, [
        wrapper$2(extensions.wrapper, [
            label(extensions.label, '$label'),
            inner(extensions.inner, [
                prefix(extensions.prefix),
                select$1(extensions.input, [option(extensions.option, '$option.label')]),
                suffix(extensions.suffix),
            ]),
        ]),
        help(extensions.help, '$help'),
        messages(extensions.messages, [
            message(extensions.message, '$message.value'),
        ]),
    ]),
];

const boxLabel = composable('label', (children) => ({
    $el: 'span',
    if: typeof children === 'string' ? children : '$: true',
    attrs: {
        class: '$classes.label',
    },
}));

const wrapper$1 = composable('wrapper', () => ({
    $el: 'label',
    attrs: {
        class: '$classes.wrapper',
        'data-disabled': {
            if: '$options.length',
            then: undefined,
            else: '$disabled',
        },
    },
}));

const box = composable('input', () => ({
    $el: 'input',
    bind: '$attrs',
    attrs: {
        type: '$type',
        class: '$classes.input',
        name: '$node.props.altName || $node.name',
        disabled: '$option.attrs.disabled || $disabled',
        onInput: '$handlers.toggleChecked',
        checked: '$_value === $onValue',
        onBlur: '$handlers.blur',
        value: '$: true',
        id: '$id',
        'aria-describedby': {
            if: '$options.length',
            then: {
                if: '$option.help',
                then: '$: "help-" + $option.attrs.id',
                else: undefined,
            },
            else: {
                if: '$help',
                then: '$: "help-" + $id',
                else: undefined,
            },
        },
    },
}));

const fieldset = composable('fieldset', () => ({
    $el: 'fieldset',
    attrs: {
        id: '$id',
        class: '$classes.fieldset',
        'aria-describedby': {
            if: '$help',
            then: '$: "help-" + $id',
            else: undefined,
        },
    },
}));

const legend = composable('legend', () => ({
    $el: 'legend',
    if: '$label',
    attrs: {
        class: '$classes.legend',
    },
}));

const boxes = composable('option', () => ({
    $el: 'li',
    for: ['option', '$options'],
    attrs: {
        class: '$classes.option',
        'data-disabled': '$option.attrs.disabled || $disabled',
    },
}));

const wrapper = composable('options', () => ({
    $el: 'ul',
    attrs: {
        class: '$classes.options',
    },
}));

const decorator = composable('decorator', () => ({
    $el: 'span',
    attrs: {
        class: '$classes.decorator',
        'aria-hidden': 'true',
    },
}));

/**
 * The schema for text classifications.
 * @public
 */
const boxSchema = (extensions = {}) => {
    const singleCheckbox = [
        wrapper$1(extensions.wrapper, [
            inner(extensions.inner, [
                prefix(extensions.prefix),
                box(extensions.input),
                decorator(extensions.decorator),
                suffix(extensions.suffix),
            ]),
            boxLabel(extensions.label, '$label'),
        ]),
        help(extensions.help, '$help'),
    ];
    const multiCheckbox = fieldset(extensions.fieldset, [
        legend(extensions.legend, '$label'),
        help(extensions.help, '$help'),
        wrapper(extensions.options, [
            boxes(extensions.option, [
                wrapper$1(extensions.wrapper, [
                    inner(extensions.inner, [
                        prefix(extensions.prefix),
                        box(extend({
                            bind: '$option.attrs',
                            attrs: {
                                id: '$option.attrs.id',
                                value: '$option.value',
                                checked: '$fns.isChecked($option.value)',
                            },
                        }, extensions.input || {})),
                        decorator(extensions.decorator),
                        suffix(extensions.suffix),
                    ]),
                    boxLabel(extensions.label, '$option.label'),
                ]),
                help(extensions.optionHelp, '$option.help', 'optionHelp', '$option.help'),
            ]),
        ]),
    ]);
    return [
        outer(extensions.outer, [
            {
                if: '$options.length',
                then: multiCheckbox,
                else: singleCheckbox,
            },
            messages(extensions.messages, [
                message(extensions.message, '$message.value'),
            ]),
        ]),
    ];
};

const actions = composable('actions', () => ({
    $el: 'div',
    if: '$actions',
    attrs: {
        class: '$classes.actions',
    },
}));

const form$1 = composable('form', () => ({
    $el: 'form',
    bind: '$attrs',
    attrs: {
        id: '$id',
        class: '$classes.form',
        name: '$node.name',
        onSubmit: '$handlers.submit',
        'data-loading': '$state.loading || undefined',
    },
}));

const submit$1 = composable('submit', () => ({
    $cmp: 'FormKit',
    bind: '$submitAttrs',
    props: {
        ignore: true,
        type: 'submit',
        disabled: '$disabled',
        label: '$submitLabel',
    },
}));

const formSchema = (extensions = {}) => {
    return [
        form$1(extensions.form, [
            '$slots.default',
            messages(extensions.messages, [
                message(extensions.message, '$message.value'),
            ]),
            actions(extensions.actions, [submit$1(extensions.submit)]),
        ]),
    ];
};

const button$1 = composable('input', () => ({
    $el: 'button',
    bind: '$attrs',
    attrs: {
        type: '$type',
        disabled: '$disabled',
        class: '$classes.input',
        name: '$node.name',
        id: '$id',
    },
}));

/**
 * The schema for text classifications.
 * @public
 */
const buttonSchema = (extensions = {}) => [
    outer(extensions.outer, [
        messages(extensions.messages, [
            message(extensions.message, '$message.value'),
        ]),
        wrapper$2(extensions.wrapper, [
            button$1(extensions.input, [
                prefix(extensions.prefix),
                {
                    if: '$slots.default',
                    then: '$slots.default',
                    else: {
                        if: '$label',
                        then: '$label',
                        else: '$ui.submit.value',
                    },
                },
                suffix(extensions.suffix),
            ]),
        ]),
        help(extensions.help, '$help'),
    ]),
];

/**
 * Accepts an array of objects, array of strings, or object of key-value pairs.
 * and returns an array of objects with value and label properties.
 * @param options -
 */
function normalizeOptions(options) {
    if (Array.isArray(options)) {
        return options.map((option) => {
            if (typeof option === 'string' || typeof option === 'number') {
                return {
                    label: option,
                    value: option,
                };
            }
            return option;
        });
    }
    return Object.keys(options).map((value) => {
        return {
            label: options[value],
            value,
        };
    });
}
/**
 * Converts the options prop to usable values.
 * @param node - A formkit node.
 */
function formatsOptions (node) {
    node.hook.prop((prop, next) => {
        if (prop.prop === 'options') {
            const options = normalizeOptions(prop.value);
            prop.value = options;
        }
        return next(prop);
    });
}

/**
 * Checks if a the given option should have the selected attribute.
 * @param node - The node being evaluated.
 * @param option - The option value to check
 * @returns
 */
function isSelected(node, option) {
    // Here we trick reactivity (if at play) to watch this function.
    node.context && node.context.value;
    return Array.isArray(node._value)
        ? node._value.includes(option)
        : (node.value === undefined && !option) || node._value == option;
}
/**
 * Select the correct values.
 * @param e - The input event emitted by the select.
 */
function selectInput(node, e) {
    const target = e.target;
    const value = target.hasAttribute('multiple')
        ? Array.from(target.selectedOptions).map((o) => o.value)
        : target.value;
    node.input(value);
}
/**
 * Appends a placeholder to the options list.
 * @param options - An options list
 * @param placeholder - A placeholder string to append
 * @returns
 */
function applyPlaceholder(options, placeholder) {
    if (!options.some((option) => option.attrs && option.attrs['data-is-placeholder'])) {
        return [
            {
                label: placeholder,
                value: '',
                attrs: {
                    hidden: true,
                    disabled: true,
                    'data-is-placeholder': 'true',
                },
            },
            ...options,
        ];
    }
    return options;
}
/**
 * Converts the options prop to usable values.
 * @param node - A formkit node.
 */
function selectFeatures (node) {
    // Set the initial value of a multi-input
    node.on('created', () => {
        var _a, _b, _c;
        const isMultiple = ((_a = node.props.attrs) === null || _a === void 0 ? void 0 : _a.multiple) !== undefined;
        if (!isMultiple &&
            node.props.placeholder &&
            Array.isArray(node.props.options)) {
            node.hook.prop(({ prop, value }, next) => {
                if (prop === 'options') {
                    value = applyPlaceholder(value, node.props.placeholder);
                }
                return next({ prop, value });
            });
            node.props.options = applyPlaceholder(node.props.options, node.props.placeholder);
        }
        if (isMultiple) {
            if (node.value === undefined) {
                node.input([], false);
            }
        }
        else if (node.context && !node.context.options) {
            // If this input us (probably) using the default slot, we need to add a
            // "value" attribute to get bound
            node.props.attrs = Object.assign({}, node.props.attrs, {
                value: node._value,
            });
            node.on('input', ({ payload }) => {
                node.props.attrs = Object.assign({}, node.props.attrs, {
                    value: payload,
                });
            });
        }
        if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.handlers) {
            node.context.handlers.selectInput = selectInput.bind(null, node);
        }
        if ((_c = node.context) === null || _c === void 0 ? void 0 : _c.fns) {
            node.context.fns.isSelected = isSelected.bind(null, node);
        }
    });
    node.hook.input((value, next) => {
        var _a, _b;
        if (!node.props.placeholder &&
            value === undefined &&
            Array.isArray((_a = node.props) === null || _a === void 0 ? void 0 : _a.options) &&
            node.props.options.length &&
            !('multiple' in ((_b = node.props) === null || _b === void 0 ? void 0 : _b.attrs))) {
            value = node.props.options[0].value;
        }
        return next(value);
    });
}

function normalizeBoxes (node) {
    return function (prop, next) {
        if (prop.prop === 'options' && Array.isArray(prop.value)) {
            prop.value = prop.value.map((option) => {
                var _a;
                if (!((_a = option.attrs) === null || _a === void 0 ? void 0 : _a.id)) {
                    return extend(option, {
                        attrs: { id: `${node.name}-option-${kebab(String(option.value))}` },
                    });
                }
                return option;
            });
            if (node.props.type === 'checkbox' && !Array.isArray(node.value)) {
                if (node.isCreated) {
                    node.input([], false);
                }
                else {
                    node.on('created', () => {
                        if (!Array.isArray(node.value)) {
                            node.input([], false);
                        }
                    });
                }
            }
        }
        return next(prop);
    };
}

/**
 * Event handler when an input is toggled.
 * @param node - The node being toggled
 * @param e - The input even related to the toggling
 */
function toggleChecked$1(node, e) {
    const el = e.target;
    if (el instanceof HTMLInputElement) {
        if (Array.isArray(node.props.options) && node.props.options.length) {
            if (!Array.isArray(node._value)) {
                node.input([el.value]);
            }
            else if (!node._value.includes(el.value)) {
                node.input([...node._value, el.value]);
            }
            else {
                node.input(node._value.filter((val) => val !== el.value));
            }
        }
        else {
            if (el.checked) {
                node.input(node.props.onValue);
            }
            else {
                node.input(node.props.offValue);
            }
        }
    }
}
/**
 * Checks if a given option is present in the node value.
 * @param node - The node being checked
 * @param value - The value of any option
 * @returns
 */
function isChecked$1(node, value) {
    var _a, _b;
    // We need to force vue’s reactivity to respond when the value is run:
    (_a = node.context) === null || _a === void 0 ? void 0 : _a.value;
    (_b = node.context) === null || _b === void 0 ? void 0 : _b._value;
    return Array.isArray(node._value) ? node._value.includes(value) : false;
}
/**
 * Adds checkbox selection support
 * @param node - Node the feature is added to
 */
function checkboxes (node) {
    node.on('created', () => {
        var _a, _b;
        if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {
            node.context.handlers.toggleChecked = toggleChecked$1.bind(null, node);
        }
        if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.fns) {
            node.context.fns.isChecked = isChecked$1.bind(null, node);
        }
        // Configure our default onValue and offValue
        if (!has(node.props, 'onValue'))
            node.props.onValue = true;
        if (!has(node.props, 'offValue'))
            node.props.offValue = false;
    });
    node.hook.prop(normalizeBoxes(node));
}

/**
 * Sets the value of a radio button when checked.
 * @param node - FormKitNode
 * @param value - Value
 */
function toggleChecked(node, event) {
    if (event.target instanceof HTMLInputElement) {
        node.input(event.target.value);
    }
}
/**
 * Checks if the value being checked is the current value.
 * @param node - The node to check against.
 * @param value - The value to check
 * @returns
 */
function isChecked(node, value) {
    var _a, _b;
    // We need to force vue’s reactivity to respond when the value is run:
    (_a = node.context) === null || _a === void 0 ? void 0 : _a.value;
    (_b = node.context) === null || _b === void 0 ? void 0 : _b._value;
    return node._value == value;
}
/**
 * Determines if a given radio input is being evaluated.
 * @param node - The radio input group.
 */
function radios(node) {
    node.on('created', () => {
        var _a, _b;
        if (!Array.isArray(node.props.options)) {
            warn(350, node);
        }
        if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {
            node.context.handlers.toggleChecked = toggleChecked.bind(null, node);
        }
        if ((_b = node.context) === null || _b === void 0 ? void 0 : _b.fns) {
            node.context.fns.isChecked = isChecked.bind(null, node);
        }
    });
    node.hook.prop(normalizeBoxes(node));
}

/**
 * Allows disabling children of this.
 * @param node - The FormKitNode of the form/group/list
 */
function disablesChildren (node) {
    node.hook.prop(({ prop, value }, next) => {
        value = prop === 'disabled' ? undefine(value) : value;
        return next({ prop, value });
    });
    node.on('prop:disabled', ({ payload: value }) => {
        node.config.disabled = value;
    });
    node.on('created', () => {
        node.config.disabled = undefine(node.props.disabled);
    });
}

/**
 * Handle the submit event.
 * @param e - The event
 */
async function handleSubmit(node, submitEvent) {
    submitEvent.preventDefault();
    await node.settled;
    // Set the submitted state on all children
    node.walk((n) => {
        n.store.set(createMessage({
            key: 'submitted',
            value: true,
            visible: false,
        }));
    });
    if (typeof node.props.onSubmitRaw === 'function') {
        node.props.onSubmitRaw(submitEvent);
    }
    if (node.ledger.value('blocking')) {
        // There is still a blocking message in the store.
        if (node.props.incompleteMessage !== false) {
            node.store.set(createMessage({
                blocking: false,
                key: `incomplete`,
                meta: {
                    localize: node.props.incompleteMessage === undefined,
                    i18nArgs: [{ node }],
                    showAsMessage: true,
                },
                type: 'ui',
                value: node.props.incompleteMessage || 'Form incomplete.',
            }));
        }
    }
    else {
        // No blocking messages
        if (typeof node.props.onSubmit === 'function') {
            // call onSubmit
            const retVal = node.props.onSubmit(clone(node.value), node);
            if (retVal instanceof Promise) {
                const autoDisable = node.props.disabled === undefined &&
                    node.props.submitBehavior !== 'live';
                if (autoDisable)
                    node.props.disabled = true;
                node.store.set(createMessage({
                    key: 'loading',
                    value: true,
                    visible: false,
                }));
                await retVal;
                if (autoDisable)
                    node.props.disabled = false;
                node.store.remove('loading');
            }
        }
        else {
            if (submitEvent.target instanceof HTMLFormElement) {
                submitEvent.target.submit();
            }
        }
    }
}
/**
 * Converts the options prop to usable values.
 * @param node - A formkit node.
 */
function formHandler (node) {
    node.props.isForm = true;
    node.on('created', () => {
        var _a;
        if ((_a = node.context) === null || _a === void 0 ? void 0 : _a.handlers) {
            node.context.handlers.submit = handleSubmit.bind(null, node);
        }
        if (!has(node.props, 'actions')) {
            node.props.actions = true;
        }
    });
    node.on('settled:blocking', () => node.store.remove('incomplete'));
}

/**
 * Creates a new feature that generates a localization message of type ui
 * for use on a given component.
 *
 * @param key - The key of the message
 * @param value - The value of the message
 * @returns
 * @public
 */
function localize(key, value) {
    return (node) => {
        node.store.set(createMessage({
            key,
            type: 'ui',
            value: value || key,
            meta: {
                localize: true,
                i18nArgs: [node],
            },
        }));
    };
}

const isBrowser = typeof window !== 'undefined';
/**
 * Remove the data-file-hover attribute from the target.
 * @param e - Event
 */
function removeHover(e) {
    if (e.target instanceof HTMLElement &&
        e.target.hasAttribute('data-file-hover')) {
        e.target.removeAttribute('data-file-hover');
    }
}
/**
 * Prevent stray drag/drop events from navigating the window.
 * @param e - Event
 */
function preventStrayDrop(type, e) {
    if (!(e.target instanceof HTMLInputElement)) {
        e.preventDefault();
    }
    else if (type === 'dragover') {
        e.target.setAttribute('data-file-hover', 'true');
    }
    if (type === 'drop') {
        removeHover(e);
    }
}
function files (node) {
    // Localize our content:
    localize('noFiles', 'Select file')(node);
    localize('removeAll', 'Remove all')(node);
    localize('remove')(node);
    if (isBrowser) {
        if (!window._FormKit_File_Drop) {
            window.addEventListener('dragover', preventStrayDrop.bind(null, 'dragover'));
            window.addEventListener('drop', preventStrayDrop.bind(null, 'drop'));
            window.addEventListener('dragleave', removeHover);
            window._FormKit_File_Drop = true;
        }
    }
    node.on('created', () => {
        if (!Array.isArray(node.value)) {
            node.input([], false);
        }
        if (!node.context)
            return;
        node.context.handlers.resetFiles = (e) => {
            e.preventDefault();
            node.input([]);
            if (node.props.id && isBrowser) {
                const el = document.getElementById(node.props.id);
                if (el)
                    el.value = '';
            }
        };
        node.context.handlers.files = (e) => {
            var _a, _b;
            const files = [];
            if (e.target instanceof HTMLInputElement && e.target.files) {
                for (let i = 0; i < e.target.files.length; i++) {
                    let file;
                    if ((file = e.target.files.item(i))) {
                        files.push({ name: file.name, file });
                    }
                }
                node.input(files);
            }
            if (node.context)
                node.context.files = files;
            // Call the original listener if there is one.
            if (typeof ((_a = node.props.attrs) === null || _a === void 0 ? void 0 : _a.onChange) === 'function') {
                (_b = node.props.attrs) === null || _b === void 0 ? void 0 : _b.onChange(e);
            }
        };
    });
}

/**
 * Applies ignore="true" by default.
 * @param node - The node
 */
function ignore (node) {
    if (node.props.ignore === undefined) {
        node.props.ignore = true;
        node.parent = null;
    }
}

function initialValue(node) {
    node.on('created', () => {
        if (node.context) {
            node.context.initialValue = node.value || '';
        }
    });
}

/**
 * Default classifications that are available.
 */
const textClassification = {
    type: 'input',
    schema: textSchema$1,
};
/**
 * The color input.
 * @public
 */
const color = textClassification;
/**
 * The date input.
 * @public
 */
const date = textClassification;
/**
 * The datetime-local input.
 * @public
 */
const datetimeLocal = textClassification;
/**
 * The email input.
 * @public
 */
const email = textClassification;
/**
 * The month input.
 * @public
 */
const month = textClassification;
/**
 * The number input.
 * @public
 */
const number = textClassification;
/**
 * The password input.
 * @public
 */
const password = textClassification;
/**
 * The search input.
 * @public
 */
const search = textClassification;
/**
 * The tel input.
 * @public
 */
const tel = textClassification;
/**
 * The time input.
 * @public
 */
const time = textClassification;
/**
 * The text input.
 * @public
 */
const text = textClassification;
/**
 * The url input.
 * @public
 */
const url = textClassification;
/**
 * The week input.
 * @public
 */
const week = textClassification;
/**
 * The range input.
 * @public
 */
const range = textClassification;
/**
 * The textarea input.
 * @public
 */
const textarea = {
    type: 'input',
    schema: textareaSchema,
    features: [initialValue],
};
/**
 * Buttons are all this classification:
 */
const buttonClassification = {
    type: 'input',
    schema: buttonSchema,
    features: [localize('submit'), ignore],
};
/**
 * The submit input.
 * @public
 */
const submit = buttonClassification;
/**
 * The button classification.
 * @public
 */
const button = buttonClassification;
/**
 * The hidden input.
 * @public
 */
const hidden = {
    type: 'input',
    schema: hiddenSchema,
};
/**
 * The group input type.
 * @public
 */
const select = {
    type: 'input',
    schema: textSchema,
    props: ['options', 'placeholder'],
    features: [formatsOptions, selectFeatures],
};
/**
 * The checkbox input type.
 * @public
 */
const checkbox = {
    type: 'input',
    schema: boxSchema,
    props: ['options', 'onValue', 'offValue'],
    features: [formatsOptions, checkboxes],
};
/**
 * The radio input type.
 * @public
 */
const radio = {
    type: 'input',
    schema: boxSchema,
    props: ['options'],
    features: [formatsOptions, radios],
};
/**
 * The group input type.
 * @public
 */
const group = {
    type: 'group',
    schema: groupSchema,
    features: [disablesChildren],
};
/**
 * The group input type.
 * @public
 */
const form = {
    type: 'group',
    schema: formSchema,
    props: [
        'actions',
        'submit',
        'submitLabel',
        'submitAttrs',
        'submitBehavior',
        'incompleteMessage',
    ],
    features: [formHandler, disablesChildren],
};
/**
 * The group input type.
 * @public
 */
const list = {
    type: 'list',
    schema: listSchema,
    features: [disablesChildren],
};
/**
 * The file input.
 * @public
 */
const file = {
    type: 'input',
    schema: fileSchema,
    features: [files],
    props: ['files'],
};

var inputs = /*#__PURE__*/Object.freeze({
    __proto__: null,
    color: color,
    date: date,
    datetimeLocal: datetimeLocal,
    email: email,
    month: month,
    number: number,
    password: password,
    search: search,
    tel: tel,
    time: time,
    text: text,
    url: url,
    week: week,
    range: range,
    textarea: textarea,
    submit: submit,
    button: button,
    hidden: hidden,
    select: select,
    checkbox: checkbox,
    radio: radio,
    group: group,
    form: form,
    list: list,
    file: file
});

/**
 *
 * @param libraries - One or many formkit urls.
 * @returns
 * @public
 */
function createLibraryPlugin(...libraries) {
    /**
     * Merge all provided library items.
     */
    const library = libraries.reduce((merged, lib) => extend(merged, lib), {});
    /* eslint-disable-next-line @typescript-eslint/no-empty-function */
    const plugin = () => { };
    /**
     * Enables the hook that exposes all library inputs.
     * @param node - The primary plugin
     */
    plugin.library = function (node) {
        const type = camel(node.props.type);
        if (has(library, type)) {
            node.define(library[type]);
        }
    };
    return plugin;
}

export { button, checkbox, color, composable, createLibraryPlugin, date, datetimeLocal, email, extendSchema, file, form, group, hidden, inputs, list, localize, month, number, password, radio, range, search, select, submit, tel, text, textarea, time, url, useSchema, week };

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@formkit/core');
var vue = require('vue');
var utils = require('@formkit/utils');
var inputs = require('@formkit/inputs');
var defaultRules = require('@formkit/rules');
var validation = require('@formkit/validation');
var i18n = require('@formkit/i18n');
var observer = require('@formkit/observer');
require('@formkit/dev');

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var defaultRules__namespace = /*#__PURE__*/_interopNamespace(defaultRules);

/**
 * A registry of memoized schemas (in JSON) to their respective render function
 * and provider registry.
 */
const memo = {};
/**
 * This symbol represents the current component instance during render. It is
 * critical for linking the current instance to the data required for render.
 */
let instanceKey;
/**
 * A registry of scoped data produced during runtime that is keyed by the
 * instance symbol. For example data from: for-loop instances and slot data.
 */
const instanceScopes = new Map();
/**
 * Indicates the a section of the schema is raw.
 */
const raw = '__raw__';
/**
 * Is a class prop.
 */
const isClassProp = /[a-zA-Z0-9\-][cC]lass$/;
/**
 * Returns a reference as a placeholder to a specific location on an object.
 * @param data - A reactive data object
 * @param token - A dot-syntax string representing the object path
 * @returns
 */
function getRef(token, data) {
    const value = vue.ref(null);
    const nodeRef = vue.ref(undefined);
    if (token === 'get') {
        value.value = get.bind(null, nodeRef);
        return value;
    }
    const path = token.split('.');
    vue.watchEffect(() => (value.value = getValue(data, path)));
    return value;
}
/**
 * Returns a value inside a set of data objects.
 * @param sets - An array of objects to search through
 * @param path - A array of string paths easily produced by split()
 * @returns
 */
function getValue(set, path) {
    if (Array.isArray(set)) {
        for (const subset of set) {
            const value = subset !== false && getValue(subset, path);
            if (value !== undefined)
                return value;
        }
        return undefined;
    }
    let foundValue = undefined;
    path.reduce((obj, segment, i, arr) => {
        if (typeof obj !== 'object') {
            foundValue = undefined;
            return arr.splice(1); // Forces an exit
        }
        const currentValue = obj[segment];
        if (i === path.length - 1 && currentValue !== undefined) {
            foundValue = currentValue;
        }
        return obj[segment];
    }, set);
    return foundValue;
}
/**
 * Get the node from the global registry
 * @param id - A dot-syntax string where the node is located.
 */
function get(nodeRef, id) {
    if (typeof id !== 'string')
        return core.warn(650);
    if (nodeRef.value === undefined) {
        nodeRef.value = null;
        const root = core.getNode(id);
        if (root)
            nodeRef.value = root.context;
        core.watchRegistry(id, ({ payload: node }) => {
            nodeRef.value = core.isNode(node) ? node.context : node;
        });
    }
    return nodeRef.value;
}
/**
 *
 * @param library - A library of concrete components to use
 * @param schema -
 * @returns
 */
function parseSchema(library, schema) {
    /**
     * Given an if/then/else schema node, pre-compile the node and return the
     * artifacts for the render function.
     * @param data - The schema context object
     * @param library - The available components
     * @param node - The node to parse
     */
    function parseCondition(library, node) {
        const condition = provider(core.compile(node.if), { if: true });
        const children = createElements(library, node.then);
        const alternate = node.else ? createElements(library, node.else) : null;
        return [condition, children, alternate];
    }
    /**
     * Parses a conditional if/then/else attribute statement.
     * @param data - The data object
     * @param attr - The attribute
     * @param _default - The default value
     * @returns
     */
    function parseConditionAttr(attr, _default) {
        var _a, _b;
        const condition = provider(core.compile(attr.if));
        let b = () => _default;
        let a = () => _default;
        if (typeof attr.then === 'object') {
            a = parseAttrs(attr.then, undefined);
        }
        else if (typeof attr.then === 'string' && ((_a = attr.then) === null || _a === void 0 ? void 0 : _a.startsWith('$'))) {
            a = provider(core.compile(attr.then));
        }
        else {
            a = () => attr.then;
        }
        if (utils.has(attr, 'else')) {
            if (typeof attr.else === 'object') {
                b = parseAttrs(attr.else);
            }
            else if (typeof attr.else === 'string' && ((_b = attr.else) === null || _b === void 0 ? void 0 : _b.startsWith('$'))) {
                b = provider(core.compile(attr.else));
            }
            else {
                b = () => attr.else;
            }
        }
        return () => (condition() ? a() : b());
    }
    /**
     * Parse attributes for dynamic content.
     * @param attrs - Object of attributes
     * @returns
     */
    function parseAttrs(unparsedAttrs, bindExp, _default = {}) {
        const explicitAttrs = new Set(Object.keys(unparsedAttrs || {}));
        const boundAttrs = bindExp ? provider(core.compile(bindExp)) : () => ({});
        const staticAttrs = {};
        const setters = [
            (attrs) => {
                const bound = boundAttrs();
                for (const attr in bound) {
                    if (!explicitAttrs.has(attr)) {
                        attrs[attr] = bound[attr];
                    }
                }
            },
        ];
        if (unparsedAttrs) {
            if (core.isConditional(unparsedAttrs)) {
                // This is a root conditional object that must produce an object of
                // attributes.
                const condition = parseConditionAttr(unparsedAttrs, _default);
                return condition;
            }
            // Some attributes are explicitly bound, we need to parse those ones
            // using the compiler and create a dynamic "setter".
            for (let attr in unparsedAttrs) {
                const value = unparsedAttrs[attr];
                let getValue;
                const isStr = typeof value === 'string';
                if (attr.startsWith(raw)) {
                    // attributes prefixed with __raw__ should not be parsed
                    attr = attr.substring(7);
                    getValue = () => value;
                }
                else if (isStr &&
                    value.startsWith('$') &&
                    value.length > 1 &&
                    !(value.startsWith('$reset') && isClassProp.test(attr))) {
                    // Most attribute values starting with $ should be compiled
                    // -class attributes starting with `$reset` should not be compiled
                    getValue = provider(core.compile(value));
                }
                else if (typeof value === 'object' && core.isConditional(value)) {
                    // Conditional attrs require further processing
                    getValue = parseConditionAttr(value, undefined);
                }
                else if (typeof value === 'object' && utils.isPojo(value)) {
                    // Sub-parse pojos
                    getValue = parseAttrs(value);
                }
                else {
                    // In all other cases, the value is static
                    getValue = () => value;
                    staticAttrs[attr] = value;
                }
                setters.push((attrs) => {
                    attrs[attr] = getValue();
                });
            }
        }
        return () => {
            const attrs = {};
            setters.forEach((setter) => setter(attrs));
            return attrs;
        };
    }
    /**
     * Given a single schema node, parse it and extract the value.
     * @param data - A state object provided to each node
     * @param node - The schema node being parsed
     * @returns
     */
    function parseNode(library, _node) {
        let element = null;
        let attrs = () => null;
        let condition = false;
        let children = null;
        let alternate = null;
        let iterator = null;
        let resolve = false;
        const node = core.sugar(_node);
        if (core.isDOM(node)) {
            // This is an actual HTML DOM element
            element = node.$el;
            attrs =
                node.$el !== 'text' ? parseAttrs(node.attrs, node.bind) : () => null;
        }
        else if (core.isComponent(node)) {
            // This is a Vue Component
            if (typeof node.$cmp === 'string') {
                if (utils.has(library, node.$cmp)) {
                    element = library[node.$cmp];
                }
                else {
                    element = node.$cmp;
                    resolve = true;
                }
            }
            else {
                // in this case it must be an actual component
                element = node.$cmp;
            }
            attrs = parseAttrs(node.props, node.bind);
        }
        else if (core.isConditional(node)) {
            [condition, children, alternate] = parseCondition(library, node);
        }
        // This is the same as a "v-if" statement — not an if/else statement
        if (!core.isConditional(node) && 'if' in node) {
            condition = provider(core.compile(node.if));
        }
        else if (!core.isConditional(node) && element === null) {
            // In this odd case our element is actually a partial and
            // we only want to render the children.
            condition = () => true;
        }
        // Compile children down to a function
        if ('children' in node && node.children) {
            if (typeof node.children === 'string') {
                // We are dealing with a raw string value
                if (node.children.startsWith('$slots.')) {
                    // this is a lone text node, turn it into a slot
                    element = element === 'text' ? 'slot' : element;
                    children = provider(core.compile(node.children));
                }
                else if (node.children.startsWith('$') && node.children.length > 1) {
                    const value = provider(core.compile(node.children));
                    children = () => String(value());
                }
                else {
                    children = () => String(node.children);
                }
            }
            else if (Array.isArray(node.children)) {
                // We are dealing with node sub-children
                children = createElements(library, node.children);
            }
            else {
                // This is a conditional if/else clause
                const [childCondition, c, a] = parseCondition(library, node.children);
                children = (iterationData) => childCondition && childCondition()
                    ? c && c(iterationData)
                    : a && a(iterationData);
            }
        }
        if (core.isComponent(node)) {
            if (children) {
                // Children of components need to be provided as an object of slots
                // so we provide an object with the default slot provided as children.
                // We also create a new scope for this default slot, and then on each
                // render pass the scoped slot props to the scope.
                const produceChildren = children;
                children = (iterationData) => {
                    return {
                        default(slotData, key) {
                            var _a, _b, _c, _d;
                            // We need to switch the current instance key back to the one that
                            // originally called this component's render function.
                            const currentKey = instanceKey;
                            if (key)
                                instanceKey = key;
                            if (slotData)
                                (_a = instanceScopes.get(instanceKey)) === null || _a === void 0 ? void 0 : _a.unshift(slotData);
                            if (iterationData)
                                (_b = instanceScopes.get(instanceKey)) === null || _b === void 0 ? void 0 : _b.unshift(iterationData);
                            const c = produceChildren(iterationData);
                            // Ensure our instance key never changed during runtime
                            if (slotData)
                                (_c = instanceScopes.get(instanceKey)) === null || _c === void 0 ? void 0 : _c.shift();
                            if (iterationData)
                                (_d = instanceScopes.get(instanceKey)) === null || _d === void 0 ? void 0 : _d.shift();
                            instanceKey = currentKey;
                            return c;
                        },
                    };
                };
                children.slot = true;
            }
            else {
                // If we dont have any children, we still need to provide an object
                // instead of an empty array (which raises a warning in vue)
                children = () => ({});
            }
        }
        // Compile the for loop down
        if ('for' in node && node.for) {
            const values = node.for.length === 3 ? node.for[2] : node.for[1];
            const getValues = typeof values === 'string' && values.startsWith('$')
                ? provider(core.compile(values))
                : () => values;
            iterator = [
                getValues,
                node.for[0],
                node.for.length === 3 ? String(node.for[1]) : null,
            ];
        }
        return [condition, element, attrs, children, alternate, iterator, resolve];
    }
    /**
     * Given a particular function that produces children, ensure that the second
     * argument of all these slots is the original instance key being used to
     * render the slots.
     * @param children - The children() function that will produce slots
     */
    function createSlots(children, iterationData) {
        const slots = children(iterationData);
        const currentKey = instanceKey;
        return Object.keys(slots).reduce((allSlots, slotName) => {
            const slotFn = slots && slots[slotName];
            allSlots[slotName] = (data) => {
                return (slotFn && slotFn(data, currentKey)) || null;
            };
            return allSlots;
        }, {});
    }
    /**
     * Creates an element
     * @param data - The context data available to the node
     * @param node - The schema node to render
     * @returns
     */
    function createElement(library, node) {
        // Parses the schema node into pertinent parts
        const [condition, element, attrs, children, alternate, iterator, resolve] = parseNode(library, node);
        // This is a sub-render function (called within a render function). It must
        // only use pre-compiled features, and be organized in the most efficient
        // manner possible.
        let createNodes = ((iterationData) => {
            if (condition && element === null && children) {
                // Handle conditional if/then statements
                return condition()
                    ? children(iterationData)
                    : alternate && alternate(iterationData);
            }
            if (element && (!condition || condition())) {
                // handle text nodes
                if (element === 'text' && children) {
                    return vue.createTextVNode(String(children()));
                }
                // Handle lone slots
                if (element === 'slot' && children)
                    return children(iterationData);
                // Handle resolving components
                const el = resolve ? vue.resolveComponent(element) : element;
                // If we are rendering slots as children, ensure their instanceKey is properly added
                const slots = (children === null || children === void 0 ? void 0 : children.slot)
                    ? createSlots(children, iterationData)
                    : null;
                // Handle dom elements and components
                return vue.h(el, attrs(), (slots || (children ? children(iterationData) : [])));
            }
            return typeof alternate === 'function'
                ? alternate(iterationData)
                : alternate;
        });
        if (iterator) {
            const repeatedNode = createNodes;
            const [getValues, valueName, keyName] = iterator;
            createNodes = (() => {
                const _v = getValues();
                const values = !isNaN(_v)
                    ? Array(Number(_v))
                        .fill(0)
                        .map((_, i) => i)
                    : _v;
                const fragment = [];
                if (typeof values !== 'object')
                    return null;
                const instanceScope = instanceScopes.get(instanceKey) || [];
                for (const key in values) {
                    const iterationData = Object.defineProperty({
                        ...instanceScope.reduce((previousIterationData, scopedData) => {
                            if (previousIterationData.__idata) {
                                return { ...previousIterationData, ...scopedData };
                            }
                            return scopedData;
                        }, {}),
                        [valueName]: values[key],
                        ...(keyName !== null ? { [keyName]: key } : {}),
                    }, '__idata', { enumerable: false, value: true });
                    instanceScope.unshift(iterationData);
                    fragment.push(repeatedNode.bind(null, iterationData)());
                    instanceScope.shift();
                }
                return fragment;
            });
        }
        return createNodes;
    }
    /**
     * Given a schema, parse it and return the resulting renderable nodes.
     * @param data - The schema context object
     * @param library - The available components
     * @param node - The node to parse
     * @returns
     */
    function createElements(library, schema) {
        if (Array.isArray(schema)) {
            const els = schema.map(createElement.bind(null, library));
            return (iterationData) => els.map((element) => element(iterationData));
        }
        // Single node to render
        const element = createElement(library, schema);
        return (iterationData) => element(iterationData);
    }
    /**
     * Data providers produced as a result of the compiler.
     */
    const providers = [];
    /**
     * Append the requisite compiler provider and return the compiled function.
     * @param compiled - A compiled function
     * @returns
     */
    function provider(compiled, hints = {}) {
        const compiledFns = {};
        providers.push((callback, key) => {
            compiledFns[key] = compiled.provide((tokens) => callback(tokens, hints));
        });
        return () => compiledFns[instanceKey]();
    }
    /**
     * Creates a new instance of a given schema — this either comes from a
     * memoized copy of the parsed schema or a freshly parsed version. An symbol
     * instance key, and dataProvider functions are passed in.
     * @param providerCallback - A function that is called for each required provider
     * @param key - a symbol representing the current instance
     */
    return function createInstance(providerCallback, key) {
        const memoKey = JSON.stringify(schema);
        const [render, compiledProviders] = utils.has(memo, memoKey)
            ? memo[memoKey]
            : [createElements(library, schema), providers];
        memo[memoKey] = [render, compiledProviders];
        compiledProviders.forEach((compiledProvider) => {
            compiledProvider(providerCallback, key);
        });
        return () => {
            instanceKey = key;
            return render();
        };
    };
}
/**
 * Checks the current runtime scope for data.
 * @param token - The token to lookup in the current scope
 * @param defaultValue - The default ref value to use if no scope is found.
 */
function useScope(token, defaultValue) {
    const scopedData = instanceScopes.get(instanceKey) || [];
    let scopedValue = undefined;
    if (scopedData.length) {
        scopedValue = getValue(scopedData, token.split('.'));
    }
    return scopedValue === undefined ? defaultValue : scopedValue;
}
/**
 * Get the current scoped data and flatten it.
 */
function slotData(data, key) {
    return new Proxy(data, {
        get(...args) {
            let data = undefined;
            const property = args[1];
            if (typeof property === 'string') {
                const prevKey = instanceKey;
                instanceKey = key;
                data = useScope(property, undefined);
                instanceKey = prevKey;
            }
            return data !== undefined ? data : Reflect.get(...args);
        },
    });
}
/**
 * Provides data to a parsed schema.
 * @param provider - The SchemaProvider (output of calling parseSchema)
 * @param data - Data to fetch values from
 * @returns
 */
function createRenderFn(instanceCreator, data, instanceKey) {
    return instanceCreator((requirements, hints = {}) => {
        return requirements.reduce((tokens, token) => {
            if (token.startsWith('slots.')) {
                const slot = token.substring(6);
                const hasSlot = data.slots && utils.has(data.slots, slot);
                if (hints.if) {
                    // If statement — dont render the slot, check if it exists
                    tokens[token] = () => hasSlot;
                }
                else if (data.slots && hasSlot) {
                    // Render the slot with current scope data
                    const scopedData = slotData(data, instanceKey);
                    tokens[token] = () => data.slots[slot](scopedData);
                    return tokens;
                }
            }
            const value = getRef(token, data);
            tokens[token] = () => useScope(token, value.value);
            return tokens;
        }, {});
    }, instanceKey);
}
let i = 0;
/**
 * The FormKitSchema vue component:
 * @public
 */
const FormKitSchema = vue.defineComponent({
    name: 'FormKitSchema',
    props: {
        schema: {
            type: [Array, Object],
            required: true,
        },
        data: {
            type: Object,
            default: () => ({}),
        },
        library: {
            type: Object,
            default: () => ({}),
        },
    },
    setup(props, context) {
        const instance = vue.getCurrentInstance();
        let instanceKey = Symbol(String(i++));
        instanceScopes.set(instanceKey, []);
        let provider = parseSchema(props.library, props.schema);
        let render;
        let data;
        // Re-parse the schema if it changes:
        vue.watch(() => props.schema, (newSchema, oldSchema) => {
            var _a;
            instanceKey = Symbol(String(i++));
            provider = parseSchema(props.library, props.schema);
            render = createRenderFn(provider, data, instanceKey);
            if (newSchema === oldSchema) {
                ((_a = instance === null || instance === void 0 ? void 0 : instance.proxy) === null || _a === void 0 ? void 0 : _a.$forceUpdate)();
            }
        }, { deep: true });
        // Watch the data object explicitly
        vue.watchEffect(() => {
            data = Object.assign(vue.reactive(props.data), {
                slots: context.slots,
            });
            render = createRenderFn(provider, data, instanceKey);
        });
        return () => render();
    },
});

/**
 * All the explicit FormKit props.
 */
const nativeProps = {
    config: {
        type: Object,
        default: {},
    },
    classes: {
        type: Object,
        required: false,
    },
    delay: {
        type: Number,
        required: false,
    },
    errors: {
        type: Array,
        default: [],
    },
    inputErrors: {
        type: Object,
        default: () => ({}),
    },
    id: {
        type: String,
        required: false,
    },
    modelValue: {
        required: false,
    },
    name: {
        type: String,
        required: false,
    },
    parent: {
        type: Object,
        required: false,
    },
    plugins: {
        type: Array,
        default: [],
    },
    sectionsSchema: {
        type: Object,
        default: {},
    },
    type: {
        type: [String, Object],
        default: 'text',
    },
    validation: {
        type: [String, Array],
        required: false,
    },
    validationMessages: {
        type: Object,
        required: false,
    },
    validationRules: {
        type: Object,
        required: false,
    },
    validationLabel: {
        type: [String, Function],
        required: false,
    },
};
/**
 * The FormKit props object.
 * @internal
 */
const props = nativeProps;

/**
 * The symbol that represents the formkit parent injection value.
 */
const parentSymbol = Symbol('FormKitParent');
/**
 * The root FormKit component.
 * @public
 */
const FormKit = vue.defineComponent({
    props,
    emits: {
        /* eslint-disable @typescript-eslint/no-unused-vars */
        input: (_value) => true,
        'update:modelValue': (_value) => true,
        node: (node) => !!node,
        submit: (_data, _node) => true,
        submitRaw: (_event) => true,
        /* eslint-enable @typescript-eslint/no-unused-vars */
    },
    inheritAttrs: false,
    setup(props, context) {
        const node = useInput(props, context);
        if (!node.props.definition)
            core.error(600, node);
        if (node.props.definition.component) {
            return () => {
                var _a;
                return vue.h((_a = node.props.definition) === null || _a === void 0 ? void 0 : _a.component, {
                    context: node.context,
                }, { ...context.slots });
            };
        }
        const schemaDefinition = node.props.definition.schema;
        if (!schemaDefinition)
            core.error(601, node);
        const schema = typeof schemaDefinition === 'function'
            ? schemaDefinition({ ...props.sectionsSchema })
            : schemaDefinition;
        context.emit('node', node);
        const library = node.props.definition.library;
        // Expose the FormKitNode to template refs.
        context.expose({ node });
        return () => vue.h(FormKitSchema, { schema, data: node.context, library }, { ...context.slots });
    },
});

/**
 * The Create a new instance of the FormKit plugin for Vue.
 * @param app - A Vue application
 * @param config - FormKit Vue plugin configuration options
 */
function createPlugin(app, options) {
    app
        .component(options.alias || 'FormKit', FormKit)
        .component(options.schemaAlias || 'FormKitSchema', FormKitSchema);
    return {
        get: core.getNode,
        setLocale: (locale) => {
            var _a;
            if ((_a = options.config) === null || _a === void 0 ? void 0 : _a.rootConfig) {
                options.config.rootConfig.locale = locale;
            }
        },
        setErrors: core.setErrors,
        submit: core.submitForm,
        reset: core.reset,
    };
}
/**
 * The symbol key for accessing the FormKit node options.
 * @public
 */
const optionsSymbol = Symbol.for('FormKitOptions');
/**
 * The symbol key for accessing FormKit root configuration.
 * @public
 */
const configSymbol = Symbol.for('FormKitConfig');
/**
 * Create the FormKit plugin.
 * @public
 */
const plugin = {
    install(app, _options) {
        /**
         * Extend the default configuration options.
         */
        const options = Object.assign({
            alias: 'FormKit',
            schemaAlias: 'FormKitSchema',
        }, typeof _options === 'function' ? _options() : _options);
        /**
         * The root configuration options.
         */
        const rootConfig = core.createConfig(options.config || {});
        /**
         * We dont want to explicitly provide any "config" options, only a root
         * config option — so here we override the existing config options.
         */
        options.config = { rootConfig };
        /**
         * Register the global $formkit plugin property.
         */
        app.config.globalProperties.$formkit = createPlugin(app, options);
        /**
         * Provide the config to the application for injection.
         */
        app.provide(optionsSymbol, options);
        /**
         * Provide the root config to the application.
         */
        app.provide(configSymbol, rootConfig);
    },
};

/**
 * Props that are extracted from the attrs object.
 * TODO: Currently local, this should probably exported to a inputs or another
 * package.
 */
const pseudoProps = [
    'help',
    'label',
    'ignore',
    'disabled',
    'preserve',
    /^[a-z]+(?:-visibility|Visibility)$/,
    /^[a-zA-Z-]+(?:-class|Class)$/,
];
/**
 * Given some props, map those props to individualized props internally.
 * @param node - A formkit node
 * @param props - Some props that may include a classes object
 */
function classesToNodeProps(node, props) {
    if (props.classes) {
        Object.keys(props.classes).forEach((key) => {
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            node.props[`_${key}Class`] = props.classes[key];
        });
    }
}
/**
 * Extracts known FormKit listeners.
 * @param props - Extract known FormKit listeners.
 * @returns
 */
function onlyListeners(props) {
    if (!props)
        return {};
    const knownListeners = ['Submit', 'SubmitRaw'].reduce((listeners, listener) => {
        const name = `on${listener}`;
        if (name in props) {
            if (typeof props[name] === 'function') {
                listeners[name] = props[name];
            }
        }
        return listeners;
    }, {});
    return knownListeners;
}
/**
 * A composable for creating a new FormKit node.
 * @param type - The type of node (input, group, list)
 * @param attrs - The FormKit "props" — which is really the attrs list.
 * @returns
 * @public
 */
function useInput(props, context, options = {}) {
    /**
     * The configuration options, these are provided by either the plugin or by
     * explicit props.
     */
    const config = Object.assign({}, vue.inject(optionsSymbol) || {}, options);
    /**
     * The parent node.
     */
    const parent = props.parent || vue.inject(parentSymbol, null);
    /**
     * The current instance.
     */
    const instance = vue.getCurrentInstance();
    /**
     * Extracts the listeners.
     */
    const listeners = onlyListeners(instance === null || instance === void 0 ? void 0 : instance.vnode.props);
    /**
     * Define the initial component
     */
    const value = props.modelValue !== undefined
        ? props.modelValue
        : utils.cloneAny(context.attrs.value);
    /**
     * Creates the node's initial props from the context, props, and definition
     * @returns
     */
    function createInitialProps() {
        const initialProps = {
            ...utils.nodeProps(props),
            ...listeners,
        };
        const attrs = utils.except(utils.nodeProps(context.attrs), pseudoProps);
        initialProps.attrs = attrs;
        const propValues = utils.only(utils.nodeProps(context.attrs), pseudoProps);
        for (const propName in propValues) {
            initialProps[utils.camel(propName)] = propValues[propName];
        }
        const classesProps = { props: {} };
        classesToNodeProps(classesProps, props);
        Object.assign(initialProps, classesProps.props);
        if (typeof initialProps.type !== 'string') {
            initialProps.definition = initialProps.type;
            delete initialProps.type;
        }
        return initialProps;
    }
    /**
     * Create the FormKitNode.
     */
    const initialProps = createInitialProps();
    const node = core.createNode(utils.extend(config || {}, {
        name: props.name || undefined,
        value,
        parent: initialProps.ignore ? null : parent,
        plugins: (config.plugins || []).concat(props.plugins),
        config: props.config,
        props: initialProps,
    }, false, true));
    /**
     * If no definition has been assigned at this point — we're out!
     */
    if (!node.props.definition)
        core.error(600, node);
    /**
     * These prop names must be assigned.
     */
    const pseudoPropNames = pseudoProps
        .concat(node.props.definition.props || [])
        .reduce((names, prop) => {
        if (typeof prop === 'string') {
            names.push(utils.camel(prop));
            names.push(utils.kebab(prop));
        }
        else {
            names.push(prop);
        }
        return names;
    }, []);
    /* Splits Classes object into discrete props for each key */
    vue.watchEffect(() => classesToNodeProps(node, props));
    /**
     * The props object already has properties even if they start as "undefined"
     * so we can loop over them and individual watchEffect to prevent responding
     * inappropriately.
     */
    const passThrough = utils.nodeProps(props);
    for (const prop in passThrough) {
        vue.watch(() => props[prop], () => {
            if (props[prop] !== undefined) {
                node.props[prop] = props[prop];
            }
        });
    }
    /**
     * Watch "pseudoProp" attributes explicitly.
     */
    const pseudoPropsValues = utils.only(utils.nodeProps(context.attrs), pseudoPropNames);
    for (const prop in pseudoPropsValues) {
        const camelName = utils.camel(prop);
        vue.watch(() => context.attrs[prop], () => {
            node.props[camelName] = context.attrs[prop];
        });
    }
    /**
     * Watch and dynamically set attribute values, those values that are not
     * props and are not pseudoProps
     */
    vue.watchEffect(() => {
        const attrs = utils.except(utils.nodeProps(context.attrs), pseudoPropNames);
        node.props.attrs = Object.assign({}, node.props.attrs || {}, attrs);
    });
    /**
     * Add any/all "prop" errors to the store.
     */
    vue.watchEffect(() => {
        const messages = props.errors.map((error) => core.createMessage({
            key: utils.slugify(error),
            type: 'error',
            value: error,
            meta: { source: 'prop' },
        }));
        node.store.apply(messages, (message) => message.type === 'error' && message.meta.source === 'prop');
    });
    /**
     * Add input errors.
     */
    if (node.type !== 'input') {
        const sourceKey = `${node.name}-prop`;
        vue.watchEffect(() => {
            const keys = Object.keys(props.inputErrors);
            const messages = keys.reduce((messages, key) => {
                let value = props.inputErrors[key];
                if (typeof value === 'string')
                    value = [value];
                if (Array.isArray(value)) {
                    messages[key] = value.map((error) => core.createMessage({
                        key: error,
                        type: 'error',
                        value: error,
                        meta: { source: sourceKey },
                    }));
                }
                return messages;
            }, {});
            node.store.apply(messages, (message) => message.type === 'error' && message.meta.source === sourceKey);
        });
    }
    /**
     * Watch the config prop for any changes.
     */
    vue.watchEffect(() => Object.assign(node.config, props.config));
    /**
     * Produce another parent object.
     */
    if (node.type !== 'input') {
        vue.provide(parentSymbol, node);
    }
    /**
     * Explicitly watch the input value, and emit changes (lazy)
     */
    vue.watch(() => { var _a; return (_a = node.context) === null || _a === void 0 ? void 0 : _a.value; }, () => {
        var _a, _b;
        // Emit the values after commit
        context.emit('input', (_a = node.context) === null || _a === void 0 ? void 0 : _a.value);
        context.emit('update:modelValue', (_b = node.context) === null || _b === void 0 ? void 0 : _b.value);
    });
    /**
     * Enabled support for v-model, using this for groups/lists is not recommended
     */
    if (props.modelValue !== undefined) {
        // Warning that v-model isnt the most performant for non-inputs:
        // if (node.type !== 'input') warn()
        vue.watch(() => props.modelValue, (value) => {
            node.input(value, false);
        }, {
            deep: true,
        });
    }
    /**
     * When this input shuts down, we need to "delete" the node too.
     */
    vue.onUnmounted(() => node.destroy());
    return node;
}

let totalCreated = 1;
/**
 * Determine if the given object is a vue component.
 *
 * @param obj - Object or function
 * @returns
 * @public
 */
function isComponent(obj) {
    return ((typeof obj === 'function' && obj.length === 2) ||
        (typeof obj === 'object' &&
            !Array.isArray(obj) &&
            !('$el' in obj) &&
            !('$cmp' in obj) &&
            !('if' in obj)));
}
/**
 * Creates a new input from schema or a Vue component with the "standard"
 * FormKit features in place such as labels, help text, validation messages, and
 * class support.
 *
 * @param schemaOrComponent - The actual schema of the input.
 * @public
 */
function createInput(schemaOrComponent, definitionOptions = {}) {
    const definition = {
        type: 'input',
        ...definitionOptions,
    };
    let schema = undefined;
    if (isComponent(schemaOrComponent)) {
        const cmpName = `SchemaComponent${totalCreated++}`;
        schema = () => ({
            $cmp: cmpName,
            props: {
                context: '$node.context',
            },
        });
        definition.library = { [cmpName]: vue.markRaw(schemaOrComponent) };
    }
    else {
        schema = schemaOrComponent;
    }
    // Use the default wrapping schema
    definition.schema = inputs.useSchema(schema || 'Schema undefined');
    return definition;
}

/**
 * A plugin that creates Vue-specific context object on each given node.
 * @param node - FormKitNode to create the context on.
 * @public
 */
const vueBindings = function vueBindings(node) {
    /**
     * Start a validity counter on all blocking messages.
     */
    node.ledger.count('blocking', (m) => m.blocking);
    const isValid = vue.ref(!node.ledger.value('blocking'));
    /**
     * Start an error message counter.
     */
    node.ledger.count('errors', (m) => m.type === 'error');
    const hasErrors = vue.ref(!!node.ledger.value('errors'));
    /**
     * All messages with the visibility state set to true.
     */
    const availableMessages = vue.reactive(node.store.reduce((store, message) => {
        if (message.visible) {
            store[message.key] = message;
        }
        return store;
    }, {}));
    /**
     * A flag that determines when validation messages should be displayed.
     */
    const validationVisibility = vue.ref(node.props.validationVisibility || 'blur');
    node.on('props:validationVisibility', ({ payload }) => {
        validationVisibility.value = payload;
    });
    /**
     * Keep track of if this input has ever shown validation errors.
     */
    const hasShownErrors = vue.ref(validationVisibility.value === 'live');
    /**
     * The current visibility state of validation messages.
     */
    const validationVisible = vue.computed(() => {
        if (context.state.submitted)
            return true;
        if (!hasShownErrors.value && !context.state.settled) {
            return false;
        }
        switch (validationVisibility.value) {
            case 'live':
                return true;
            case 'blur':
                return context.state.blurred;
            case 'dirty':
                return context.state.dirty;
            default:
                return false;
        }
    });
    /**
     * Determines if the input should be considered "complete".
     */
    const isComplete = vue.computed(() => {
        return hasValidation.value
            ? isValid.value && !hasErrors.value
            : context.state.dirty && !utils.empty(context.value);
    });
    /**
     * If the input has validation rules or not.
     */
    const hasValidation = vue.ref(Array.isArray(node.props.parsedRules) && node.props.parsedRules.length > 0);
    node.on('prop:parsedRules', ({ payload: rules }) => {
        hasValidation.value = Array.isArray(rules) && rules.length > 0;
    });
    /**
     * All messages that are currently on display to an end user. This changes
     * based on the current message type visibility, like errorVisibility.
     */
    const messages = vue.computed(() => {
        const visibleMessages = {};
        for (const key in availableMessages) {
            const message = availableMessages[key];
            if (message.type !== 'validation' || validationVisible.value) {
                visibleMessages[key] = message;
            }
        }
        return visibleMessages;
    });
    /**
     * UI Messages.
     */
    const ui = vue.reactive(node.store.reduce((messages, message) => {
        if (message.type === 'ui' && message.visible)
            messages[message.key] = message;
        return messages;
    }, {}));
    /**
     * This is the reactive data object that is provided to all schemas and
     * forms. It is a subset of data in the core node object.
     */
    let inputElement = null;
    const cachedClasses = vue.reactive({});
    const classes = new Proxy(cachedClasses, {
        get(...args) {
            const [target, property] = args;
            let className = Reflect.get(...args);
            if (!className && typeof property === 'string') {
                if (!utils.has(target, property) && !property.startsWith('__v')) {
                    const observedNode = observer.createObserver(node);
                    observedNode.watch((node) => {
                        const rootClasses = typeof node.config.rootClasses === 'function'
                            ? node.config.rootClasses(property, node)
                            : {};
                        const globalConfigClasses = node.config.classes
                            ? core.createClasses(property, node, node.config.classes[property])
                            : {};
                        const classesPropClasses = core.createClasses(property, node, node.props[`_${property}Class`]);
                        const sectionPropClasses = core.createClasses(property, node, node.props[`${property}Class`]);
                        className = core.generateClassList(node, property, rootClasses, globalConfigClasses, classesPropClasses, sectionPropClasses);
                        target[property] = className;
                    });
                }
            }
            return className;
        },
    });
    const describedBy = vue.computed(() => {
        const describers = [];
        if (context.help) {
            describers.push(`help-${node.props.id}`);
        }
        for (const key in messages.value) {
            describers.push(`${node.props.id}-${key}`);
        }
        return describers.length ? describers.join(' ') : undefined;
    });
    const context = vue.reactive({
        _value: node.value,
        attrs: node.props.attrs,
        disabled: node.props.disabled,
        describedBy,
        fns: {
            length: (obj) => Object.keys(obj).length,
            number: (value) => Number(value),
            string: (value) => String(value),
            json: (value) => JSON.stringify(value),
        },
        handlers: {
            blur: () => node.store.set(core.createMessage({ key: 'blurred', visible: false, value: true })),
            touch: () => {
                node.store.set(core.createMessage({ key: 'dirty', visible: false, value: true }));
            },
            DOMInput: (e) => {
                inputElement = e.target;
                node.input(e.target.value);
            },
        },
        help: node.props.help,
        id: node.props.id,
        label: node.props.label,
        messages,
        node,
        options: node.props.options,
        state: {
            blurred: false,
            complete: isComplete,
            dirty: false,
            submitted: false,
            settled: node.isSettled,
            valid: isValid,
            errors: hasErrors,
            rules: hasValidation,
            validationVisible,
        },
        type: node.props.type,
        ui,
        value: node.value,
        classes,
    });
    /**
     * Ensure the context object is properly configured after booting up.
     */
    node.on('created', () => {
        if (!utils.eq(context.value, node.value)) {
            context._value = node.value;
            context.value = node.value;
        }
    });
    /**
     * Sets the settled state.
     */
    node.on('settled', ({ payload: isSettled }) => {
        context.state.settled = isSettled;
    });
    /**
     * Observes node.props properties explicitly and updates them in the context
     * object.
     * @param observe - Props to observe and register as context data.
     */
    function observeProps(observe) {
        observe.forEach((prop) => {
            prop = utils.camel(prop);
            if (!utils.has(context, prop) && utils.has(node.props, prop)) {
                context[prop] = node.props[prop];
            }
            node.on(`prop:${prop}`, ({ payload }) => {
                context[prop] = payload;
            });
        });
    }
    /**
     * We use a node observer to individually observe node props.
     */
    const rootProps = [
        'help',
        'label',
        'disabled',
        'options',
        'type',
        'attrs',
        'id',
    ];
    observeProps(rootProps);
    /**
     * Once the input is defined, deal with it.
     * @param definition - Type definition.
     */
    function definedAs(definition) {
        if (definition.props)
            observeProps(definition.props);
    }
    node.props.definition
        ? definedAs(node.props.definition)
        : node.on('defined', ({ payload }) => definedAs(payload));
    /**
     * Watch for input events from core.
     */
    node.on('input', ({ payload }) => {
        context._value = payload;
        if (inputElement) {
            inputElement.value = context._value;
        }
    });
    /**
     * Watch for input commits from core.
     */
    node.on('commit', ({ payload }) => {
        switch (node.type) {
            case 'group':
                context.value = { ...payload };
                break;
            case 'list':
                context.value = [...payload];
                break;
            default:
                context.value = payload;
        }
        // The input is dirty after a value has been input by a user
        if (!context.state.dirty && node.isCreated)
            context.handlers.touch();
    });
    /**
     * Update the local state in response to messages.
     * @param message - A formkit message
     */
    const updateState = async (message) => {
        if (message.type === 'ui' &&
            message.visible &&
            !message.meta.showAsMessage) {
            ui[message.key] = message;
        }
        else if (message.visible) {
            availableMessages[message.key] = message;
        }
        else if (message.type === 'state') {
            // await node.settled
            context.state[message.key] = !!message.value;
        }
    };
    /**
     * Listen to message events and modify the local message data values.
     */
    node.on('message-added', (e) => updateState(e.payload));
    node.on('message-updated', (e) => updateState(e.payload));
    node.on('message-removed', ({ payload: message }) => {
        delete ui[message.key];
        delete availableMessages[message.key];
        delete context.state[message.key];
    });
    node.on('settled:blocking', () => {
        isValid.value = true;
    });
    node.on('unsettled:blocking', () => {
        isValid.value = false;
    });
    node.on('settled:errors', () => {
        hasErrors.value = false;
    });
    node.on('unsettled:errors', () => {
        hasErrors.value = true;
    });
    /**
     * Watch the validation visible prop and set the hasShownErrors state.
     */
    vue.watch(validationVisible, (value) => {
        if (value) {
            hasShownErrors.value = true;
        }
    });
    node.context = context;
    // The context is complete
    node.emit('context', node, false);
};

/**
 * Default configuration options. Includes all validation rules,
 * en i18n messages.
 * @public
 */
const defaultConfig = (options = {}) => {
    const { rules = {}, locales = {}, inputs: inputs$1 = {}, messages = {}, locale = undefined, ...nodeOptions } = options;
    /**
     * The default configuration includes the validation plugin,
     * with all core-available validation rules.
     */
    const validation$1 = validation.createValidationPlugin({
        ...defaultRules__namespace,
        ...(rules || {}),
    });
    /**
     * Includes the i18n plugin with only the english language
     * messages.
     */
    const i18n$1 = i18n.createI18nPlugin(utils.extend({ en: i18n.en, ...(locales || {}) }, messages));
    /**
     * Create the library of inputs that are generally available. This default
     * config imports all "native" inputs by default, but
     */
    const library = inputs.createLibraryPlugin(inputs.inputs, inputs$1);
    return utils.extend({
        plugins: [library, vueBindings, i18n$1, validation$1],
        ...(!locale ? {} : { config: { locale } }),
    }, nodeOptions || {}, true);
};

Object.defineProperty(exports, 'errorHandler', {
    enumerable: true,
    get: function () { return core.errorHandler; }
});
Object.defineProperty(exports, 'reset', {
    enumerable: true,
    get: function () { return core.reset; }
});
Object.defineProperty(exports, 'resetCount', {
    enumerable: true,
    get: function () { return core.resetCount; }
});
Object.defineProperty(exports, 'setErrors', {
    enumerable: true,
    get: function () { return core.setErrors; }
});
Object.defineProperty(exports, 'submitForm', {
    enumerable: true,
    get: function () { return core.submitForm; }
});
exports.FormKit = FormKit;
exports.FormKitSchema = FormKitSchema;
exports.bindings = vueBindings;
exports.configSymbol = configSymbol;
exports.createInput = createInput;
exports.defaultConfig = defaultConfig;
exports.optionsSymbol = optionsSymbol;
exports.plugin = plugin;
exports.useInput = useInput;
